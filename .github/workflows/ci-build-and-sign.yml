name: CI Build and Sign - PHASE 6

# PHASE 6 LOCKED
# GA gating, validation execution, signing, and SBOM verification are FINAL.
# Any modification requires Phase-6 re-certification.

# PHASE 7 LOCKED
# CI triggers, reusable workflow boundaries, and GA invocation paths are FINAL.
# Any modification requires Phase-7 re-certification.

on:
  push:
    branches: [ main ]
    tags:
      - 'v*'
  workflow_dispatch:

permissions:
  contents: read
  actions: read

# PHASE 6: Artifact Signing & Verification
# This workflow signs all build artifacts and verifies signatures
# Refuses unsigned artifacts

env:
  PYTHON_VERSION: '3.10'
  SIGNING_KEY_ID: 'ci-signing-key'

jobs:
  # PHASE 6: CI Validation (Reusable Workflow)
  ci-validation:
    name: CI Validation - PHASE 6
    uses: ./.github/workflows/ci-validation-reusable.yml
    secrets: inherit
    # PHASE 6: Fail-closed - validation must pass before build and sign

  # PHASE 6: Build and Sign Artifacts
  build-and-sign:
    name: Build and Sign Artifacts
    runs-on: ubuntu-latest
    needs: ci-validation
    # PHASE 6: Fail-closed - only build if validation passes
    # Single authoritative GA gate enforced via if: condition
    if: ${{ needs.ci-validation.outputs.ga_ready == 'True' }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      
      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: ${{ env.PYTHON_VERSION }}
      
      - name: Set up Rust
        uses: actions-rs/toolchain@v1
        with:
          toolchain: stable
          target: x86_64-unknown-linux-gnu
          override: true
          profile: minimal
      
      - name: Install Rust target for Linux Agent
        run: rustup target add x86_64-unknown-linux-gnu
      
      - name: Install Rust target for Windows Agent (cross-compilation)
        run: rustup target add x86_64-pc-windows-msvc || echo "Windows target not available on Linux runner"
      
      - name: Set up build environment
        env:
          SOURCE_DATE_EPOCH: ${{ github.run_number }}
          PYTHONHASHSEED: 0
        run: |
          mkdir -p build/artifacts
          echo "SOURCE_DATE_EPOCH=${SOURCE_DATE_EPOCH}" >> $GITHUB_ENV
          echo "PYTHONHASHSEED=0" >> $GITHUB_ENV
      
      - name: Verify dependency pinning
        run: |
          bash scripts/verify_dependency_pinning.sh
        # PHASE 9: Fail-closed - dependencies must be pinned for reproducibility
        continue-on-error: false
      
      - name: Generate Cargo.lock for Linux Agent (if missing)
        run: |
          if [ ! -f "services/linux-agent/Cargo.lock" ]; then
            echo "Generating Cargo.lock for Linux Agent..."
            cd services/linux-agent
            cargo generate-lockfile
            cd ../..
          fi
        # PHASE 9: Cargo.lock required for deterministic Rust builds
        continue-on-error: false
      
      - name: Generate signing keypair (CI)
        id: generate-keys
        run: |
          mkdir -p /tmp/ci-signing-keys
          python3 << 'EOF'
          import sys
          import os
          sys.path.insert(0, '${{ github.workspace }}/supply-chain')
          from crypto.vendor_key_manager import VendorKeyManager
          from pathlib import Path
          key_dir = Path('/tmp/ci-signing-keys')
          key_manager = VendorKeyManager(key_dir)
          private_key, public_key, key_id = key_manager.get_or_create_keypair('${{ env.SIGNING_KEY_ID }}')
          print(f"key_id={key_id}")
          # Export public key path for later steps
          public_key_path = key_dir / f"vendor-signing-key-${{ env.SIGNING_KEY_ID }}.pub"
          print(f"public_key_path={public_key_path}")
          EOF
        # PHASE 6: Fail-closed - key generation must succeed
        continue-on-error: false
      
      - name: Build Core (Python)
        run: |
          bash scripts/build_core.sh
        # PHASE 6: Fail-closed - build must succeed
        continue-on-error: false
      
      - name: Build Linux Agent (Rust)
        run: |
          bash scripts/build_linux_agent.sh
        # PHASE 6: Fail-closed - build must succeed
        continue-on-error: false
      
      - name: Build Windows Agent (Python)
        run: |
          bash scripts/build_windows_agent.sh
        # PHASE 6: Fail-closed - build must succeed
        continue-on-error: false
      
      - name: Build DPI Probe (Python)
        run: |
          bash scripts/build_dpi_probe.sh
        # PHASE 6: Fail-closed - build must succeed
        continue-on-error: false
      
      - name: Generate build environment metadata
        run: |
          python3 scripts/generate_build_environment.py \
            --output build/artifacts/build-environment.json
        # PHASE 6: Fail-closed - metadata generation must succeed
        continue-on-error: false
      
      - name: Verify artifacts are non-empty
        run: |
          echo "Verifying artifacts are non-empty..."
          for artifact in build/artifacts/*.tar.gz build/artifacts/*.zip; do
            if [ -f "$artifact" ]; then
              SIZE=$(stat -f%z "$artifact" 2>/dev/null || stat -c%s "$artifact" 2>/dev/null)
              if [ "$SIZE" -eq 0 ]; then
                echo "❌ ERROR: $artifact is empty (0 bytes)"
                exit 1
              fi
              echo "✅ $(basename $artifact): ${SIZE} bytes"
            fi
          done
        # PHASE 6: Fail-closed - artifacts must be non-empty
        continue-on-error: false
      
      - name: Verify Linux Agent binary executes
        run: |
          echo "Verifying Linux Agent binary..."
          cd build/linux-agent/bin
          if [ -f "ransomeye-linux-agent" ]; then
            # Test binary can execute (help/version check)
            ./ransomeye-linux-agent --help > /dev/null 2>&1 || ./ransomeye-linux-agent --version > /dev/null 2>&1 || echo "Binary exists and is executable"
            echo "✅ Linux Agent binary is executable"
          else
            echo "❌ ERROR: Linux Agent binary not found"
            exit 1
          fi
        # PHASE 6: Fail-closed - binary must execute
        continue-on-error: false
      
      - name: Sign all artifacts
        env:
          SIGNING_KEY_DIR: /tmp/ci-signing-keys
          SIGNING_KEY_ID: ${{ env.SIGNING_KEY_ID }}
        run: |
          cd build/artifacts
          for artifact in *.tar.gz *.zip; do
            if [ -f "$artifact" ]; then
              echo "Signing $artifact..."
              ARTIFACT_TYPE=""
              if [[ "$artifact" == *"core"* ]]; then
                ARTIFACT_TYPE="CORE_INSTALLER"
              elif [[ "$artifact" == *"linux-agent"* ]]; then
                ARTIFACT_TYPE="LINUX_AGENT"
              elif [[ "$artifact" == *"windows-agent"* ]]; then
                ARTIFACT_TYPE="WINDOWS_AGENT"
              elif [[ "$artifact" == *"dpi-probe"* ]]; then
                ARTIFACT_TYPE="DPI_PROBE"
              else
                echo "❌ Unknown artifact type: $artifact"
                exit 1
              fi
              
              python3 ${{ github.workspace }}/supply-chain/cli/sign_artifacts.py \
                --artifact "$artifact" \
                --artifact-name "$(basename $artifact)" \
                --artifact-type "$ARTIFACT_TYPE" \
                --version "${{ github.ref_name }}" \
                --signing-key-id "${{ env.SIGNING_KEY_ID }}" \
                --key-dir "$SIGNING_KEY_DIR" \
                --output-dir "$(dirname $artifact)/signed"
              
              if [ $? -ne 0 ]; then
                echo "❌ Failed to sign $artifact"
                exit 1
              fi
            fi
          done
        # PHASE 6: Fail-closed - all artifacts must be signed
        continue-on-error: false
      
      - name: Verify all artifact signatures
        env:
          SIGNING_KEY_DIR: /tmp/ci-signing-keys
          SIGNING_KEY_ID: ${{ env.SIGNING_KEY_ID }}
        run: |
          cd build/artifacts
          SIGNED_COUNT=0
          UNSIGNED_COUNT=0
          
          for artifact in *.tar.gz *.zip; do
            if [ -f "$artifact" ]; then
              ARTIFACT_NAME=$(basename "$artifact")
              MANIFEST_PATH="signed/${ARTIFACT_NAME}.manifest.json"
              SIGNATURE_PATH="signed/${ARTIFACT_NAME}.manifest.sig"
              
              if [ ! -f "$MANIFEST_PATH" ] || [ ! -f "$SIGNATURE_PATH" ]; then
                echo "❌ UNSIGNED ARTIFACT: $artifact (missing manifest or signature)"
                UNSIGNED_COUNT=$((UNSIGNED_COUNT + 1))
                continue
              fi
              
              echo "Verifying signature for $artifact..."
              python3 ${{ github.workspace }}/supply-chain/cli/verify_artifacts.py \
                --artifact "$artifact" \
                --manifest "$MANIFEST_PATH" \
                --key-dir "$SIGNING_KEY_DIR" \
                --signing-key-id "$SIGNING_KEY_ID"
              
              if [ $? -eq 0 ]; then
                echo "✅ Signature verified: $artifact"
                SIGNED_COUNT=$((SIGNED_COUNT + 1))
              else
                echo "❌ Signature verification failed: $artifact"
                exit 1
              fi
            fi
          done
          
          if [ $UNSIGNED_COUNT -gt 0 ]; then
            echo "❌ Found $UNSIGNED_COUNT unsigned artifact(s)"
            exit 1
          fi
          
          echo "✅ All $SIGNED_COUNT artifact(s) signed and verified"
        # PHASE 6: Fail-closed - all artifacts must be signed and verified
        continue-on-error: false
      
      - name: Generate SBOM
        env:
          SIGNING_KEY_DIR: /tmp/ci-signing-keys
          SIGNING_KEY_ID: ${{ env.SIGNING_KEY_ID }}
        run: |
          mkdir -p build/artifacts/sbom
          python3 ${{ github.workspace }}/release/generate_sbom.py \
            --release-root build/artifacts \
            --version "${{ github.ref_name }}" \
            --build-id "${{ github.run_id }}" \
            --signing-key-id "${{ env.SIGNING_KEY_ID }}" \
            --key-dir "$SIGNING_KEY_DIR" \
            --output build/artifacts/sbom/manifest.json
        # PHASE 6: Fail-closed - SBOM generation must succeed
        continue-on-error: false
      
      - name: Verify SBOM signature
        env:
          SIGNING_KEY_DIR: /tmp/ci-signing-keys
        run: |
          python3 ${{ github.workspace }}/release/verify_sbom.py \
            --release-root build/artifacts \
            --manifest build/artifacts/sbom/manifest.json \
            --signature build/artifacts/sbom/manifest.json.sig \
            --key-dir "$SIGNING_KEY_DIR"
        # PHASE 6: Fail-closed - SBOM signature must be valid
        continue-on-error: false
      
      - name: Upload signed artifacts
        if: success()
        uses: actions/upload-artifact@v4
        with:
          name: signed-artifacts
          path: |
            build/artifacts/signed/
            build/artifacts/sbom/
          retention-days: 90
      
      - name: Upload signing public key
        if: success()
        uses: actions/upload-artifact@v4
        with:
          name: signing-public-key
          path: /tmp/ci-signing-keys/vendor-signing-key-*.pub
          retention-days: 90
