*****Promot Start*****

You are working on **RansomEye v1.0 – Clean-Room Rebuild**.

**STRICT CONTEXT (READ CAREFULLY):**

* This is a **clean-room rebuild**. Assume **zero prior code exists**.
* You are in **Phase 1 – System Contracts**.
* **NO SERVICE CODE IS ALLOWED**.
* **NO INSTALLER CODE**.
* **NO DATABASE CODE**.
* Output must be **contracts only**.
* If you feel tempted to “prepare for later” or “add convenience”, **do not**.

---

## OBJECTIVE OF THIS PROMPT

Define the **canonical, immutable system contracts** for RansomEye v1.0.

These contracts will be frozen and **every future component must conform to them**.
If any later code violates these contracts, the code will be deleted.

---

## SCOPE (MUST DELIVER ALL)

Produce **ONLY** the following artifacts:

### 1. Canonical Event Envelope (AUTHORITATIVE)

Deliver:

* JSON Schema (Draft 2020-12)
* Protobuf definition

The envelope **must exactly contain** the following fields (no more, no less):

```json
{
  "event_id": "uuid",
  "machine_id": "string",
  "component": "linux_agent | windows_agent | dpi | core",
  "component_instance_id": "string",
  "observed_at": "RFC3339 UTC",
  "ingested_at": "RFC3339 UTC",
  "sequence": "monotonic_uint64",
  "payload": {},
  "identity": {
    "hostname": "string",
    "boot_id": "string",
    "agent_version": "string"
  },
  "integrity": {
    "hash_sha256": "string",
    "prev_hash_sha256": "string | null"
  }
}
```

Rules:

* **No optional fields**
* **No defaults**
* **No extensions**
* `payload` is opaque but must be typed correctly
* `component` must be an enum
* Timestamps must be strictly validated

---

### 2. Time Semantics Contract (TEXT + MACHINE-READABLE)

Define **explicit, enforceable rules** for:

* `observed_at`
* `ingested_at`
* Clock skew tolerance
* Out-of-order arrival
* Late arrival
* Duplicate arrival

Deliverables:

* Human-readable spec (Markdown)
* Machine-readable policy (JSON)

---

### 3. Failure Semantics Contract (MANDATORY)

Define **explicit behavior** for each component when:

* No events are received
* Events arrive late
* Events are duplicated
* Dependencies are unavailable
* Integrity chain breaks
* Schema validation fails

Rules:

* **Silence is forbidden**
* Every failure must result in:

  * Explicit state
  * Explicit log classification
  * Explicit downstream behavior

Deliverable:

* Structured failure matrix (Markdown table)
* Machine-readable failure policy (JSON)

---

### 4. Contract Bundle Metadata

Produce:

* Contract bundle version
* SHA256 hash placeholder (document where hash will be inserted later)
* Compatibility rules (breaking vs non-breaking)
* Freeze statement (immutable once approved)

---

## OUTPUT FORMAT (MANDATORY)

Return output in this **exact structure**:

```
/contracts/
  event-envelope.schema.json
  event-envelope.proto
  time-semantics.md
  time-semantics.policy.json
  failure-semantics.md
  failure-semantics.policy.json
  CONTRACT_BUNDLE.md
```

Each file must be fully written.

---

## HARD RULES (NON-NEGOTIABLE)

* ❌ Do NOT write code
* ❌ Do NOT reference databases
* ❌ Do NOT reference installers
* ❌ Do NOT reference paths
* ❌ Do NOT reference systemd
* ❌ Do NOT invent future fields
* ❌ Do NOT optimize for convenience

This is a **military-grade contract freeze**, not a draft.

If anything is ambiguous, **make it explicit**.
If something can fail, **define how it fails**.

---

Begin immediately.

*****Prompt End*****


*****Promot Start*****

You are continuing **RansomEye v1.0 – Clean-Room Rebuild**.

**STRICT CONTEXT (DO NOT VIOLATE):**

* Phase 1 (System Contracts) is **COMPLETE and FROZEN**.
* You are now entering **PHASE 2 — DATABASE FIRST**.
* **NO SERVICE CODE IS ALLOWED**.
* **NO INSTALLER CODE**.
* **NO AGENT / DPI CODE**.
* **NO UI CODE**.
* Database design is **authoritative**; future code must conform to it.
* If schema changes later without migration + version bump, the schema is invalid.

---

## OBJECTIVE OF THIS PROMPT

Design the **authoritative, production-grade database schema** for **RansomEye v1.0**, aligned **exactly** to the frozen system contracts and threat model.

This schema must support:

* Linux Agent
* Windows Agent
* DPI Probe
* Ingest
* Correlation Engine
* AI Core (read-only metadata)
* SOC UI (read-only views)

---

## HARD DATABASE PHILOSOPHY (NON-NEGOTIABLE)

* Schema is **not derived from code**
* Code will adapt to schema, not the reverse
* No dynamic columns
* No JSON blobs for core facts (JSON only where explicitly justified)
* Machine-first modeling (host-centric, not event-centric)
* Time-indexed everywhere
* Immutable primary keys
* Explicit foreign keys
* Deterministic querying

---

## SCOPE (MUST DELIVER ALL)

### 1. Core Identity Tables

Define tables for:

* Machines / Hosts
* Components (agent / dpi instances)
* Component identity history (version, boot_id)

Must align with:

* `machine_id`
* `component`
* `component_instance_id`
* `identity.*` fields from the event envelope

---

### 2. Event Storage Model (RAW + NORMALIZED)

Design:

* **Raw event storage** (exact envelope preservation)
* **Normalized tables** for:

  * Process activity
  * File activity
  * Persistence
  * Network intent (agent-side)
  * DPI-derived flows
  * DNS
  * Deception
  * Health / heartbeat

Rules:

* Raw events are immutable
* Normalized tables are query-optimized
* Every normalized row must reference its raw event

---

### 3. Integrity & Ordering

Schema must explicitly support:

* Event hash chains
* Sequence monotonicity per component instance
* Duplicate detection
* Gap detection

No inference in code — DB must support this natively.

---

### 4. Correlation & Incident Tables

Define tables for:

* Incidents
* Incident stages (Clean → Suspicious → Probable → Confirmed)
* Confidence accumulation
* Evidence linkage (event → incident)

Rules:

* One event can contribute to multiple incidents
* Incident state transitions must be auditable
* No deletion of incident history

---

### 5. AI / ML Metadata Tables (READ-ONLY)

Define tables for:

* Feature vectors (references only)
* Clusters
* Novelty scores
* SHAP explanations (references, not blobs)

Rules:

* AI NEVER writes facts
* AI NEVER mutates incidents
* Metadata only, versioned

---

### 6. Indexing, Partitioning & Retention

For every table:

* Primary key
* Foreign keys
* Mandatory indexes
* Time partitioning strategy
* Retention policy (hot / warm / cold)

No hand-waving. Be explicit.

---

### 7. Schema Freeze Artifacts

Produce:

* Versioned schema definition (DDL)
* Schema hash placeholder
* Migration rules (what constitutes breaking vs non-breaking)
* Explicit freeze statement

---

## OUTPUT FORMAT (MANDATORY)

Return output in this **exact structure**:

```
/schemas/
  00_core_identity.sql
  01_raw_events.sql
  02_normalized_agent.sql
  03_normalized_dpi.sql
  04_correlation.sql
  05_ai_metadata.sql
  06_indexes.sql
  07_retention.sql
  SCHEMA_BUNDLE.md
```

* SQL must be **PostgreSQL 14+ compatible**
* Use `UUID`, `TIMESTAMPTZ`, `JSONB` only where justified
* Every file must be complete and executable

---

## HARD RULES (DO NOT BREAK)

* ❌ No assumptions about paths
* ❌ No assumptions about deployment size
* ❌ No sample data
* ❌ No test data
* ❌ No service logic
* ❌ No shortcuts for “later optimization”

This schema must survive:

* Zero data
* One event
* Partial failure
* Adversarial input
* Multi-year growth

---

Begin immediately.
Do not explain — **design**.

*****Prompt End*****

Promot Start

You are continuing RansomEye v1.0 – Clean-Room Rebuild.

PHASE: 3 — INSTALLER BEFORE SERVICES
PREVIOUS PHASES COMPLETE:

Phase 1: System Contracts (Frozen)

Phase 2: Database Schema (Frozen)

STRICT RULES (NON-NEGOTIABLE)

❌ No service code

❌ No agent code

❌ No DPI code

❌ No database schema changes

❌ No systemd unit files yet

❌ No hardcoded paths

❌ No assumptions about install location

This installer must support commercial self-installation at any path.

ALLOWED LANGUAGES ONLY

Bash

Python 3.10+

No other languages permitted.

OBJECTIVE

Design the authoritative unified installer specification for RansomEye v1.0.

The installer is responsible for:

Discovering install root

Creating system user

Generating manifest

Injecting paths via ENV

Enforcing fail-closed startup

SCOPE (MUST DELIVER ALL)
1. Installation Manifest (AUTHORITATIVE)

Define a machine-readable manifest that contains:

Install root (absolute)

Data directories

Log directories

Binary directories

Config directories

Runtime UID/GID

Enabled components

Schema bundle hash

Contract bundle hash

Deliver:

install.manifest.schema.json

Example install.manifest.json (NO PATH ASSUMPTIONS, use placeholders)

2. Environment Variable Contract

Define EXACT ENV VARS that every service must read:

Paths

IDs

Versions

Runtime identity

Deliver:

env.contract.md

env.contract.json

No service may compute paths internally.

3. Privilege Model

Define:

Installer privilege requirements

Runtime privilege drop rules

Agent/DPI exception boundaries

Deliver:

privilege-model.md

4. Failure Semantics (Installer-Specific)

Define:

What causes install abort

What is recoverable

What is fatal

Rollback rules

Deliver:

installer-failure-policy.md

installer-failure-policy.json

OUTPUT FORMAT (MANDATORY)
/installer/
  install.manifest.schema.json
  install.manifest.json
  env.contract.md
  env.contract.json
  privilege-model.md
  installer-failure-policy.md
  installer-failure-policy.json
  INSTALLER_BUNDLE.md

HARD REQUIREMENTS

Installer must be idempotent

Installer must be fail-closed

Installer must leave zero partial state

All paths are injected, never inferred

Manifest is the single source of runtime truth

This installer defines how RansomEye exists on disk.

Begin immediately.
Do not explain — design.

Prompt End


Promot Start

You are continuing RansomEye v1.0 – Clean-Room Rebuild.

PHASE: 4 — MINIMAL DATA PLANE (ONE EVENT)

PREVIOUS PHASES (FROZEN):

Phase 1: System Contracts

Phase 2: Database Schema

Phase 3: Installer Contracts

HARD RULES (NON-NEGOTIABLE)

❌ No correlation engine

❌ No AI / ML / LLM

❌ No enrichment

❌ No heuristics

❌ No retries

❌ No buffering

❌ No background threads

❌ No filesystem/process monitoring

❌ No installer code

❌ No schema changes

❌ No contract changes

This phase exists only to prove:

One valid event → validated → stored → queryable

COMPONENT 1 — LINUX AGENT (MINIMAL)
Allowed Language

Rust only

Responsibilities (ONLY)

Read environment variables defined in env.contract.json

Construct exact canonical event envelope

Populate:

event_id

machine_id

component = linux_agent

component_instance_id

observed_at

sequence = 1

identity.*

integrity.hash_sha256

payload may contain one dummy key/value (explicitly allowed for this phase)

Transmit event to Ingest over HTTP

Forbidden

No local persistence

No retries

No batching

No enrichment

No inference

Deliver:

Minimal Rust binary

Clear module structure

Inline comments explaining contract compliance

COMPONENT 2 — INGEST SERVICE (MINIMAL)
Allowed Language

Python 3.10+ only

Responsibilities (ONLY)

Accept event via HTTP

Validate against:

event-envelope.schema.json

time-semantics.policy.json

Verify hash integrity

Detect duplicates (event_id + sequence)

Write to:

machines

component_instances

raw_events

event_validation_log

Forbidden

No correlation

No enrichment

No retry logic

No background jobs

No AI

No assumptions

OUTPUT FORMAT (MANDATORY)
/services/
  linux-agent/
    src/
    Cargo.toml
    README.md

  ingest/
    app/
    requirements.txt
    README.md


Each README must explain:

What this component does

What it explicitly does NOT do

How it proves Phase 4 correctness

VALIDATION CRITERIA (PASS / FAIL)

PASS only if:

One event is accepted

One row exists in raw_events

Hash chain is valid

No other tables are touched

Restarting ingest does NOT duplicate data

FAIL if:

Anything “helpful” is added

Any future logic leaks in

Begin immediately.
Do not explain — implement exactly.

Prompt End


Promot Start

You are continuing RansomEye v1.0 – Clean-Room Rebuild.

PHASE: 5 — CORRELATION ENGINE (DETERMINISTIC)

PREVIOUS PHASES (FROZEN):

Phase 1: System Contracts

Phase 2: Database Schema

Phase 3: Installer Contracts

Phase 4: Minimal Data Plane

HARD RULES (NON-NEGOTIABLE)

❌ No AI / ML / LLM

❌ No time-window dependency

❌ No probabilistic logic

❌ No heuristics

❌ No enrichment

❌ No retries

❌ No background threads

❌ No async

❌ No schema changes

❌ No contract changes

This engine must be purely deterministic.

OBJECTIVE

Implement the minimal deterministic correlation engine that:

Consumes validated events

Applies explicit contradiction rules

Produces at most one incident per event

INPUT

Read from:

raw_events

Normalized tables (if required)

Use only persisted facts

DETECTION MODEL (MINIMAL)

For this phase, define exactly ONE rule:

If a Linux Agent event exists with component = linux_agent,
THEN:

Either create zero incidents, OR

Create exactly one incident with:

stage = Suspicious

confidence = deterministic constant (e.g. 0.3)

No additional logic is allowed.

INCIDENT REQUIREMENTS

When an incident is created:

Insert into incidents

Insert initial stage into incident_stages

Link triggering event in evidence

All writes must be atomic (single transaction)

OUTPUT FORMAT (MANDATORY)
/services/
  correlation-engine/
    app/
      main.py
      rules.py
      db.py
    requirements.txt
    README.md

README MUST EXPLICITLY STATE

What rules exist

Why rules are deterministic

What this engine does NOT do

Why time is NOT required for correctness

VALIDATION (PASS / FAIL)

PASS only if:

One event → ≤ 1 incident

Restarting engine does NOT duplicate incidents

No time-window logic exists

No ML/AI imports exist

No retries or background jobs exist

FAIL if:

Engine waits for more data

Engine uses time windows

Engine attempts “confidence tuning”

Begin immediately.
Do not explain — implement exactly.

Prompt End


Promot Start

You are continuing RansomEye v1.0 – Clean-Room Rebuild.

PHASE: 6 — AI CORE (READ-ONLY, NON-BLOCKING)

PREVIOUS PHASES (FROZEN):

Phase 1: System Contracts

Phase 2: Database Schema

Phase 3: Installer Contracts

Phase 4: Minimal Data Plane

Phase 5: Deterministic Correlation Engine

HARD RULES (NON-NEGOTIABLE)

❌ AI must NOT create incidents

❌ AI must NOT modify incidents

❌ AI must NOT block pipeline

❌ AI must NOT require real-time inference

❌ AI must NOT be in data plane

❌ No deep learning

❌ No retries

❌ No background schedulers

❌ No schema changes

❌ No contract changes

The system must remain fully correct if AI is disabled.

OBJECTIVE

Implement the minimal AI Core that operates in read-only advisory mode.

The AI Core must:

Consume existing incidents

Perform offline, batch analysis

Produce metadata only

AI FUNCTIONS (MINIMAL, REQUIRED)

Implement exactly three capabilities:

1. Feature Extraction (Deterministic)

Derive numeric features from:

incident confidence

incident stage

evidence count

Persist feature vector references only

2. Unsupervised Clustering

Use scikit-learn (e.g., KMeans or DBSCAN)

Cluster incidents

Persist:

cluster_id

model_version

incident ↔ cluster mapping

3. Explainability (SHAP)

Generate SHAP explanations for:

confidence contribution

evidence contribution

Store references only, not raw arrays

OUTPUT FORMAT (MANDATORY)
/services/
  ai-core/
    app/
      main.py
      feature_extraction.py
      clustering.py
      shap_explainer.py
      db.py
    requirements.txt
    README.md

README MUST EXPLICITLY STATE

AI is read-only

AI cannot block or decide

AI output is advisory only

System remains correct without AI

VALIDATION (PASS / FAIL)

PASS only if:

Incidents are unchanged

Only AI metadata tables are written

Disabling AI has zero impact on detection

SHAP output is generated per run

Models are versioned and reproducible

FAIL if:

AI touches facts

AI alters incident state

AI introduces timing dependency

AI blocks pipeline

Begin immediately.
Do not explain — implement exactly.

Prompt End


Promot Start

You are continuing RansomEye v1.0 – Clean-Room Rebuild.

PHASE: 7 — POLICY ENGINE (SIMULATION-FIRST)

PREVIOUS PHASES (FROZEN):

Phase 1: System Contracts

Phase 2: Database Schema

Phase 3: Installer Contracts

Phase 4: Minimal Data Plane

Phase 5: Deterministic Correlation Engine

Phase 6: AI Core (Read-Only)

HARD RULES (NON-NEGOTIABLE)

❌ No automatic enforcement

❌ No agent execution

❌ No incident modification

❌ No AI / ML / LLM

❌ No background schedulers

❌ No async

❌ No schema changes

❌ No contract changes

Policy Engine operates in SIMULATION MODE BY DEFAULT.

OBJECTIVE

Implement the minimal Policy Engine that:

Consumes existing incidents

Evaluates explicit policy rules

Produces policy decisions and simulations

Signs commands without executing them

POLICY MODEL (MINIMAL)

Define exactly ONE policy rule:

IF incident.stage == SUSPICIOUS
THEN recommend action: ISOLATE_HOST

Rules:

Recommendation only

No execution

Deterministic (no time, no probability)

COMMAND MODEL

When a policy decision is made:

Generate a command payload:

command_type

target_machine_id

incident_id

issued_at

Cryptographically sign the command

Store signed command in DB

DO NOT send to agents

OUTPUT FORMAT (MANDATORY)
/services/
  policy-engine/
    app/
      main.py
      rules.py
      signer.py
      db.py
    requirements.txt
    README.md

README MUST EXPLICITLY STATE

Policy is simulation-first

No commands are executed

Enforcement is disabled by default

All commands are signed and auditable

System correctness does not depend on policy engine

VALIDATION (PASS / FAIL)

PASS only if:

Incidents are unchanged

Policy decisions are recorded

Signed commands are generated

No enforcement occurs

Disabling policy engine has zero impact

FAIL if:

Any command is executed

Any agent is contacted

Incident state is modified

Enforcement occurs implicitly

Begin immediately.
Do not explain — implement exactly.

Prompt End



Promot Start

You are continuing RansomEye v1.0 – Clean-Room Rebuild.

PHASE: 8 — SOC UI (READ-ONLY)

PREVIOUS PHASES (FROZEN):

Phase 1: System Contracts

Phase 2: Database Schema

Phase 3: Installer Contracts

Phase 4: Minimal Data Plane

Phase 5: Correlation Engine

Phase 6: AI Core (Read-Only)

Phase 7: Policy Engine (Simulation-First)

HARD RULES (NON-NEGOTIABLE)

❌ UI must NOT write to DB

❌ UI must NOT query base tables

❌ UI must NOT infer state

❌ UI must NOT trigger actions

❌ UI must NOT contain policy logic

❌ UI must NOT contain AI logic

❌ No schema changes

❌ No contract changes

UI is OBSERVATIONAL ONLY.

OBJECTIVE

Implement the minimal SOC UI that provides read-only visibility into system state.

REQUIRED DB VIEWS (MUST DEFINE)

Define READ-ONLY SQL VIEWS for:

v_active_incidents

incident_id

machine_id

stage

confidence

created_at

v_incident_timeline

incident_id

stage

transitioned_at

v_incident_evidence_summary

incident_id

evidence_count

v_policy_recommendations

incident_id

recommended_action

simulation_mode

created_at

v_ai_insights

incident_id

cluster_id

novelty_score

shap_summary

UI FEATURES (MINIMAL)
Dashboards

Incident list (from v_active_incidents)

Incident detail view:

Timeline

Evidence count

AI insights

Policy recommendations

Constraints

No edits

No buttons that execute actions

No “acknowledge”, “resolve”, or “close”

OUTPUT FORMAT (MANDATORY)
/services/
  ui/
    backend/
      main.py
      views.sql
      requirements.txt
    frontend/
      src/
      package.json
      README.md
    README.md

README MUST EXPLICITLY STATE

UI is read-only

UI does not affect pipeline

UI reads from DB views only

System correctness is independent of UI

VALIDATION (PASS / FAIL)

PASS only if:

UI reads ONLY from views

UI cannot modify data

UI can be disabled without impact

No table writes exist

FAIL if:

Any DB write exists

Any base table is queried

Any action can be triggered

Begin immediately.
Do not explain — implement exactly.

Prompt End


Promot Start

You are continuing RansomEye v1.0 – Clean-Room Rebuild.

PHASE: 9 — VALIDATION HARNESS (WRITTEN FIRST)

PREVIOUS PHASES (FROZEN):

Phase 1: System Contracts

Phase 2: Database Schema

Phase 3: Installer Contracts

Phase 4: Minimal Data Plane

Phase 5: Correlation Engine

Phase 6: AI Core (Read-Only)

Phase 7: Policy Engine (Simulation-First)

Phase 8: SOC UI (Read-Only)

HARD RULES (NON-NEGOTIABLE)

❌ No service logic

❌ No mocks of core logic

❌ No sleeps / timing hacks

❌ No randomness

❌ No skipping failures

❌ No schema changes

❌ No contract changes

Validation must assert real system behavior.

OBJECTIVE

Implement the authoritative validation harness that proves end-to-end correctness of RansomEye v1.0.

VALIDATION CASES (ALL REQUIRED)

Implement tests for:

Cold start correctness

Zero-event correctness

One-event correctness

Duplicate event handling

Failure semantics enforcement

Subsystem disablement (AI, Policy, UI)

Each test must:

Set up environment

Execute scenario

Assert DB state

Assert logs / exit codes

Clean up

OUTPUT FORMAT (MANDATORY)
/validation/
  harness/
    test_cold_start.py
    test_zero_event.py
    test_one_event.py
    test_duplicates.py
    test_failure_semantics.py
    test_subsystem_disablement.py
  README.md

README MUST EXPLICITLY STATE

What is validated

Why failures block release

How to run validation

Determinism guarantees

PASS / FAIL CRITERIA

PASS only if:

All tests pass consistently

Results are deterministic

System is left clean

No silent failures exist

FAIL if:

Any nondeterminism

Any skipped test

Any silent error

Begin immediately.
Do not explain — implement exactly.

Prompt End


Promot Start

You are continuing RansomEye v1.0 – Clean-Room Rebuild.

PHASE: 9.1 — VALIDATION HARDENING (MANDATORY CORRECTION)

HARD RULES (NON-NEGOTIABLE)

❌ NO synthetic events

❌ NO fabricated UUIDs

❌ NO prebuilt payloads

❌ NO fixed timestamps

❌ NO dummy data of any kind

Validation must observe real system behavior only.

OBJECTIVE

Refactor the existing Phase 9 validation harness to meet military-grade forensic correctness.

REQUIRED CHANGES
1. Linux Agent–Driven Validation

Validation must:

Launch the real Linux Agent binary

Wait for agent to emit one real event

Observe resulting DB state

No manual event construction allowed.

2. Replace Fixed Assertions

Replace:

Fixed UUID checks

Fixed timestamp checks

With:

Structural assertions

Cardinality assertions

Contract compliance assertions

Integrity chain verification

3. Policy & AI Validation Tightening

Validation must:

Verify signed command exists

Verify signature cryptographically

Verify command was not executed

Verify AI metadata exists or not, without inspecting content

OUTPUT

Modify only files under:

/validation/harness/


No schema changes.
No service changes.
No contract changes.

PASS CRITERIA

PASS only if:

Validation uses real agents

No synthetic data exists

All assertions are observational

Results remain deterministic

System remains clean

Begin immediately.
Do not explain — fix it.

Prompt End



Promot Start*

You are continuing RansomEye v1.0 – Clean-Room Rebuild.

PHASE: 10.1 — CORE RUNTIME HARDENING (STARTUP & SHUTDOWN)

STRICT CONTEXT (DO NOT VIOLATE)

You are hardening RansomEye Core, not individual services.

Ingest, Correlation, AI Core, Policy Engine, UI Backend run inside one Core runtime.

❌ NO systemd files

❌ NO standalone service assumptions

❌ NO new features

❌ NO retries

❌ NO schema or contract changes

OBJECTIVE (ONLY THIS)

Harden startup and shutdown behavior for RansomEye Core components.

COMPONENTS IN SCOPE

Inside Core:

Ingest

Correlation Engine

AI Core

Policy Engine

UI Backend

Treat them as modules, not services.

REQUIRED HARDENING (IMPLEMENT ALL)
1. Startup Validation (MANDATORY)

On Core startup:

Validate all required environment variables

Validate DB connectivity

Validate schema presence

Validate write permissions where applicable

Validate read-only enforcement where applicable

If ANY check fails:

Log explicit error

Exit process immediately (non-zero)

2. Fail-Fast Invariants

Add invariant checks that terminate Core immediately if violated:

Missing env var

DB connection failure

Schema mismatch

Unauthorized write attempt (read-only module)

Duplicate incident creation attempt

No recovery. No retry.

3. Graceful Shutdown

On SIGTERM / SIGINT:

Stop accepting new work

Finish in-flight DB transactions

Close DB connections cleanly

Exit cleanly with log confirmation

OUTPUT CONSTRAINTS

Modify existing Core code only

Do NOT create new processes

Do NOT introduce background schedulers

Do NOT add retries

Do NOT add systemd files

Each modified Core module must update its README with a new section:

Operational Hardening Guarantees
PASS CRITERIA

PASS only if:

Core fails immediately on bad config

Core shuts down cleanly

No partial state possible

No retries hide failures

Begin immediately.
Do not explain.
Implement only what is asked.

Promot end*


Promot Start*

You are continuing RansomEye v1.0 – Enterprise & Military-Grade Build.

WORK UNIT: Database Hardening & Transaction Safety
(Do NOT use phase numbers anywhere)

STRICT CONTEXT (DO NOT VIOLATE)

This applies to RansomEye Core database usage

Core runs as one unified runtime

❌ No schema changes

❌ No contract changes

❌ No retry loops

❌ No silent fallbacks

❌ No per-module DB ownership confusion

OBJECTIVE (ONLY THIS)

Harden all database interactions to ensure:

Atomicity

Consistency

Explicit failure behavior

Zero partial state

Deterministic outcomes under failure

COMPONENTS IN SCOPE (CORE)

Ingest

Correlation Engine

AI Core

Policy Engine

UI Backend (read-only)

REQUIRED HARDENING (IMPLEMENT ALL)
1. Transaction Discipline (MANDATORY)

For every DB write path:

Explicit transaction begin

Explicit commit on success

Explicit rollback on failure

No implicit autocommit behavior

If rollback fails → terminate Core.

2. Isolation & Consistency

Explicitly set isolation level at connection creation

Log isolation level at startup

Reject runtime if isolation cannot be enforced

3. Deadlock & Integrity Detection

Detect and fail fast on:

Serialization failures

Deadlocks

Foreign-key violations

Unique-constraint violations

No retries.
Log → terminate.

4. Connection Safety

Validate connection health before each critical operation

Detect dropped connections

Fail immediately on broken connection

No reconnection loops

5. Read-Only Enforcement (UI & AI)

Explicitly open read-only DB sessions

Abort process if write attempt occurs

Log security-grade error

OUTPUT CONSTRAINTS

Modify existing DB access layers only

No new abstractions unless required for safety

No background workers

No schedulers

Each modified component must update its README:

Database Safety & Transaction Guarantees
PASS CRITERIA

PASS only if:

No partial writes possible

All failures are explicit and fatal

Isolation level is enforced and logged

Read-only violations terminate immediately

System behavior is deterministic under DB failure

Begin immediately.
Do not explain.
Do not refactor unrelated code.
Harden the database interactions only.

Promot end*




Promot Start*

You are continuing RansomEye v1.0 – Enterprise & Military-Grade Build.

WORK UNIT: Database Safety Completion (AI Core, Policy Engine, UI Backend)

STRICT CONTEXT (DO NOT VIOLATE)

Database schema is frozen

Contracts are frozen

Core runs as one unified runtime

❌ No retries

❌ No silent failures

❌ No best-effort fallbacks

❌ No new abstractions beyond existing common/db/safety.py

OBJECTIVE (ONLY THIS)

Complete database hardening for remaining Core modules using the existing safety utilities.

COMPONENT-SPECIFIC REQUIREMENTS
1. AI Core

File:
services/ai-core/app/db.py

Required changes:

All read paths must use create_readonly_connection()

All write paths must use execute_write_operation()

Enforce isolation level

Abort Core on:

Deadlock

Integrity violation

Unauthorized write attempt

2. Policy Engine

File:
services/policy-engine/app/db.py

Required changes:

Use read-only connections only

Enforce read-only mode explicitly

Abort Core if any write is attempted

Policy Engine must never write to DB.

3. UI Backend

File:
services/ui/backend/main.py

Required changes:

Enforce read-only DB connections at pool level

Ensure query_view() cannot execute writes

Any write attempt → immediate Core termination

4. Documentation (MANDATORY)

Update README for:

AI Core

Policy Engine

UI Backend

Add section:

Database Safety & Transaction Guarantees

Must explicitly state:

Isolation level enforcement

Explicit transaction behavior

Read-only enforcement (where applicable)

Fail-fast semantics

No retries, no partial state

No fluff. No marketing.

PASS CRITERIA

PASS only if:

AI Core writes are fully transaction-safe

Policy Engine cannot write under any condition

UI Backend is read-only by construction

Any DB misuse terminates Core

All READMEs updated correctly

Begin immediately.
Do not refactor unrelated code.
Do not summarize.
Finish database hardening cleanly.

Promot end*




Promot Start*

You are continuing RansomEye v1.0 – Enterprise & Military-Grade Build.

WORK UNIT: Resource & Disk Safety Hardening

STRICT CONTEXT (DO NOT VIOLATE)

Applies to RansomEye Core runtime

Core runs as one unified process

❌ No schema changes

❌ No contract changes

❌ No retries

❌ No background schedulers

❌ No new features

This is safety hardening only.

OBJECTIVE (ONLY THIS)

Harden Core against resource exhaustion and disk failures so the system fails explicitly and safely, never silently.

COMPONENTS IN SCOPE (CORE)

Ingest

Correlation Engine

AI Core

Policy Engine

UI Backend

REQUIRED HARDENING (IMPLEMENT ALL)
1. Disk Safety (MANDATORY)

Implement explicit checks and fail-fast behavior for:

Disk full conditions

Permission denied (logs, temp, runtime dirs)

Read-only filesystem

Rules:

Detect error at write attempt

Log explicit error

Terminate Core immediately

No retries, no degradation

2. Log Safety

Prevent unbounded log growth

Enforce size limits or rotation without losing critical errors

If logging fails → terminate Core (fail-fast)

No silent logging failures.

3. File Descriptor & Resource Limits

Detect exhaustion of file descriptors

Detect inability to open files/sockets

Fail fast with explicit error

4. Memory Safety (BASIC, NOT OPTIMIZATION)

Detect MemoryError / allocation failures

Abort Core immediately on memory allocation failure

No swap-based survival logic

OUTPUT CONSTRAINTS

Modify existing code paths only

Use explicit exception handling

No new abstractions unless strictly required for safety

No platform-specific hacks

Each modified component must update its README with a section:

Resource & Disk Safety Guarantees
PASS CRITERIA

PASS only if:

Disk full causes explicit termination

Logging failure causes explicit termination

Resource exhaustion causes explicit termination

No silent degradation paths exist

Behavior is deterministic under resource failure

Begin immediately.
Do not explain.
Do not refactor unrelated code.
Harden resource and disk safety only.

Promot end*


Promot Start*

You are continuing RansomEye v1.0 – Enterprise & Military-Grade Build.

WORK UNIT: Security Hardening (Secrets, Redaction, Signing Discipline)

STRICT CONTEXT (DO NOT VIOLATE)

Applies to RansomEye Core runtime

Core runs as one unified process

❌ No schema changes

❌ No contract changes

❌ No new features

❌ No retries

❌ No background schedulers

❌ No standalone services added

Security hygiene only.

OBJECTIVE (ONLY THIS)

Eliminate secret leakage risks and enforce cryptographic discipline across Core.

COMPONENTS IN SCOPE (CORE)

Ingest

Correlation Engine

AI Core

Policy Engine

UI Backend

Common logging & config utilities

REQUIRED HARDENING (IMPLEMENT ALL)
1. Secrets Handling (MANDATORY)

All secrets only from environment variables

No secrets in:

Code

Config files

Logs

Exceptions

Validate presence and format at startup

If a required secret is missing or malformed → terminate Core immediately

2. Log Redaction (MANDATORY)

Implement centralized redaction for:

DB credentials

API tokens

Signing keys

Any value matching secret patterns

Ensure:

Secrets never appear in logs

Stack traces are sanitized

Any attempt to log a secret → terminate Core

3. Signing Discipline (Policy Engine)

Ensure command signing keys:

Are read once at startup

Never logged

Never reloaded dynamically

Validate key strength and format

Fail fast on weak/invalid keys

4. Untrusted Input Handling (AI & UI)

Treat AI metadata and UI inputs as untrusted

Validate types and bounds before processing

Abort Core on malformed or unexpected structures

OUTPUT CONSTRAINTS

Modify existing code paths only

No new crypto schemes

Use existing libraries already in use

No platform-specific hacks

Each modified component must update its README with:

Security & Secrets Handling Guarantees
PASS CRITERIA

PASS only if:

No secrets can be logged

Missing/weak secrets terminate Core

Signing keys are handled once, securely

Malformed untrusted input terminates Core

Behavior is deterministic and explicit

Begin immediately.
Do not explain.
Do not refactor unrelated code.
Harden security hygiene only.

Promot end*



Promot Start*

You are continuing RansomEye v1.0 – Enterprise & Military-Grade Build.

WORK UNIT: End-to-End Hardened Run & Validation Re-Execution

STRICT CONTEXT (DO NOT VIOLATE)

All hardening work is complete and frozen

Credentials everywhere are username = gagan, password = gagan

❌ No code changes unless a failure is discovered

❌ No schema changes

❌ No contract changes

❌ No new features

This is an execution and verification step only.

OBJECTIVE (ONLY THIS)

Bring up the entire hardened RansomEye system on this machine and prove zero-failure operation.

REQUIRED EXECUTION STEPS

Start PostgreSQL with credentials:

user: gagan

password: gagan

Start RansomEye Core (single unified runtime):

Ingest

Correlation Engine

AI Core

Policy Engine

UI Backend

Start Linux Agent:

Emit at least one real event

Run full validation harness (hardened, reality-based):

All tests must pass

No warnings ignored

No retries hiding faults

REQUIRED OBSERVATIONS

You must confirm:

No crashes

No invariant violations

No secret leakage in logs

No partial DB state

Clean startup and clean shutdown

Validation passes without modification

OUTPUT EXPECTATION

Return only:

Execution status

Any failures (if present)

Confirmation of zero-failure run

Do NOT summarize code.
Do NOT refactor.

Begin immediately.
This step gates installer creation.

Promot end*



Promot Start*

You are continuing RansomEye v1.0 – Enterprise & Military-Grade Build.

WORK UNIT: Installer Packaging — RansomEye Core

STRICT CONTEXT (DO NOT VIOLATE)

Core code is frozen

Validation is frozen

❌ No code changes unless installer uncovers a fatal issue

❌ No schema changes

❌ No contract changes

❌ No feature additions

This step is packaging only.

OBJECTIVE (ONLY THIS)

Create a commercial-grade installer for RansomEye Core that:

Installs cleanly on Ubuntu LTS

Uses any install path chosen by the user

Runs Core as a single unified service

Uses credentials:

user: gagan

password: gagan

Is deterministic, idempotent, and fail-closed

INSTALLER REQUIREMENTS (MANDATORY)
1. Installer Type

Bash installer (install.sh)

Must be executable

Must fail fast on any error

2. User & Permissions

Installer must:

Create system user: ransomeye

Set ownership and permissions correctly

Drop privileges for runtime

3. Paths (NO HARDCODED PATHS)

Installer must:

Prompt for install root (example: /opt/ransomeye)

Create:

bin/

lib/

config/

logs/

runtime/

Write installation manifest with absolute paths

4. Configuration

Installer must generate:

Environment file for Core

DB connection config using:

user: gagan

password: gagan

Log directories with correct permissions

5. Service Management

Create ONE systemd service:

ransomeye-core.service

No per-module services

Service must:

Start Core

Restart on failure

Stop cleanly

6. Validation Hook

Installer must:

Start Core

Perform health check

Fail installation if Core does not start cleanly

OUTPUT FORMAT (MANDATORY)
/installer/
  core/
    install.sh
    uninstall.sh
    ransomeye-core.service
    installer.manifest.json
    README.md

README MUST EXPLICITLY STATE

What the installer does

Supported OS

How to install

How to uninstall

Failure behavior (fail-closed)

No assumptions about paths

PASS / FAIL CRITERIA

PASS only if:

Installer works on a clean Ubuntu system

Installation path is user-defined

Core starts successfully

Core stops cleanly

Re-running installer is idempotent

FAIL if:

Any hardcoded path exists

Multiple services are created

Installer continues after failure

Begin immediately.
Do not explain.
Do not summarize.
Build the Core installer only.

Promot end*


Promot Start*

You are continuing RansomEye v1.0 – Enterprise & Military-Grade Build.

WORK UNIT: Core Installer Corrections (Blocking Fixes)

STRICT CONTEXT (DO NOT VIOLATE)

Core code is frozen

Installer must NOT modify Core logic

❌ No runtime fixes inside installer

❌ No new features

❌ No schema or contract changes

This task is installer-only corrections.

REQUIRED FIXES (ALL MANDATORY)
1. Credential Correction (CRITICAL)

Across the installer:

Username must be exactly: gagan

Password must be exactly: gagan

Fix all occurrences including:

env file generation

DB config

health checks

README examples

No variants. No hashes. No doubles.

2. Remove Core Runtime Modification

Revert any Core code changes introduced during installer creation

Installer must:

Copy pre-built Core artifacts

Start Core as-is

If Core startup requires uvicorn:

Installer must call it

NOT modify Core code

3. Re-run Installer Validation

Install on clean system

Start Core

Health check must pass

Uninstall must fully clean system

OUTPUT EXPECTATION

Return:

Confirmation of credential correction

Confirmation no Core code was modified

Confirmation installer works end-to-end

Do NOT summarize code.

Begin immediately.

Promot end*



Promot Start*

You are continuing RansomEye v1.0 – Enterprise & Military-Grade Build.

WORK UNIT: Linux Agent Installer (Standalone, systemd)

STRICT CONTEXT (DO NOT VIOLATE)

Linux Agent is a standalone component

❌ Do NOT modify Linux Agent code

❌ Do NOT modify Core code

❌ Do NOT assume Core is installed

❌ Do NOT hardcode any paths

❌ Do NOT add features

This task is installer packaging only.

OBJECTIVE (ONLY THIS)

Create a production-grade installer for the Linux Agent that:

Installs cleanly on Ubuntu LTS

Uses any install path chosen by the user

Runs as a standalone systemd service

Emits real events when Core is present

Fails cleanly when Core is absent (no crashes, no loops)

INSTALLER REQUIREMENTS (MANDATORY)
1. Installer Type

Bash installer (install.sh)

Executable

Fail-fast (set -euo pipefail)

2. User & Permissions

Installer must:

Create system user: ransomeye-agent

Drop privileges for runtime

Ensure least-privilege filesystem access

3. Paths (NO HARDCODED PATHS)

Installer must:

Prompt for install root (example: /opt/ransomeye-agent)

Create:

bin/

config/

logs/

runtime/

Write agent installation manifest with absolute paths

4. Configuration

Installer must generate:

Agent environment file

Core endpoint configurable via env (no assumption Core exists)

Credentials fixed:

username: gagan

password: gagan

5. systemd Service (MANDATORY)

Create ONE service:

ransomeye-linux-agent.service

Service must:

Run Linux Agent binary

Restart on failure

Handle SIGTERM cleanly

Not crash-loop if Core is unreachable

6. Validation Hook

Installer must:

Start agent

Verify process is running

NOT require Core to be present

OUTPUT FORMAT (MANDATORY)
/installer/
  linux-agent/
    install.sh
    uninstall.sh
    ransomeye-linux-agent.service
    installer.manifest.json
    README.md

README MUST EXPLICITLY STATE

Standalone nature of Linux Agent

Supported OS

How to install

How to uninstall

Behavior when Core is unreachable

No path assumptions

PASS / FAIL CRITERIA

PASS only if:

Agent installs without Core

Agent runs under systemd

Agent stops cleanly

Re-running installer is idempotent

Uninstall removes all artifacts

FAIL if:

Any hardcoded path exists

Agent assumes Core availability

Multiple services are created

Begin immediately.
Do not explain.
Do not summarize.
Build the Linux Agent installer only.

Promot end*



Promot Start*

You are continuing RansomEye v1.0 – Enterprise & Military-Grade Build.

WORK UNIT: Windows Agent Installer (Standalone, .bat)

STRICT CONTEXT (DO NOT VIOLATE)

Windows Agent is a standalone component

❌ Do NOT modify Windows Agent code

❌ Do NOT modify Core code

❌ Do NOT assume Core is installed

❌ Do NOT hardcode any paths

❌ Do NOT introduce MSI / PowerShell (BAT ONLY)

This task is installer packaging only.

OBJECTIVE (ONLY THIS)

Create a production-grade Windows installer for the Windows Agent that:

Installs cleanly on Windows Server / Windows 10+

Uses any install path chosen by the user

Runs as a Windows Service

Emits telemetry when Core is reachable

Fails gracefully when Core is unreachable (no crash loops)

INSTALLER REQUIREMENTS (MANDATORY)
1. Installer Type

Windows batch installer (install.bat)

Must be run as Administrator

Fail-fast on any error

2. User & Permissions

Installer must:

Create Windows service user: ransomeye-agent

Run service under least privilege

Ensure filesystem permissions are minimal

3. Paths (NO HARDCODED PATHS)

Installer must:

Prompt for install directory (example: C:\RansomEye\Agent)

Create:

bin\

config\

logs\

runtime\

Generate installation manifest with absolute paths

4. Configuration

Installer must generate:

Environment/config file

Core endpoint configurable

Credentials fixed:

username: gagan

password: gagan

5. Windows Service (MANDATORY)

Create ONE service:

RansomEyeWindowsAgent

Service must:

Run agent executable

Auto-restart on failure

Stop cleanly

NOT crash-loop if Core is unreachable

6. Validation Hook

Installer must:

Start service

Verify service is running

NOT require Core to be reachable

OUTPUT FORMAT (MANDATORY)
/installer/
  windows-agent/
    install.bat
    uninstall.bat
    ransomeye-windows-agent.service.txt
    installer.manifest.json
    README.md

README MUST EXPLICITLY STATE

Standalone nature of Windows Agent

Supported Windows versions

How to install (Administrator required)

How to uninstall

Behavior when Core is unreachable

No path assumptions

PASS / FAIL CRITERIA

PASS only if:

Agent installs without Core

Windows service starts

Service stops cleanly

Re-running installer is idempotent

Uninstall removes all artifacts

FAIL if:

Any hardcoded path exists

PowerShell/MSI is used

Agent assumes Core availability

Multiple services are created

Begin immediately.
Do not explain.
Do not summarize.
Build the Windows Agent installer only.

Promot end*


*Promot Start*

You are continuing RansomEye v1.0 – Enterprise & Military-Grade Build.

WORK UNIT: DPI Probe Installer (Standalone, systemd)

STRICT CONTEXT (DO NOT VIOLATE)

DPI Probe is a standalone privileged component

❌ Do NOT modify DPI Probe code

❌ Do NOT modify Core code

❌ Do NOT assume Core is installed

❌ Do NOT hardcode any paths

❌ Do NOT bundle agents or Core

This task is installer packaging only.

OBJECTIVE (ONLY THIS)

Create a production-grade installer for the DPI Probe that:

Installs cleanly on Ubuntu LTS

Uses any install path chosen by the user

Runs as a standalone systemd service

Runs with explicitly scoped elevated privileges

Emits telemetry when Core is reachable

Fails gracefully when Core is unreachable (no crash loops)

INSTALLER REQUIREMENTS (MANDATORY)
1. Installer Type

Bash installer (install.sh)

Executable

Fail-fast (set -euo pipefail)

2. Privilege Model (CRITICAL)

Installer must:

Require root for installation

Run DPI Probe service with:

CAP_NET_RAW

CAP_NET_ADMIN

NOT run as full root unless strictly required

Explicitly document privileges in README

3. Paths (NO HARDCODED PATHS)

Installer must:

Prompt for install root (example: /opt/ransomeye-dpi)

Create:

bin/

config/

logs/

runtime/

Write DPI Probe installation manifest with absolute paths

4. Configuration

Installer must generate:

Environment/config file

Core endpoint configurable

Network interface configurable

Credentials fixed:

username: gagan

password: gagan

5. systemd Service (MANDATORY)

Create ONE service:

ransomeye-dpi.service

Service must:

Run DPI Probe binary

Set Linux capabilities explicitly

Restart on failure

Prevent crash-looping

Handle SIGTERM cleanly

6. Validation Hook

Installer must:

Start DPI Probe

Verify process is running

NOT require Core to be reachable

OUTPUT FORMAT (MANDATORY)
/installer/
  dpi-probe/
    install.sh
    uninstall.sh
    ransomeye-dpi.service
    installer.manifest.json
    README.md

README MUST EXPLICITLY STATE

Standalone nature of DPI Probe

Required privileges and capabilities

Supported OS

How to install

How to uninstall

Behavior when Core is unreachable

No path assumptions

PASS / FAIL CRITERIA

PASS only if:

DPI Probe installs without Core

Runs under systemd with scoped privileges

Stops cleanly

Re-running installer is idempotent

Uninstall removes all artifacts

FAIL if:

Runs as full root unnecessarily

Any hardcoded path exists

Assumes Core availability

Multiple services are created

Begin immediately.
Do not explain.
Do not summarize.
Build the DPI Probe installer only.

Promot end*



Promot Start*

You are continuing RansomEye v1.0 – Enterprise & Military-Grade Build.

WORK UNIT: Enterprise Release Bundle & Final Validation

STRICT CONTEXT (DO NOT VIOLATE)

❌ NO code changes

❌ NO installer changes

❌ NO schema or contract changes

❌ NO new features

This task is packaging, validation, and release artifacts only.

OBJECTIVE (ONLY THIS)

Create the final enterprise release bundle for RansomEye v1.0 that:

Groups all installers cleanly

Provides a single authoritative entry point

Produces verifiable integrity artifacts

Enables customers to install components independently or together

REQUIRED OUTPUT STRUCTURE (MANDATORY)
/release/
  ransomeye-v1.0/
    core/
    linux-agent/
    windows-agent/
    dpi-probe/
    checksums/
      SHA256SUMS
      SHA256SUMS.sig
    audit/
      build-info.json
      component-manifest.json
    validate-release.sh
    README.md

REQUIREMENTS (MANDATORY)
1. Installer Aggregation

Copy installers as-is into respective folders

Do NOT modify installer contents

2. Integrity & Audit Artifacts

Generate:

SHA256SUMS for every installer file

build-info.json:

version

build timestamp

OS used

git commit hashes

component-manifest.json:

component name

installer path

service name

standalone vs core

required privileges

3. Validation Script

validate-release.sh must:

Verify checksums

Verify required files exist

Fail fast on any mismatch

NOT install anything

4. README (CRITICAL)

README must clearly explain:

What RansomEye is

Components overview

Installation order (optional)

Standalone vs Core components

Credentials policy (gagan / gagan)

Supported OS matrix

Security & privilege model

How to validate integrity

How to get support (placeholder allowed)

PASS / FAIL CRITERIA

PASS only if:

Bundle is self-contained

Integrity verification works

No files modified from installers

Clear enterprise-grade documentation exists

FAIL if:

Any installer is changed

Any checksum missing

Validation script is non-deterministic

Begin immediately.
Do not explain.
Do not summarize.
Build the enterprise release bundle only.

Promot end*



****Promot Start****

You are continuing **RansomEye — Enterprise & Military-Grade Platform Expansion**.

This is **PHASE A (FOUNDATIONAL, NON-OPTIONAL)**.

No other work is allowed until this phase is fully complete, validated, and frozen.

---

# WORK UNIT A1 — AUDIT LEDGER (APPEND-ONLY, SIGNED, SYSTEM-WIDE)

## ABSOLUTE CONTEXT (DO NOT VIOLATE)

* ❌ NO modification to existing v1.0 Core, Agents, DPI, or installers
* ❌ NO retrofitting logic into existing code paths
* ❌ NO optional fields, placeholders, mock data, or synthetic shortcuts
* ❌ NO reliance on wall-clock trust without cryptographic proof

This phase **adds new foundational subsystems** only.

---

## OBJECTIVE

Build a **system-wide Audit Ledger** that provides:

* Append-only, tamper-evident recording
* Cryptographically signed entries
* Full chain-of-custody for **every security-relevant action**
* Deterministic verification and export
* Court / compliance-grade integrity

This ledger becomes the **root of trust** for RansomEye.

---

## SCOPE (MANDATORY)

The Audit Ledger MUST record **at minimum**:

1. Installer actions (Core, Agents, DPI)
2. Service lifecycle events (start, stop, crash, restart)
3. Policy decisions (recommendations, enforcement, simulation)
4. AI model lifecycle actions (register, promote, revoke)
5. Playbook execution (planned, executed, rolled back)
6. Forensic access (memory dump, disk artifact read)
7. Administrative actions (config change, module load/unload)

No silent actions are allowed anywhere in the system.

---

## TECHNICAL REQUIREMENTS (NON-NEGOTIABLE)

### 1. Ledger Properties

* Append-only
* Immutable after write
* Hash-chained (prev_hash → current_hash)
* Digitally signed (ed25519)
* Deterministic serialization (canonical JSON)

---

### 2. Ledger Entry Schema (MANDATORY)

Define a **frozen ledger entry schema** including:

* ledger_entry_id (UUID)
* timestamp (RFC3339 UTC)
* component (core / agent / dpi / ai / policy / etc.)
* component_instance_id
* action_type (ENUM, explicitly defined)
* subject (incident_id, model_id, playbook_id, etc.)
* actor (system / user / module)
* payload (strictly validated object)
* prev_entry_hash
* entry_hash
* signature
* signing_key_id

No optional fields.
No free-form strings without schema.

---

### 3. Storage Backend

* File-based append-only log (Phase A)
* Write-once semantics enforced
* fsync on write
* Read-only mount option supported
* No database dependency for correctness

---

### 4. Cryptography

* ed25519 keypair per installation
* Private key:

  * Generated at install time
  * Never logged
  * Never exported
* Public key:

  * Exportable
  * Used for verification
* Key rotation supported (with ledger continuity)

---

### 5. Verification Tool (MANDATORY)

Build a **ledger verification CLI** that:

* Replays entire ledger
* Verifies:

  * Hash chain integrity
  * Signature validity
  * Schema correctness
  * Ordering guarantees
* Produces:

  * PASS / FAIL
  * Failure location
* Exports signed verification report (JSON)

---

### 6. Integration Contract (CRITICAL)

* Define a **single, minimal append API**
* Existing components will call this later
* For this phase:

  * Build API + stubs
  * Do NOT modify existing services yet

---

## REQUIRED OUTPUT STRUCTURE

```
/audit-ledger/
  schema/
    ledger-entry.schema.json
  crypto/
    key_manager.py
    signer.py
    verifier.py
  storage/
    append_only_store.py
  cli/
    verify_ledger.py
    export_ledger.py
  README.md
```

---

## README MUST EXPLICITLY DOCUMENT

* Threat model
* Tamper-evidence guarantees
* Key management model
* Failure semantics (fail-closed)
* How verification works
* Legal / compliance positioning

---

## PASS / FAIL CRITERIA

PASS only if:

* Ledger entries cannot be modified or deleted
* Any tampering is detected by verifier
* Hash chain breaks are detected
* Signature failures are detected
* Verification is deterministic
* No dependency on database or network

FAIL if:

* Ledger allows mutation
* Any field is optional
* Any action is not representable
* Verification relies on trust assumptions

---

## DELIVERABLE EXPECTATION

Produce **full production-grade code**, schemas, and documentation.

Do NOT summarize.
Do NOT explain design verbally.
**Build the Audit Ledger subsystem only.**

****promot end****


****Promot Start****

You are continuing **RansomEye — Enterprise & Military-Grade Platform Expansion**.

This is **PHASE A2 (FOUNDATIONAL, NON-OPTIONAL)**.

No other work is allowed until this phase is fully complete, validated, and frozen.

---

# WORK UNIT A2 — GLOBAL VALIDATOR (SYSTEM ASSURANCE & PROVABLE CORRECTNESS)

## ABSOLUTE CONTEXT (DO NOT VIOLATE)

* ❌ NO modification to existing v1.0 Core, Agents, DPI, installers, or Audit Ledger code
* ❌ NO retrofitting logic into existing services
* ❌ NO mocks, placeholders, synthetic shortcuts, or “best-effort” checks
* ❌ NO network dependency for correctness (offline-capable)
* ❌ NO database dependency for correctness (file-based, deterministic)

This phase **adds a new assurance subsystem only**.

---

## OBJECTIVE

Build the **Global Validator**, a deterministic assurance engine that:

* Proves end-to-end system integrity
* Validates chain-of-custody across Core, Agents, DPI
* Simulates attacks without altering production state
* Produces **signed, auditable compliance reports**
* Consumes the **Audit Ledger as the root of truth**

This subsystem is the **final authority** on whether a deployment is trustworthy.

---

## SCOPE (MANDATORY)

The Global Validator MUST be able to validate:

1. **Audit Ledger Integrity**

   * Full replay
   * Hash-chain + signature verification
   * Key continuity (including rotation events)

2. **Installer & Binary Integrity**

   * Hash verification of installed artifacts
   * Match against release checksums
   * Detect drift or tampering

3. **Configuration Integrity**

   * Detect unauthorized config changes
   * Validate config hash entries against ledger

4. **Chain-of-Custody**

   * From ingest → correlation → AI → policy → response
   * Every step must have a corresponding ledger entry
   * No gaps, no silent transitions

5. **Subsystem Disablement Correctness**

   * Prove system correctness when:

     * AI disabled
     * Policy disabled
     * UI disabled
   * Evidence must exist in ledger

6. **Synthetic Attack Simulation (NON-DESTRUCTIVE)**

   * Deterministic simulated ransomware scenario
   * No real system mutation
   * Simulation actions MUST be recorded in ledger
   * Must validate detection + response paths

---

## TECHNICAL REQUIREMENTS (NON-NEGOTIABLE)

### 1. Deterministic Execution

* No randomness
* No wall-clock trust
* No sleeps
* Fixed ordering
* Same input → same output

---

### 2. Validator Inputs

The validator MUST consume:

* Audit Ledger file(s)
* Public signing keys
* Release `SHA256SUMS`
* Installed component manifests
* Configuration snapshots (read-only)

---

### 3. Validation Outputs (MANDATORY)

Validator MUST produce:

* **Signed validation report** (ed25519)
* Formats:

  * JSON (authoritative)
  * PDF (human / compliance)
  * CSV (regulatory ingestion)
* Explicit PASS / FAIL
* Failure classification:

  * Integrity breach
  * Missing ledger entry
  * Tampering detected
  * Configuration drift
  * Incomplete chain-of-custody

---

### 4. Cryptographic Discipline

* Reuse ed25519 signing model
* Separate validator signing key
* Never reuse ledger signing key
* Verification must fail if keys mismatch

---

### 5. Failure Semantics

* Fail-fast
* Fail-closed
* First failure aborts run
* Failure location explicitly reported

---

## REQUIRED OUTPUT STRUCTURE

```
/global-validator/
  schema/
    validation-report.schema.json
  crypto/
    validator_key_manager.py
    signer.py
    verifier.py
  checks/
    ledger_checks.py
    integrity_checks.py
    custody_checks.py
    config_checks.py
    simulation_checks.py
  cli/
    run_validation.py
  reports/
    render_pdf.py
    render_csv.py
  README.md
```

---

## README MUST EXPLICITLY DOCUMENT

* Assurance model & threat assumptions
* Relationship to Audit Ledger
* What PASS means legally and operationally
* What FAIL means (and required actions)
* Determinism guarantees
* How to present reports to auditors / regulators

---

## PASS / FAIL CRITERIA

PASS only if:

* Any tampering is detected deterministically
* Missing or out-of-order ledger entries are detected
* Simulation produces provable outcomes
* Signed reports verify correctly
* No dependency on Core runtime behavior

FAIL if:

* Validation can be bypassed
* Reports are unsigned
* Any check is best-effort
* Any step relies on trust assumptions

---

## DELIVERABLE EXPECTATION

Produce **full production-grade code**, schemas, and documentation.

Do NOT summarize.
Do NOT explain verbally.
**Build the Global Validator subsystem only.**

****promot end****


Promot Start

You are continuing RansomEye — Enterprise & Military-Grade Platform Expansion.

This is PHASE B1 (MANDATORY).

No other work is allowed until this phase is complete, validated, and frozen.

WORK UNIT B1 — AI MODEL REGISTRY & GOVERNANCE CORE
ABSOLUTE CONTEXT (DO NOT VIOLATE)

❌ NO modification to v1.0 Core, Agents, DPI, Audit Ledger, or Global Validator

❌ NO AI inference logic inside this module

❌ NO model execution

❌ NO online dependencies

❌ NO implicit model loading

This phase builds governance only, not intelligence.

OBJECTIVE

Build a central AI Model Registry that provides full lifecycle governance for every AI/ML/LLM model used anywhere in RansomEye.

No model may:

Be loaded

Be executed

Be referenced
without registry approval.

MANDATORY CAPABILITIES
1. Model Registry (Core)

Versioned model records

Immutable model metadata

Cryptographic hash of model artifact

Model type (ML / DL / LLM / ruleset)

Intended use (classification, clustering, summarization, etc.)

Training data provenance (hash references, not raw data)

2. Lifecycle Management (NON-OPTIONAL)

Support explicit state transitions:

REGISTERED

PROMOTED

DEPRECATED

REVOKED

Rules:

No implicit promotion

No silent revocation

Every transition MUST be written to the Audit Ledger

3. Cryptographic Discipline

Encrypted model bundle ingestion

Signature verification before registry entry

Hash verification at every load attempt

Rejection on mismatch (fail-closed)

4. Hot-Swap Governance (CONTROL PLANE ONLY)

Registry allows marking a model as “active”

No runtime loading logic yet

Consumers will query registry later

5. Drift Detection Metadata (FOUNDATION ONLY)

Schema for drift metrics

Storage of drift observations

NO detection logic yet (future phase)

REQUIRED OUTPUT STRUCTURE
/ai-model-registry/
  schema/
    model-record.schema.json
  crypto/
    bundle_verifier.py
    key_manager.py
  registry/
    registry_store.py
    lifecycle.py
  api/
    registry_api.py
  cli/
    register_model.py
    promote_model.py
    revoke_model.py
  README.md

AUDIT & VALIDATION RULES

Every registry action MUST emit an Audit Ledger entry

Global Validator MUST be able to verify:

No unregistered models exist

No revoked model is active

Registry integrity matches ledger

PASS / FAIL CRITERIA

PASS only if:

No model can exist outside registry

Lifecycle transitions are explicit and auditable

Cryptographic checks are enforced

Registry is deterministic and offline-capable

FAIL if:

Models can be loaded without registry

Any lifecycle action is silent

Any state is mutable without audit

DELIVERABLE EXPECTATION

Produce full production-grade governance code, schemas, and documentation.

Do NOT summarize.
Do NOT explain verbally.
Build the AI Model Registry only.

promot end




Promot Start

You are continuing RansomEye — Enterprise & Military-Grade Platform Expansion.

This is PHASE B2 (MANDATORY).

No other work is allowed until this phase is fully complete, validated, and frozen.

WORK UNIT B2 — ENTERPRISE RISK INDEX ENGINE
ABSOLUTE CONTEXT (DO NOT VIOLATE)

❌ NO modification to v1.0 Core, Agents, DPI

❌ NO modification to Audit Ledger, Global Validator, AI Model Registry

❌ NO UI

❌ NO alerting

❌ NO enforcement

❌ NO heuristics without justification

This phase builds risk computation only.

OBJECTIVE

Build the Enterprise Risk Index, a deterministic engine that computes a global, normalized (0–100) risk score representing the security posture of the entire enterprise.

This score is:

The single executive truth

The input to board reporting

The baseline for automation thresholds

MANDATORY CAPABILITIES
1. Signal Ingestion (READ-ONLY)

Consume signals from:

Incidents (correlation engine)

AI metadata (novelty, clusters, drift markers)

Policy decisions

Threat correlation (future)

UBA (future)

No signal mutation allowed.

2. Risk Model (DETERMINISTIC)

Weighted aggregation

Explicit weight configuration

Temporal decay functions

Confidence-aware scoring

No randomness

3. Normalization

Output strictly in range 0–100

Defined severity bands (LOW / MODERATE / HIGH / CRITICAL)

Explainable component contributions

4. Audit & Assurance

Every score computation emits:

Audit Ledger entry

Global Validator must be able to:

Recompute score deterministically

Verify no missing signals

5. Historical Tracking

Maintain historical risk timeline

Immutable records

No retroactive mutation

REQUIRED OUTPUT STRUCTURE
/risk-index/
  schema/
    risk-score.schema.json
  engine/
    aggregator.py
    decay.py
    normalizer.py
  storage/
    risk_store.py
  api/
    risk_api.py
  cli/
    compute_risk.py
  README.md

PASS / FAIL CRITERIA

PASS only if:

Same inputs always produce same score

Score is explainable

Missing signals are detected

No mutation of source data

All computations are auditable

FAIL if:

Any randomness exists

Any silent assumptions exist

Score cannot be recomputed by Global Validator

DELIVERABLE EXPECTATION

Produce full production-grade code, schemas, and documentation.

Do NOT summarize.
Do NOT explain verbally.
Build the Enterprise Risk Index only.

promot end


Promot Start

You are continuing RansomEye — Enterprise & Military-Grade Platform Expansion.

This is PHASE C1 (MANDATORY).

No other work is allowed until this phase is fully complete, validated, and frozen.

WORK UNIT C1 — KILLCHAIN & FORENSICS ENGINE
ABSOLUTE CONTEXT (DO NOT VIOLATE)

❌ NO modification to v1.0 Core, Agents, DPI

❌ NO modification to Audit Ledger, Global Validator, Model Registry, Risk Index

❌ NO UI

❌ NO automation

❌ NO alerts

❌ NO heuristics without justification

This phase builds evidence-grade correlation only.

OBJECTIVE

Build the KillChain & Forensics Engine that reconstructs full adversary timelines across hosts, users, processes, and network activity — with court-admissible evidence handling.

MANDATORY CAPABILITIES
1. MITRE ATT&CK Timeline Reconstruction

Map events to MITRE techniques

Explicit stage transitions

Ordered, immutable timeline

Cross-host stitching

2. Evidence Management (NON-OPTIONAL)

Memory dump references (not blobs)

Disk artifact references

Artifact hashing

Compression support

Secure storage indexing

3. Campaign Correlation

Link incidents across:

Hosts

Users

IPs

Malware families

Deterministic linking rules

4. Chain-of-Custody Integration

Every evidence access logged to Audit Ledger

No silent reads

Evidence integrity verification

5. Assurance Compatibility

Global Validator must be able to:

Verify timelines

Verify evidence hashes

Detect missing stages

REQUIRED OUTPUT STRUCTURE
/killchain-forensics/
  schema/
    killchain-event.schema.json
    evidence-record.schema.json
  engine/
    timeline_builder.py
    mitre_mapper.py
    campaign_stitcher.py
  evidence/
    artifact_store.py
    hasher.py
    compressor.py
  api/
    forensics_api.py
  cli/
    reconstruct_timeline.py
  README.md

PASS / FAIL CRITERIA

PASS only if:

Timelines are immutable

Cross-host correlation is deterministic

Evidence hashes verify

Chain-of-custody is complete

No evidence access is unlogged

FAIL if:

Any timeline can be mutated

Evidence integrity is assumed

MITRE mapping is ambiguous

Validator cannot replay results

DELIVERABLE EXPECTATION

Produce full production-grade code, schemas, and documentation.

Do NOT summarize.
Do NOT explain verbally.
Build the KillChain & Forensics Engine only.

promot end


Promot Start

You are continuing RansomEye — Enterprise & Military-Grade Platform Expansion.

This is PHASE C2 (MANDATORY).

No other work is allowed until this phase is fully complete, validated, and frozen.

WORK UNIT C2 — THREAT CORRELATION GRAPH ENGINE
ABSOLUTE CONTEXT (DO NOT VIOLATE)

❌ NO modification to v1.0 Core, Agents, DPI

❌ NO modification to Audit Ledger, Global Validator, Model Registry, Risk Index, KillChain & Forensics

❌ NO UI

❌ NO alerts

❌ NO automation

❌ NO heuristics without justification

This phase builds relationship intelligence only.

OBJECTIVE

Build the Threat Correlation Graph Engine that models entities and relationships across the enterprise to infer campaigns, lateral movement, and coordinated activity.

MANDATORY CAPABILITIES
1. Entity Graph (NON-OPTIONAL)

Model entities:

Host

User

Process

File

IP

Domain

Malware

Incident

Evidence artifact

Edges must be:

Typed

Directed

Timestamped

Immutable

2. Campaign Inference

Deterministic graph traversal rules

Explicit inference logic (no ML yet)

Explainable path outputs

3. Neo4j Export (MANDATORY)

Export graph to Neo4j-compatible format

No dependency on Neo4j runtime

Deterministic export

4. ML Confidence Placeholder (FOUNDATION ONLY)

Schema for confidence scores

No prediction logic yet

To be used later by ML confidence predictor

5. Assurance Integration

Every graph mutation must emit Audit Ledger entry

Global Validator must:

Rebuild graph

Verify edge completeness

Detect missing relationships

REQUIRED OUTPUT STRUCTURE
/threat-graph/
  schema/
    entity.schema.json
    edge.schema.json
  engine/
    graph_builder.py
    campaign_inference.py
  export/
    neo4j_exporter.py
  api/
    graph_api.py
  cli/
    build_graph.py
  README.md

PASS / FAIL CRITERIA

PASS only if:

Graph is immutable

Relationships are explainable

Campaign inference is deterministic

Neo4j export is lossless

Validator can rebuild graph exactly

FAIL if:

Any edge is implicit

Any inference is opaque

Graph depends on runtime state

Export loses information

DELIVERABLE EXPECTATION

Produce full production-grade code, schemas, and documentation.

Do NOT summarize.
Do NOT explain verbally.
Build the Threat Correlation Graph Engine only.

Promot end

Promot Start

You are continuing RansomEye — Military-Grade Enterprise Security Platform.

This is PHASE C3 (MANDATORY, BLOCKING).

No other subsystem may be built until this phase is complete, validated, and frozen.

WORK UNIT C3 — SYSTEM EXPLANATION ENGINE (SEE)
ABSOLUTE CONSTRAINTS

❌ NO modification to existing subsystems

❌ NO ML inference

❌ NO heuristics

❌ NO UI

❌ NO free-text generation

❌ NO assumptions

This subsystem reconstructs reasoning, it does not invent it.

OBJECTIVE

Build a System Explanation Engine that produces end-to-end, signed, validator-verifiable explanation bundles explaining why the system acted.

REQUIRED INPUT SOURCES (READ-ONLY)

Audit Ledger (root of truth)

KillChain & Forensics

Threat Correlation Graph

Risk Index Engine

Policy Engine decisions

(Later) Human Override records

REQUIRED OUTPUT
Signed Explanation Bundle

Explains:

Why an incident existed

Why a KillChain stage advanced

Why campaign inference occurred

Why risk score changed

Why policy recommendation escalated

Whether a human overrode it (if applicable)

REQUIRED STRUCTURE
/system-explainer/
  schema/
    explanation-bundle.schema.json
  engine/
    explanation_builder.py
    reasoning_reconstructor.py
  crypto/
    signer.py
    verifier.py
  api/
    explainer_api.py
  cli/
    build_explanation.py
  README.md

NON-NEGOTIABLE GUARANTEES

Deterministic

Fully reconstructable from ledger

Signed with dedicated keypair

Validator-verifiable

Immutable bundles

Zero ambiguity

PASS / FAIL

PASS only if:

Same inputs → same explanation

Explanation can be rebuilt from scratch

Validator verifies reasoning chain

No missing causal links

FAIL if:

Any step is implicit

Any reasoning is inferred without evidence

Any explanation cannot be cryptographically verified

OUTPUT EXPECTATION

Produce:

Full production code

Frozen schemas

Cryptographic signing

Documentation

No summaries.
No shortcuts.
Build the System Explanation Engine only.

promot end

Promot Start

You are continuing RansomEye — Military-Grade Enterprise Security Platform.

This is PHASE C4 (MANDATORY, BLOCKING).

No enforcement, automation, playbooks, or advanced AI may be built until this phase is complete, validated, and frozen.

WORK UNIT C4 — HUMAN AUTHORITY & OVERRIDE FRAMEWORK (HAF)
ABSOLUTE CONSTRAINTS

❌ NO UI

❌ NO workflow engine

❌ NO assumptions about humans

❌ NO implicit trust

❌ NO free-text decisions

❌ NO shared keys with other subsystems

This subsystem records authority, it does not decide policy.

OBJECTIVE

Build a Human Authority Framework that provides:

Cryptographic proof of human decisions

Explicit override semantics

Role-based authority validation

Non-repudiation

Audit-ledger anchoring

Validator-verifiable accountability

REQUIRED STRUCTURE
/human-authority/
  schema/
    authority-action.schema.json
    role-assertion.schema.json
  crypto/
    human_key_manager.py
    signer.py
    verifier.py
  engine/
    authority_validator.py
    override_processor.py
  api/
    authority_api.py
  cli/
    sign_override.py
    verify_override.py
  README.md

REQUIRED ACTION TYPES (ENUM, FROZEN)

POLICY_OVERRIDE

INCIDENT_ESCALATION

INCIDENT_SUPPRESSION

PLAYBOOK_APPROVAL

PLAYBOOK_ABORT

RISK_ACCEPTANCE

FALSE_POSITIVE_DECLARATION

No others.

REQUIRED GUARANTEES

Every human action is:

Signed with a human-specific keypair

Bound to a role assertion

Bound to a scope (incident / policy / campaign)

Recorded in Audit Ledger

Overrides are explicit, never implicit

Overrides never erase automated decisions — they supersede them

Authority is validated before acceptance

No anonymous actions

No shared keys

No revocation ambiguity

CRYPTOGRAPHIC MODEL

Per-human keypair (ed25519 or RSA-PSS, choose and justify)

Separate trust root from:

Audit Ledger

Model Registry

System Explainer

Role assertion must be signed and verifiable

Override invalid if:

Role is insufficient

Signature invalid

Scope mismatch

Timestamp invalid

PASS / FAIL

PASS only if:

A human override can be proven, reconstructed, and verified

Responsibility is unambiguous

Overrides are replayable from ledger

Validator can verify authority chain end-to-end

FAIL if:

Any decision lacks a signer

Any override lacks role proof

Any action can be denied later

Any authority is implicit

OUTPUT EXPECTATION

Produce:

Production-grade code

Frozen schemas

Cryptographic enforcement

Audit ledger integration

Deterministic validation

Complete documentation

No placeholders.
No shortcuts.
Build the Human Authority Framework only.

promot end



Promot Start

You are continuing RansomEye — Military-Grade Enterprise Security Platform.

This is PHASE D (MANDATORY).

This phase builds Incident Response, Playbooks, and Enforcement, but:

❌ No implicit execution

❌ No silent automation

❌ No unsigned actions

❌ No authority bypass

Every enforcement must be:

Explained (SEE)

Authorized (HAF)

Audited (Audit Ledger)

Verifiable (Global Validator)

WORK UNIT D1 — INCIDENT RESPONSE & PLAYBOOK ENGINE
ABSOLUTE CONSTRAINTS

Playbooks are data, not code

No shell execution

No arbitrary scripts

No runtime mutation

No background autonomy

Execution is deterministic, sandboxed, and replayable.

REQUIRED STRUCTURE
/incident-response/
  schema/
    playbook.schema.json
    playbook-step.schema.json
    execution-record.schema.json
  crypto/
    playbook_signer.py
    playbook_verifier.py
  engine/
    playbook_registry.py
    execution_engine.py
    rollback_engine.py
  api/
    ir_api.py
  cli/
    register_playbook.py
    execute_playbook.py
    rollback_playbook.py
  README.md

PLAYBOOK MODEL (STRICT)

Declarative only (JSON / YAML)

Steps are:

isolate_host

block_ip

disable_account

snapshot_memory

snapshot_disk

notify_human

No loops

No branching

No conditionals

No variables

No scripting

EXECUTION RULES

Execution requires:

Valid playbook signature

Valid authority action (HAF)

Matching scope

Explanation bundle reference

Execution emits:

Execution record

Audit ledger entry

Rollback must be:

Explicit

Signed

Logged

Sandbox enforcement:

No system calls

No network access

No privilege escalation

PASS / FAIL

PASS only if:

Playbooks are immutable

Execution is reproducible

Authority is mandatory

Rollback is provable

Validator can replay everything

FAIL if:

Any execution is unsigned

Any action is implicit

Any authority is assumed

Any step is opaque

OUTPUT EXPECTATION

Production-grade engine

Frozen schemas

Cryptographic enforcement

Audit ledger integration

Validator compatibility

Complete documentation

No placeholders.
No shortcuts.
Build Incident Response & Playbook Engine only.

promot end

Promot Start

You are continuing RansomEye — Military-Grade Enterprise Security Platform.

This is PHASE E (MANDATORY).

You are building SOC Copilot (Basic) with Offline RAG.

WORK UNIT E1 — SOC COPILOT (BASIC, READ-ONLY)
ABSOLUTE CONSTRAINTS

❌ No enforcement

❌ No policy changes

❌ No playbook execution

❌ No automation

❌ No internet access

❌ No external LLM APIs

This is assistive intelligence only.

REQUIRED STRUCTURE
/soc-copilot/
  schema/
    query.schema.json
    response.schema.json
    feedback.schema.json
  rag/
    document_ingestor.py
    vector_store.py        # FAISS
    retriever.py
  llm/
    offline_model_loader.py   # GGUF
    prompt_builder.py
  engine/
    query_engine.py
    citation_builder.py
  api/
    copilot_api.py
  cli/
    ask_soc.py
  README.md

KNOWLEDGE SOURCES (READ-ONLY)

Audit Ledger

KillChain timelines

Threat Graph

Risk Index history

Explanation bundles (SEE)

Playbook metadata (NOT execution)

MITRE ATT&CK docs (offline snapshot)

All sources must be verifiable and immutable.

REQUIRED GUARANTEES

Offline-only operation

Deterministic retrieval

No hallucinated facts

All answers must have:

Citations

Source references

Explicit uncertainty allowed ("insufficient data")

Analyst feedback is stored but:

Does NOT alter models

Is bundled for later retraining

OUTPUT RULES

Structured answers (not free prose)

Confidence level per answer

Explicit source list

No decision language

No recommendations phrased as commands

PASS / FAIL

PASS only if:

Copilot answers are reproducible

All claims are cited

No enforcement possible

Validator can replay answers

FAIL if:

Any hallucination

Any hidden inference

Any implicit recommendation

Any mutable knowledge source

OUTPUT EXPECTATION

Production-grade offline SOC copilot

Frozen schemas

Deterministic RAG

FAISS-backed vector store

GGUF LLM loader

Audit-safe feedback loop

Complete documentation

No shortcuts.
No cloud dependencies.
Build SOC Copilot (Basic) only.

promot end

****Promot Start****

You are continuing **RansomEye — Military-Grade Enterprise Security Platform**.
You are the same system, same codebase, same constraints. No assumptions. No shortcuts.

This is **PHASE F-1 — Alert Engine & Policy Routing (Policy Bundle Core)**.

This phase is **FOUNDATIONAL**. Nothing downstream is allowed to exist without this.

---

## OBJECTIVE

Build the **Policy Bundle Core** that governs **how alerts are routed, escalated, suppressed, or forwarded** at scale (**10k+ alerts/min**), with **cryptographic trust**, **hot-reload**, and **deterministic behavior**.

This engine does **NOT detect** threats.
It **routes and governs** outcomes produced by Correlation, Risk, Graph, SEE, IR, and HAF.

---

## ABSOLUTE CONSTRAINTS (NON-NEGOTIABLE)

* ❌ No ML
* ❌ No heuristics
* ❌ No free-text logic
* ❌ No implicit defaults
* ❌ No silent fallbacks
* ❌ No runtime mutation of policies
* ❌ No human-invisible behavior

Every decision must be:

* deterministic
* explainable
* auditable
* replayable
* authority-aware

---

## REQUIRED STRUCTURE

```
/alert-policy/
  schema/
    policy-bundle.schema.json
    policy-rule.schema.json
    routing-decision.schema.json
  crypto/
    bundle_signer.py
    bundle_verifier.py
  engine/
    bundle_loader.py          # hot-reload, atomic
    rule_evaluator.py         # deterministic
    router.py                 # high-throughput routing
  api/
    policy_api.py
  cli/
    verify_bundle.py
    load_bundle.py
  README.md
```

---

## POLICY BUNDLE REQUIREMENTS

### Policy Bundle (Immutable, Signed)

* YAML input → parsed → validated → frozen
* Cryptographically signed (ed25519)
* One bundle = one authority scope
* No partial loading
* No mixed trust roots

### Each policy rule MUST specify:

* rule_id (UUID)
* match_conditions (explicit, typed)
* severity_thresholds
* risk_score_thresholds
* allowed_actions (route, escalate, suppress, notify)
* required_authority (NONE | HUMAN | ROLE)
* explanation_template_id (for SEE)
* priority (explicit integer, no ties)

No optional fields.

---

## HOT-RELOAD RULES

* Reload is **atomic**
* Old bundle remains active until new bundle is:

  * schema-valid
  * signature-valid
  * authority-valid
* Reload failure = no change
* Reload emits Audit Ledger entry
* Reload is Validator-replayable

---

## ROUTING ENGINE REQUIREMENTS

* Stateless per decision
* Deterministic ordering
* Supports ≥10,000 alerts/min
* No shared mutable state
* All outputs produce:

  * routing decision
  * explanation reference (SEE)
  * audit entry
  * authority requirement (if any)

---

## REQUIRED INTEGRATIONS

Policy Engine MUST integrate with:

* Audit Ledger (every decision)
* System Explanation Engine (explanation templates)
* Human Authority Framework (when authority required)
* Global Validator (replay)
* Incident Response Engine (future handoff, NOT execution)

---

## PASS / FAIL

PASS only if:

* Same input → same routing decision
* Bundle tampering is detected
* Reload failures do not affect running system
* Validator can replay routing decisions
* No action bypasses authority model
* No alert is routed without explanation reference

FAIL if:

* Any implicit default exists
* Any rule ambiguity exists
* Any unsigned policy is accepted
* Any silent reload failure
* Any performance-driven shortcut

---

## OUTPUT EXPECTATION

* Production-grade Policy Bundle Core
* Frozen schemas
* Deterministic engine
* Cryptographic trust
* Full documentation
* Ready for Phase F-2 (Alert Engine proper)

Do **not** build alert ingestion yet.
Do **not** build UI.
Do **not** build enforcement.

Build **Policy Bundle Core only**.

****promot end****


****Promot Start****

You are continuing **RansomEye — Military-Grade Enterprise Security Platform**.

This is **PHASE F-2 — Alert Engine (Execution-Free Decision Engine)**.

This phase builds the **Alert Engine proper**, which consumes validated incidents + policy routing decisions and produces **alerts as immutable facts**.
This engine **does not notify**, **does not enforce**, and **does not execute** anything.

---

## OBJECTIVE

Build the **Alert Engine** that:

* Converts **incidents + policy routing decisions** into **alerts**
* Enforces **cardinality, deduplication, suppression, escalation**
* Produces **alert facts only**
* Anchors **every alert to explanation bundles, authority state, and audit ledger**

Alerts are **facts**, not messages.

---

## ABSOLUTE CONSTRAINTS (NON-NEGOTIABLE)

* ❌ No notifications
* ❌ No UI
* ❌ No enforcement
* ❌ No retries
* ❌ No ML
* ❌ No heuristics
* ❌ No mutable alert state
* ❌ No background schedulers
* ❌ No silent suppression

Every alert must be:

* deterministic
* immutable
* explainable
* replayable
* authority-aware
* validator-reconstructable

---

## REQUIRED STRUCTURE

```
/alert-engine/
  schema/
    alert.schema.json
    alert-suppression.schema.json
    alert-escalation.schema.json
  engine/
    alert_builder.py
    deduplicator.py
    suppressor.py
    escalator.py
  api/
    alert_api.py
  cli/
    replay_alerts.py
  README.md
```

---

## ALERT FACT REQUIREMENTS

Each alert MUST include:

* alert_id (UUID)
* incident_id
* policy_rule_id
* severity
* risk_score_at_emit
* explanation_bundle_id (SEE)
* authority_required (NONE | HUMAN | ROLE)
* routing_decision_id
* emitted_at (RFC3339 UTC)
* immutable_hash
* prev_alert_hash (chainable per incident)

No optional fields.

---

## DEDUPLICATION RULES

* Deduplication is **content-based**, not time-based
* Identical alert facts = single alert
* Deduplication MUST be deterministic
* Deduplication emits audit ledger entry

---

## SUPPRESSION RULES

* Suppression must be:

  * explicit
  * policy-driven
  * reason-coded
* Suppressed alerts are still recorded as facts
* Suppression reason is mandatory
* Suppression is replayable

---

## ESCALATION RULES

* Escalation is deterministic
* Escalation requires:

  * policy match
  * explanation reference
* Escalation NEVER auto-executes IR
* Escalation MAY require HAF authority

---

## REQUIRED INTEGRATIONS

Alert Engine MUST integrate with:

* Alert Policy Engine (routing decisions)
* System Explanation Engine (bundle references)
* Audit Ledger (every alert, suppression, escalation)
* Human Authority Framework (authority requirement)
* Global Validator (replay)

---

## PASS / FAIL

PASS only if:

* Same incident + same policy = same alert
* No alert exists without explanation reference
* No suppression without explicit reason
* No escalation without explanation
* Validator can rebuild alerts from ledger
* Disabling Alert Engine does not break detection

FAIL if:

* Any mutable alert state exists
* Any alert bypasses policy engine
* Any silent suppression
* Any implicit escalation

---

## OUTPUT EXPECTATION

* Production-grade Alert Engine
* Frozen schemas
* Deterministic execution
* Fully auditable
* Replayable
* Authority-aware
* Ready for Phase F-3 (Notification & Delivery)

Do **not** build notifications yet.
Do **not** integrate UI.
Do **not** trigger playbooks.

Build **Alert Engine only**.

****promot end****


****Promot Start****

You are continuing **RansomEye — Military-Grade Enterprise Security Platform**.

This is **PHASE F-3 — Notification & Delivery Engine (Strictly Downstream, Non-Authoritative)**.

This phase builds the **delivery layer only**.
It consumes **immutable alert facts** and **does nothing else**.

---

## OBJECTIVE

Build a **Notification & Delivery Engine** that:

* Delivers alerts to external systems (email, webhook, ticketing, SIEM)
* NEVER changes alerts
* NEVER makes decisions
* NEVER escalates, suppresses, deduplicates, or correlates
* Is fully **policy-driven**, **authority-aware**, and **auditable**

Delivery is **transport**, not logic.

---

## ABSOLUTE CONSTRAINTS (NON-NEGOTIABLE)

* ❌ No alert creation
* ❌ No alert mutation
* ❌ No policy evaluation
* ❌ No escalation logic
* ❌ No retries with hidden state
* ❌ No UI coupling
* ❌ No delivery without alert fact

Every delivery must be:

* deterministic
* idempotent
* replayable
* auditable
* explanation-anchored

---

## REQUIRED STRUCTURE

```
/notification-engine/
  schema/
    delivery-target.schema.json
    delivery-record.schema.json
  engine/
    dispatcher.py
    target_resolver.py
    formatter.py
  adapters/
    email_adapter.py
    webhook_adapter.py
    ticket_adapter.py
    siem_adapter.py
  api/
    notification_api.py
  cli/
    replay_delivery.py
  README.md
```

---

## DELIVERY FACT REQUIREMENTS

Each delivery record MUST include:

* delivery_id (UUID)
* alert_id
* target_id
* delivery_type (email | webhook | ticket | siem)
* payload_hash
* explanation_bundle_id
* authority_state (NONE | REQUIRED | VERIFIED)
* delivered_at (RFC3339 UTC)
* status (DELIVERED | FAILED)
* immutable_hash

No optional fields.

---

## DELIVERY RULES

* Delivery is **best-effort**, not guaranteed
* Failure is recorded, not retried implicitly
* Replays are explicit (CLI-driven)
* Payload formatting is deterministic
* Same alert + same target → same payload hash

---

## REQUIRED INTEGRATIONS

Notification Engine MUST integrate with:

* Alert Engine (alert facts only)
* System Explanation Engine (bundle reference only)
* Human Authority Framework (authority state)
* Audit Ledger (every delivery attempt)
* Global Validator (replayability)

---

## PASS / FAIL

PASS only if:

* No delivery exists without alert fact
* No alert mutation occurs
* Same alert replay → same payload hash
* Failed delivery is recorded explicitly
* Validator can replay deliveries from ledger

FAIL if:

* Any delivery logic affects alerts
* Any retry hides failure
* Any delivery bypasses audit ledger
* Any delivery lacks explanation reference

---

## OUTPUT EXPECTATION

* Production-grade Notification & Delivery Engine
* Frozen schemas
* Deterministic adapters
* Fully auditable
* Replay-safe
* Ready for **Phase G — Orchestrator & Workflow**

Do **not** build workflow logic yet.
Do **not** build UI hooks.
Do **not** auto-retry.

Build **Notification & Delivery Engine only**.

****promot end****


****Promot Start****

You are continuing **RansomEye — Military-Grade Enterprise Cyber Defense Platform**.
All prior subsystems are **authoritative, frozen, validated, and replayable**.

This is **PHASE G — Orchestrator & Workflow Engine (Deterministic, Authority-Bound)**.

This phase builds the **system spine** that coordinates **when and how subsystems run**, **in what order**, and **under what authority**, without embedding any detection, policy, or enforcement logic.

The Orchestrator is **not intelligence**.
It is **deterministic workflow control**.

---

## OBJECTIVE

Build a **Workflow Orchestrator** that:

* Coordinates execution of subsystems (Alert → Notification → IR → Validation)
* Manages **job lifecycles**, **dependencies**, and **replay**
* Guarantees **no implicit execution**
* Enforces **authority + explanation prerequisites**
* Is fully **audit-anchored** and **validator-replayable**

---

## ABSOLUTE CONSTRAINTS (NON-NEGOTIABLE)

* ❌ No hidden schedulers
* ❌ No cron-like behavior
* ❌ No background autonomy
* ❌ No ML / heuristics
* ❌ No retries with implicit state
* ❌ No execution without authority proof
* ❌ No workflow without explanation reference

Every workflow must be:

* explicit
* deterministic
* authority-validated
* explanation-anchored
* replayable
* fail-closed

---

## REQUIRED STRUCTURE

```
/orchestrator/
  schema/
    workflow.schema.json
    workflow-step.schema.json
    job-record.schema.json
  engine/
    workflow_registry.py      # immutable workflows
    dependency_resolver.py    # DAG validation
    job_executor.py           # deterministic execution
    replay_engine.py          # full rehydration
  api/
    orchestrator_api.py
  cli/
    run_workflow.py
    replay_workflow.py
  README.md
```

---

## WORKFLOW REQUIREMENTS

### Workflow Definition (Immutable)

Each workflow MUST define:

* workflow_id (UUID)
* version (semver)
* allowed_triggers (manual | alert | validator)
* required_authority (NONE | HUMAN | ROLE)
* required_explanation_type (SEE bundle type)
* steps[] (ordered, typed)
* failure_policy (STOP | ROLLBACK | RECORD_ONLY)

No optional fields.

---

## WORKFLOW STEP REQUIREMENTS

Each step MUST include:

* step_id (UUID)
* step_type (ALERT_DELIVERY | IR_EXECUTION | VALIDATION | REPORT_GEN)
* input_refs (explicit data dependencies)
* output_refs
* authority_required (NONE | HUMAN | ROLE)
* explanation_required (boolean)
* deterministic_timeout (seconds)

No step may execute implicitly.

---

## EXECUTION RULES

* Execution is **pull-based**, never push
* Each step produces a **job record**
* Job records are immutable facts
* Failures are explicit and terminal unless workflow defines rollback
* Rollback steps MUST be explicitly defined and signed
* No dynamic branching at runtime

---

## REPLAY & REHYDRATION

* Entire workflows must be replayable from:

  * Audit Ledger
  * Job records
  * Explanation bundles
  * Authority actions
* Replay must produce:

  * identical job order
  * identical outputs
  * identical hashes

---

## REQUIRED INTEGRATIONS

Orchestrator MUST integrate with:

* Audit Ledger (every job start/finish/failure)
* System Explanation Engine (pre-execution checks)
* Human Authority Framework (execution permission)
* Incident Response Engine (execution handoff only)
* Global Validator (workflow replay & assurance)

---

## PASS / FAIL

PASS only if:

* No workflow runs without explanation + authority (if required)
* Same workflow input → same execution graph
* Validator can replay entire workflow deterministically
* No background execution exists
* No implicit retries or scheduling

FAIL if:

* Any step executes without job record
* Any workflow bypasses authority
* Any nondeterminism exists
* Any hidden state exists

---

## OUTPUT EXPECTATION

* Production-grade Orchestrator
* Frozen schemas
* Deterministic DAG execution
* Authority-bound workflows
* Replay & rehydration support
* Ready for **Phase H — Network Scanner & Topology**

Do **not** build scanners yet.
Do **not** build UI triggers.
Do **not** add cron.

Build **Orchestrator & Workflow Engine only**.

****promot end****


****Promot Start****

You are continuing **RansomEye — Military-Grade Enterprise Cyber Defense Platform**.
All prior subsystems are **authoritative, frozen, validated, replayable**.

This is **PHASE H — Network Scanner & Topology Engine (Deterministic Discovery, Non-Intrusive)**.

This phase builds **network discovery and topology intelligence** only.
It does **NOT** exploit, **NOT** remediate, **NOT** enforce, and **NOT** modify hosts.

---

## OBJECTIVE

Build a **Network Scanner & Topology Engine** that:

* Discovers network assets (active + passive)
* Builds **immutable topology maps**
* Performs **offline CVE matching**
* Produces **facts only**, not actions
* Operates safely in enterprise & regulated environments

---

## ABSOLUTE CONSTRAINTS (NON-NEGOTIABLE)

* ❌ No exploitation
* ❌ No credential brute-force
* ❌ No lateral movement
* ❌ No remediation or blocking
* ❌ No auto-scheduling
* ❌ No background scanning
* ❌ No ML inference during scan
* ❌ No network mutation

Scanning is **observation**, not attack.

---

## REQUIRED STRUCTURE

```
/network-scanner/
  schema/
    asset.schema.json
    service.schema.json
    topology-edge.schema.json
    cve-match.schema.json
  engine/
    active_scanner.py        # nmap-based, bounded
    passive_discoverer.py    # DPI / flow-based input
    topology_builder.py      # immutable graph
    cve_matcher.py           # offline CVE correlation
  data/
    cve_db/                  # offline NVD snapshot
  api/
    scanner_api.py
  cli/
    scan_network.py
    build_topology.py
  README.md
```

---

## DISCOVERY REQUIREMENTS

### Active Scanning (Bounded)

* Uses **nmap only**
* Explicit scan scope (CIDR, interface)
* Explicit port list (no full sweep by default)
* Rate-limited
* Produces:

  * assets
  * open services
  * banners
* Scan execution must be **explicitly triggered**

### Passive Discovery

* Consumes:

  * DPI Probe outputs
  * flow metadata
* No packet crafting
* No injection
* Read-only ingestion

---

## TOPOLOGY REQUIREMENTS

* Topology is a **fact graph**
* Nodes:

  * hosts
  * network devices
  * services
* Edges:

  * communicates_with
  * hosts_service
  * routes_through
* All edges are:

  * directed
  * timestamped
  * immutable

---

## CVE MATCHING REQUIREMENTS

* Uses **offline NVD snapshot**
* Banner/service-based matching only
* No exploitability scoring
* Produces:

  * possible_cve_id
  * match_reason
  * confidence (LOW | MEDIUM | HIGH)
* Deterministic matching rules only

---

## REQUIRED INTEGRATIONS

Network Scanner MUST integrate with:

* Audit Ledger (scan start/end, scope, results)
* Threat Graph Engine (entity + edges)
* KillChain & Forensics (evidence references)
* Global Validator (replayability)

---

## PASS / FAIL

PASS only if:

* Scans are explicit and bounded
* Same scan → same results
* No network mutation occurs
* Topology can be rebuilt deterministically
* CVE matching is offline and explainable
* Validator can replay discovery

FAIL if:

* Any implicit scanning exists
* Any exploit-like behavior exists
* Any hidden scope expansion
* Any nondeterminism

---

## OUTPUT EXPECTATION

* Production-grade Network Scanner & Topology Engine
* Frozen schemas
* Deterministic discovery
* Offline CVE matching
* Immutable topology graphs
* Ready for **Phase I — Deception Framework**

Do **not** build deception yet.
Do **not** add remediation.
Do **not** add schedulers.

Build **Network Scanner & Topology Engine only**.

****Promot end****


****Promot Start****

You are continuing **RansomEye — Military-Grade Enterprise Cyber Defense Platform**.
All previous subsystems are **authoritative, frozen, deterministic, validator-verifiable**.

This is **PHASE I — Deception Framework (Active Defense, Non-Destructive)**.

This phase introduces **controlled deception** to **observe attacker behavior**, not to block, exploit, or retaliate.

---

## OBJECTIVE

Build a **Deception Framework** that:

* Deploys **decoy assets** (hosts, services, credentials, files)
* Attracts attacker interaction
* Generates **high-confidence signals**
* Produces **evidence-grade telemetry**
* Never interferes with production assets

Deception is **observation with intent**, not enforcement.

---

## ABSOLUTE CONSTRAINTS (NON-NEGOTIABLE)

* ❌ No counter-attacks
* ❌ No malware execution
* ❌ No real credential exposure
* ❌ No production host modification
* ❌ No automatic blocking
* ❌ No retaliation logic
* ❌ No background autonomy
* ❌ No dynamic learning or ML here

Everything is **explicit, deterministic, reversible**.

---

## REQUIRED STRUCTURE

```
/deception/
  schema/
    decoy.schema.json
    interaction.schema.json
    deployment.schema.json
  engine/
    decoy_registry.py        # Immutable decoy definitions
    deployment_engine.py     # Explicit deployment only
    interaction_collector.py # Interaction capture
    signal_builder.py        # High-confidence signals
  integrations/
    linux_agent_hooks.py
    network_scanner_hooks.py
  api/
    deception_api.py
  cli/
    deploy_decoy.py
    collect_interactions.py
  README.md
```

---

## DECOY TYPES (MANDATORY)

Must support **all** below, each as **data-defined**, not code:

1. **Host Decoys**

   * Fake Linux/Windows hosts
   * Never real production IPs

2. **Service Decoys**

   * Fake SSH / SMB / HTTP banners
   * Banner-only, no real backend

3. **Credential Decoys**

   * Honey credentials
   * Cryptographically tagged
   * Never valid in real systems

4. **File / Artifact Decoys**

   * Fake configs, keys, documents
   * Read-only access

---

## INTERACTION CAPTURE

Every interaction must record:

* Decoy ID
* Interaction type (auth_attempt, scan, access, command)
* Source (IP, host, process)
* Timestamp
* Evidence reference
* Confidence level (HIGH by default)

No interaction is dropped.
No aggregation at capture time.

---

## SIGNAL REQUIREMENTS

Signals produced by deception must be:

* **High confidence by design**
* Deterministic
* Explicitly explainable
* Chain-of-custody protected

Signals flow into:

* KillChain & Forensics
* Threat Graph
* Risk Index
* Alert Engine
* System Explanation Engine (SEE)

---

## REQUIRED INTEGRATIONS

Deception Framework MUST integrate with:

* Audit Ledger (deployment, interaction, teardown)
* Network Scanner (topology-aware placement)
* Linux Agent (host-level decoys)
* Threat Graph (entity + edge creation)
* KillChain & Forensics (evidence)
* Global Validator (replayability)

---

## PASS / FAIL

PASS only if:

* Decoys are isolated from production
* No real credentials are exposed
* Same deployment → same behavior
* Interactions are immutable facts
* Signals are deterministic and explainable
* Validator can replay interactions

FAIL if:

* Any real asset is touched
* Any exploit logic exists
* Any automatic retaliation exists
* Any nondeterminism appears

---

## OUTPUT EXPECTATION

* Production-grade **Deception Framework**
* Frozen schemas
* Explicit deployment
* Evidence-grade interaction capture
* High-confidence signals
* Ready for **Phase J — Threat Intel Feed & IOC Engine**

Do **not** build Threat Intel yet.
Do **not** add blocking or remediation.
Do **not** add ML.

Build **Deception Framework only**.

****Promot end****


Promot Start*

You are continuing RansomEye v1.0 – Enterprise & Military-Grade Build.

WORK UNIT: Core Installer Corrections (Blocking Fixes)

STRICT CONTEXT (DO NOT VIOLATE)

Core code is frozen

Installer must NOT modify Core logic

❌ No runtime fixes inside installer

❌ No new features

❌ No schema or contract changes

This task is installer-only corrections.

REQUIRED FIXES (ALL MANDATORY)
1. Credential Correction (CRITICAL)

Across the installer:

Username must be exactly: gagan

Password must be exactly: gagan

Fix all occurrences including:

env file generation

DB config

health checks

README examples

No variants. No hashes. No doubles.

2. Remove Core Runtime Modification

Revert any Core code changes introduced during installer creation

Installer must:

Copy pre-built Core artifacts

Start Core as-is

If Core startup requires uvicorn:

Installer must call it

NOT modify Core code

3. Re-run Installer Validation

Install on clean system

Start Core

Health check must pass

Uninstall must fully clean system

OUTPUT EXPECTATION

Return:

Confirmation of credential correction

Confirmation no Core code was modified

Confirmation installer works end-to-end

Do NOT summarize code.

Begin immediately.

Promot end*


****Promot Start****

You are continuing **RansomEye — Military-Grade Enterprise Cyber Defense Platform**.
All prior subsystems are **authoritative, frozen, deterministic, validator-verifiable**.

This is **PHASE J — Threat Intelligence Feed & IOC Engine (Deterministic, Offline-First)**.

This phase establishes **trusted external and internal intelligence ingestion** without creating enforcement, bias, or hidden logic.

---

## OBJECTIVE

Build a **Threat Intelligence & IOC Engine** that:

* Ingests **external and internal intelligence feeds**
* Normalizes indicators into **immutable facts**
* Correlates IOCs with **existing evidence**
* Feeds **KillChain, Threat Graph, Risk Index, Alert Engine**
* Remains **offline-capable and deterministic**

Threat intel **informs**, it never decides.

---

## ABSOLUTE CONSTRAINTS (NON-NEGOTIABLE)

* ❌ No automatic blocking
* ❌ No enrichment mutation of incidents
* ❌ No trust escalation
* ❌ No ML or heuristics
* ❌ No live internet dependency at runtime
* ❌ No prioritization logic
* ❌ No scoring here

IOC ingestion ≠ threat judgment.

---

## REQUIRED STRUCTURE

```
/threat-intel/
  schema/
    ioc.schema.json
    intel-source.schema.json
    correlation.schema.json
  engine/
    feed_ingestor.py        # Offline snapshot ingestion
    normalizer.py           # Canonical IOC normalization
    deduplicator.py         # Hash-based IOC deduplication
    correlator.py           # Evidence ↔ IOC correlation
  storage/
    intel_store.py          # Immutable IOC storage
  api/
    intel_api.py
  cli/
    ingest_feed.py
    correlate_iocs.py
  README.md
```

---

## SUPPORTED IOC TYPES (MANDATORY)

Must support **explicit enumeration**:

* IP address
* Domain
* URL
* File hash (MD5, SHA1, SHA256)
* Email address
* Registry key
* Process name
* Mutex
* User agent

No free-form indicators.

---

## INTEL SOURCES

Must support **signed, versioned snapshots**:

* Public feeds (MISP, NVD-derived, CERT, ISAC)
* Internal sources:

  * Deception Framework interactions
  * Incident artifacts
  * Forensics evidence
* Manual analyst-submitted feeds (signed)

Runtime operation must be **offline-only**.

---

## CORRELATION RULES

IOC correlation must be:

* Deterministic
* Evidence-based
* Non-mutating

Correlation outputs are **facts**, not decisions.

Examples:

* IOC hash matches forensic artifact hash
* Domain IOC matches network scanner service
* IP IOC matches alert source

---

## REQUIRED INTEGRATIONS

Threat Intel Engine MUST integrate with:

* Audit Ledger (ingestion, correlation)
* KillChain & Forensics (evidence correlation)
* Threat Graph (entity + edge creation)
* Risk Index (signal input only)
* Alert Engine (context only)
* System Explanation Engine (SEE)
* Global Validator (replayability)

---

## PASS / FAIL

PASS only if:

* IOC storage is immutable
* Feeds are signed and versioned
* Correlation is deterministic
* Runtime has no network access
* Validator can replay correlations
* No decision logic exists

FAIL if:

* Any IOC causes automatic action
* Any enrichment mutates facts
* Any heuristic or ML appears
* Any runtime internet dependency exists

---

## OUTPUT EXPECTATION

* Production-grade **Threat Intelligence & IOC Engine**
* Frozen schemas
* Deterministic ingestion & correlation
* Offline-first operation
* Evidence-anchored intelligence

After completion, system proceeds to
**PHASE K — HNMP Engine (Host / Network / Malware / Process)**.

****Promot end****



****Promot Start****

You are continuing **RansomEye — Military-Grade Enterprise Cyber Defense Platform**.
All completed subsystems are **frozen, authoritative, deterministic, replayable, validator-verifiable**.

This is **PHASE K — HNMP Engine (Host / Network / Malware / Process Intelligence Core)**.

This phase establishes the **lowest-level, evidence-grade behavioral intelligence layer** that all higher reasoning depends on.

---

## OBJECTIVE

Build the **HNMP Engine** that provides **ground-truth behavioral facts** across:

* **Host** (user, privilege, filesystem, memory)
* **Network** (flows, connections, DNS, DPI outputs)
* **Malware** (artifacts, hashes, behaviors)
* **Process** (execution, parent/child, injections)

HNMP produces **facts only**, never conclusions.

---

## ABSOLUTE CONSTRAINTS (NON-NEGOTIABLE)

* ❌ No scoring
* ❌ No ML
* ❌ No heuristics
* ❌ No enforcement
* ❌ No alerting
* ❌ No aggregation logic
* ❌ No implicit inference
* ❌ No mutation of upstream data

HNMP is **observation and normalization only**.

---

## REQUIRED STRUCTURE

```
/hnmp/
  schema/
    host-event.schema.json
    network-event.schema.json
    process-event.schema.json
    malware-event.schema.json
    hnmp-correlation.schema.json
  engine/
    host_normalizer.py
    network_normalizer.py
    process_normalizer.py
    malware_normalizer.py
    correlator.py
  storage/
    hnmp_store.py
  api/
    hnmp_api.py
  cli/
    ingest_hnmp.py
    correlate_hnmp.py
  README.md
```

---

## DATA SOURCES (MANDATORY)

HNMP must ingest **only signed, validated inputs** from:

* Linux Agent (eBPF, procfs, audit)
* Windows Agent (ETW, registry, process telemetry)
* DPI Probe (flows, L7 metadata)
* Forensics Engine (artifacts, memory dumps)
* Deception Framework (interactions)
* Threat Intel Engine (IOC matches)

No raw packet capture storage.

---

## EVENT TYPES (MANDATORY)

### Host Events

* User login/logout
* Privilege escalation
* File creation/modification
* Registry change (Windows)
* Credential access attempt

### Network Events

* Flow start/end
* DNS query/response
* Protocol detection
* TLS metadata (no payload)

### Process Events

* Process start/exit
* Parent/child linkage
* Injection attempt
* Suspicious flags (explicit, no inference)

### Malware Events

* Hash observation
* Execution attempt
* Artifact discovery
* Sandbox verdict reference (no scoring)

---

## CORRELATION RULES

Correlation is **strictly factual**:

* Process ↔ network flow
* Process ↔ file artifact
* File artifact ↔ malware hash
* User ↔ process
* Host ↔ network identity

No campaign inference here
(No timelines, no killchain logic)

---

## REQUIRED INTEGRATIONS

HNMP Engine MUST integrate with:

* Audit Ledger (all ingestion & correlation)
* KillChain & Forensics (input + downstream)
* Threat Graph (entity + edge generation)
* Alert Engine (context input only)
* Risk Index (signal input only)
* System Explanation Engine (fact substrate)
* Global Validator (full replay)

---

## DETERMINISM RULES

* Same inputs → same outputs
* Canonical timestamps
* Explicit field ordering
* No time windows
* No implicit joins
* No default assumptions

---

## PASS / FAIL

PASS only if:

* All schemas have **zero optional fields**
* Storage is immutable
* Correlation produces facts only
* No decision logic exists
* Validator can fully reconstruct HNMP state
* All events are audit-anchored

FAIL if:

* Any scoring exists
* Any ML appears
* Any inference sneaks in
* Any enforcement happens
* Any event mutates upstream data

---

## OUTPUT EXPECTATION

* **HNMP Engine** as the factual backbone of RansomEye
* Immutable behavioral substrate
* Deterministic, replayable intelligence
* Court-defensible evidence layer

After completion, system proceeds to:

**PHASE L — DPI Probe Advanced Engine (10G / eBPF / AF_PACKET Fast-Path)**

****Promot end****



****Promot Start****

You are continuing **RansomEye — Military-Grade Enterprise Cyber Defense Platform**.
All previously completed subsystems are **frozen, authoritative, deterministic, replayable, validator-verifiable**.

This is **PHASE L — DPI Probe Advanced Engine (10G / eBPF / AF_PACKET Fast-Path)**.

This phase upgrades the DPI Probe from a **functional sensor** to a **carrier-grade, high-performance network intelligence engine** capable of sustaining **10G+ traffic** with **provable performance and privacy guarantees**.

---

## OBJECTIVE

Build the **Advanced DPI Probe Engine** that provides:

* Line-rate (10G+) traffic observation
* Flow-level behavioral ML (local, bounded, explainable)
* Asset classification (device / role inference)
* Privacy-preserving redaction modes
* Deterministic chunked upload with cryptographic enforcement
* eBPF / AF_PACKET fast paths
* Full integration with HNMP, Threat Graph, KillChain, Risk Index

---

## ABSOLUTE CONSTRAINTS (NON-NEGOTIABLE)

* ❌ No payload storage
* ❌ No packet replay
* ❌ No MITM
* ❌ No active traffic modification
* ❌ No credential extraction
* ❌ No decryption of encrypted payloads
* ❌ No cloud dependency
* ❌ No kernel patching

This is **observation only**, at scale.

---

## REQUIRED STRUCTURE

```
/dpi-advanced/
  schema/
    flow-record.schema.json
    asset-profile.schema.json
    upload-chunk.schema.json
    privacy-policy.schema.json
  fastpath/
    af_packet_capture.c
    ebpf_flow_tracker.c
  engine/
    flow_assembler.py
    behavior_model.py
    asset_classifier.py
    privacy_redactor.py
    uploader.py
  performance/
    throughput_benchmark.py
    latency_benchmark.py
    cpu_profile.md
  api/
    dpi_api.py
  cli/
    run_probe.py
    benchmark_probe.py
  README.md
```

---

## PERFORMANCE TARGETS (MANDATORY)

You must **prove**, not claim:

* **10 Gbps sustained throughput**
* **<5% CPU per 1 Gbps**
* **Zero packet drops at 64-byte packets (AF_PACKET)**
* **Bounded memory (ring buffers only)**
* **Backpressure under congestion (no OOM)**

Benchmarks must be reproducible.

---

## FAST-PATH IMPLEMENTATION

### AF_PACKET

* PACKET_MMAP (TPACKET_V3)
* RX ring only
* Zero-copy
* CPU affinity pinning

### eBPF

* Flow tuple extraction
* L7 protocol fingerprinting (metadata only)
* Per-flow counters
* No loops
* Verifier-safe

---

## FLOW-LEVEL ML (STRICTLY LOCAL)

Allowed:

* Sequence models on **flow metadata only**
* Packet size, timing, flags, protocol hints

Forbidden:

* Payload inspection
* Cross-host learning
* Cloud inference

Outputs:

* **Behavioral profile IDs**
* Confidence bands
* Feature vectors only (stored in HNMP-compatible form)

---

## ASSET CLASSIFICATION

Infer:

* Device type (server, workstation, IoT, network device)
* Role (DB, DC, proxy, printer)

Based on:

* Port behavior
* Protocol mix
* Flow directionality

Must be:

* Deterministic
* Explainable
* Replayable

---

## PRIVACY MODES (MANDATORY)

Implement **policy-driven redaction**:

* **STRICT**

  * Hash IPs
  * Truncate ports
  * No DNS labels
* **BALANCED**

  * Partial IP retention
  * Domain second-level only
* **FORENSIC**

  * Full metadata (no payload)

Redaction happens **before storage and upload**.

---

## UPLOAD PIPELINE

* Chunked uploads
* Per-chunk SHA256
* Signed chunk manifests
* Backpressure-aware
* Resume-safe
* Offline buffering (bounded)

No silent drops.

---

## REQUIRED INTEGRATIONS

Must integrate with:

* HNMP Engine (flow → network facts)
* Threat Graph (asset & flow edges)
* KillChain & Forensics (evidence references)
* Risk Index (signals only)
* Alert Engine (context only)
* Audit Ledger (all actions)
* Global Validator (full replay)

---

## DETERMINISM RULES

* Same packets → same flows
* Same flows → same features
* Same policies → same redaction
* Same input → same output hashes

No entropy.

---

## PASS / FAIL

PASS only if:

* 10G benchmark is reproducible
* CPU & memory profiles documented
* Privacy redaction provably enforced
* Upload integrity is cryptographically verifiable
* No payload is ever persisted
* Validator can replay outputs

FAIL if:

* Any payload leaks
* Any inference is implicit
* Any performance claim is unproven
* Any privacy mode is bypassable

---

## OUTPUT EXPECTATION

* **Carrier-grade DPI engine**
* Privacy-first by design
* Deterministic, replayable, explainable
* Suitable for regulated and military environments

After completion, system proceeds to:

**PHASE M — Advanced UBA (Insider Threat & Identity-Behavior Fusion)**

****Promot end****

****Promot Start****

### PHASE M1 — Advanced UBA Core (Identity–Behavior Ground Truth Layer)

**Objective (NON-NEGOTIABLE)**
Build the **User Behavior Analytics Core** as a **purely factual, evidence-grade subsystem** that establishes **per-identity behavioral ground truth** without scoring, prediction, ML black boxes, or enforcement.

This phase is the **foundation** for insider threat detection and must be **deterministic, replayable, and regulator-safe**.

---

## HARD CONSTRAINTS (ABSOLUTE)

1. **NO hardcoded IPs, paths, users, domains, or interfaces**

   * All paths, endpoints, and identifiers come from environment variables or manifests.
2. **NO ML models in M1**

   * This phase is **ground truth only**, not inference.
3. **NO scoring, alerts, risk, or conclusions**

   * Facts only.
4. **NO optional fields in schemas**

   * Zero ambiguity.
5. **NO background schedulers**

   * Explicit ingestion only.
6. **Every action must emit an Audit Ledger entry**
7. **Replayable from zero using Global Validator**

---

## SUBSYSTEM NAME (STRICT)

**`uba-core`**
(No “phase”, no numbers in names)

---

## DELIVERABLES TO BUILD

### 1. Schemas (Frozen, Zero Optional Fields)

Create under `/uba-core/schema/`

1. `identity.schema.json`

   * user_id
   * identity_type (human / service / machine)
   * auth_domain
   * creation_timestamp
   * source_system
   * canonical_identity_hash

2. `behavior-event.schema.json`

   * event_id
   * identity_id
   * event_type (login, file_access, process_start, network_access, privilege_use, policy_override)
   * source_component (linux-agent, windows-agent, dpi, hnmp, ir, deception)
   * resource_id
   * action
   * timestamp
   * host_id
   * evidence_ref

3. `identity-baseline.schema.json`

   * identity_id
   * baseline_window_start
   * baseline_window_end
   * observed_event_types
   * observed_hosts
   * observed_time_buckets
   * observed_privileges
   * baseline_hash

---

### 2. Engine Components

Under `/uba-core/engine/`

1. `identity_resolver.py`

   * Deterministically map events → canonical identity
   * No heuristics
   * Explicit precedence rules only

2. `behavior_normalizer.py`

   * Canonicalize timestamps
   * Canonicalize event types
   * Canonicalize identity references

3. `baseline_builder.py`

   * Builds **historical baselines**
   * Window is explicit (env-configured)
   * Output is immutable
   * No scoring, only aggregation

4. `baseline_hasher.py`

   * Deterministic SHA256 hash of baseline content
   * Used for drift comparison later (Phase M2)

---

### 3. Storage (Immutable)

Under `/uba-core/storage/`

* `uba_store.py`

  * Append-only storage
  * No updates
  * No deletes
  * Baselines are versioned by time window

---

### 4. API Layer

Under `/uba-core/api/uba_api.py`

Endpoints (read/write split):

* `ingest_behavior_event()`
* `build_identity_baseline()`
* `get_identity_baseline()`

All API calls:

* Require validated schema input
* Emit audit ledger entries
* Fail-closed

---

### 5. CLI Tools (Deterministic)

Under `/uba-core/cli/`

* `ingest_behavior.py`
* `build_baseline.py`
* `export_baseline.py`

---

### 6. Audit Ledger Integration (MANDATORY)

Every one of the following emits a ledger entry:

* Identity creation
* Behavior event ingestion
* Baseline build
* Baseline export

Ledger action types must be **new and explicit**:

* `UBA_IDENTITY_CREATED`
* `UBA_BEHAVIOR_INGESTED`
* `UBA_BASELINE_BUILT`
* `UBA_BASELINE_EXPORTED`

---

### 7. Global Validator Compatibility

Validator must be able to:

* Rebuild all baselines from raw events
* Verify baseline hashes
* Detect missing or altered events
* Confirm no inference occurred

---

### 8. Documentation

Create `/uba-core/README.md` with:

* Threat model
* What UBA Core **does NOT do**
* Determinism guarantees
* Replay guarantees
* Regulatory posture (SOX, SOC2, ISO, Insider Threat compliance)
* Clear statement: **“UBA Core establishes facts, not intent.”**

---

## EXPLICITLY FORBIDDEN

* ❌ ML
* ❌ Risk scoring
* ❌ Alerts
* ❌ Anomaly labels
* ❌ “Suspicious” flags
* ❌ Implicit inference
* ❌ Background jobs
* ❌ Optional fields
* ❌ Human-readable free text reasoning

---

## SUCCESS CRITERIA (PASS / FAIL)

PASS only if:

* All schemas have **zero optional fields**
* All outputs are replayable
* No inference logic exists
* Baselines rebuild bit-for-bit identical
* Audit Ledger contains full chain
* Validator passes reconstruction

FAIL if:

* Any heuristic exists
* Any scoring exists
* Any path/IP/interface is hardcoded
* Any optional field exists

---

**NEXT PHASE (DO NOT BUILD YET):**
PHASE M2 — Behavioral Drift Detection (Deterministic Delta Layer)

****Promot end****


****Promot Start****

### PHASE M2 — Behavioral Drift Detection Engine (Deterministic Delta Layer)

**Objective (NON-NEGOTIABLE)**
Build the **Behavioral Drift Detection Engine** as a **purely deterministic delta-analysis layer** on top of **UBA Core baselines**.

This phase detects **behavioral change**, **not intent**, **not risk**, **not anomaly labels**.
It answers only one question:

> *“Has observed behavior deviated from its own historical baseline, and how?”*

Nothing more.

---

## HARD CONSTRAINTS (ABSOLUTE)

1. **NO ML, NO statistics, NO probabilistic models**
2. **NO risk scores, NO alerts, NO confidence labels**
3. **NO words like suspicious, malicious, abnormal**
4. **NO optional fields in schemas**
5. **NO background schedulers**
6. **NO hardcoded paths, IPs, users, domains**
7. **Every delta must be reconstructable bit-for-bit**
8. **Every action emits Audit Ledger entries**
9. **UBA Core remains read-only**

---

## SUBSYSTEM NAME (STRICT)

**`uba-drift`**

(No phase numbers in names, no shortcuts)

---

## ROLE IN ARCHITECTURE (IMPORTANT)

* **Consumes**:

  * UBA Core baselines
  * UBA behavior events

* **Produces**:

  * **Behavioral delta facts only**

* **Does NOT**:

  * Decide
  * Judge
  * Alert
  * Score
  * Predict
  * Enforce

This layer exists **solely to quantify change**.

---

## DELIVERABLES TO BUILD

---

## 1. Schemas (Frozen, Zero Optional Fields)

Create under `/uba-drift/schema/`

### 1. `behavior-delta.schema.json`

Fields (ALL REQUIRED):

* delta_id
* identity_id
* baseline_hash
* observation_window_start
* observation_window_end
* delta_type

  * NEW_EVENT_TYPE
  * NEW_HOST
  * NEW_TIME_BUCKET
  * NEW_PRIVILEGE
  * FREQUENCY_SHIFT
* baseline_value
* observed_value
* delta_magnitude
* first_seen_timestamp
* last_seen_timestamp

⚠️ **delta_magnitude is numeric but NOT a score**
It is a **count difference or presence delta**, nothing else.

---

### 2. `delta-summary.schema.json`

Fields (ALL REQUIRED):

* identity_id
* baseline_hash
* observation_window_start
* observation_window_end
* total_deltas
* delta_types_present
* summary_hash

---

## 2. Engine Components

Under `/uba-drift/engine/`

### 1. `delta_comparator.py`

* Compares:

  * Baseline facts vs observation window facts
* Produces:

  * Explicit deltas
* Rules:

  * Explicit comparison logic
  * No heuristics
  * No thresholds unless environment-defined

---

### 2. `window_builder.py`

* Builds explicit observation windows
* Window size comes from env vars
* No implicit rolling windows

---

### 3. `delta_hasher.py`

* Deterministic SHA256 over delta content
* Enables validator replay

---

### 4. `delta_classifier.py`

⚠️ Misleading name clarified:

* **Classifies delta TYPE only**
* NOT severity
* NOT intent
* NOT threat

---

## 3. Storage (Immutable)

Under `/uba-drift/storage/`

### `delta_store.py`

* Append-only
* No updates
* No deletes
* Deltas versioned by window

---

## 4. API Layer

Under `/uba-drift/api/drift_api.py`

Endpoints:

* `compute_behavior_deltas()`
* `get_behavior_deltas(identity_id)`
* `get_delta_summary(identity_id)`

Rules:

* All inputs schema-validated
* All outputs immutable
* All calls ledger-anchored

---

## 5. CLI Tools

Under `/uba-drift/cli/`

* `compute_deltas.py`
* `export_deltas.py`
* `export_delta_summary.py`

---

## 6. Audit Ledger Integration (MANDATORY)

New ledger action types:

* `UBA_DELTA_COMPUTED`
* `UBA_DELTA_EXPORTED`
* `UBA_DELTA_SUMMARY_BUILT`

Every delta computation is **auditable and replayable**.

---

## 7. Global Validator Compatibility

Validator MUST be able to:

* Recompute deltas from:

  * Raw behavior events
  * Baselines
* Verify:

  * Delta hashes
  * Summary hashes
* Detect:

  * Missing events
  * Altered baselines
  * Tampering

---

## 8. Documentation

Create `/uba-drift/README.md` with:

* Explicit statement:

  > “Behavioral drift ≠ malicious behavior”
* What this subsystem **does NOT do**
* Determinism guarantees
* How regulators should read delta data
* How later layers MAY consume (Risk, IR, Policy)

---

## EXPLICITLY FORBIDDEN

* ❌ Machine learning
* ❌ Z-scores
* ❌ Percentiles
* ❌ “Anomaly”
* ❌ “Outlier”
* ❌ “Suspicious”
* ❌ Auto-thresholding
* ❌ Background execution
* ❌ Human-readable judgment text

---

## SUCCESS CRITERIA (PASS / FAIL)

### PASS only if:

* Deltas rebuild identically from raw facts
* No inference or scoring exists
* All schemas have zero optional fields
* Baselines remain untouched
* Audit ledger is complete
* Validator passes replay

### FAIL if:

* Any threshold is implicit
* Any scoring is added
* Any heuristic is used
* Any hardcoded value exists

---

## NEXT PHASE (DO NOT BUILD YET)

**PHASE M3 — UBA Signal Interpretation (Risk-Consuming, Not Risk-Producing)**
This is where **other engines** may consume drift — not here.

****Promot end****


****Promot Start****

### PHASE M3 — UBA Signal Interpretation Layer

**(Risk-Consuming, Authority-Bound, Explanation-Anchored)**

---

## OBJECTIVE (ABSOLUTE)

Build **UBA Signal Interpretation** as a **consumer-only layer** that interprets **UBA Drift deltas** in **context**, without producing *new facts*, *new risk*, or *new authority*.

This layer answers **only**:

> “How should downstream systems *understand* behavioral drift when combined with other verified facts?”

It **does not**:

* Generate risk scores
* Create alerts
* Escalate incidents
* Modify baselines
* Infer intent

---

## CORE ARCHITECTURAL POSITION

```
UBA Core (facts)
   ↓
UBA Drift (change deltas)
   ↓
UBA Signal Interpretation  ← YOU ARE HERE
   ↓
Risk Index / Policy / IR / SEE (consumers only)
```

This layer **never becomes a source of truth**.
It is a **lens**, not an authority.

---

## HARD CONSTRAINTS (NON-NEGOTIABLE)

1. **Consumes deltas, never produces facts**
2. **No scoring, no thresholds, no probabilities**
3. **No ML, no statistics**
4. **No autonomous decisions**
5. **No alerts, no enforcement**
6. **No optional schema fields**
7. **Environment-driven only**
8. **Audit-anchored**
9. **Explanation-first (SEE compatible)**
10. **Human authority respected (HAF compatible)**

---

## SUBSYSTEM NAME (STRICT)

**`uba-signal`**

(No phase numbers. No shortcuts.)

---

## DELIVERABLES TO BUILD

---

## 1. Schemas (Frozen, Zero Optional Fields)

Create under `/uba-signal/schema/`

### 1. `interpreted-signal.schema.json`

**ALL FIELDS REQUIRED**

* signal_id
* identity_id
* delta_ids (array)
* interpretation_type

  * CONTEXTUAL_SHIFT
  * ROLE_EXPANSION
  * ACCESS_SURFACE_CHANGE
  * TEMPORAL_BEHAVIOR_CHANGE
* contextual_inputs

  * references only (killchain_id, graph_id, incident_id, etc.)
* explanation_bundle_id
* authority_required (boolean)
* downstream_consumers (array)
* signal_hash
* created_timestamp

⚠️ **interpretation_type is descriptive, not evaluative**

---

### 2. `signal-summary.schema.json`

* identity_id
* observation_window
* signal_count
* interpretation_types_present
* summary_hash

---

## 2. Engine Components

Under `/uba-signal/engine/`

### 1. `signal_interpreter.py`

* Consumes:

  * UBA Drift deltas
  * Context references (read-only)
* Produces:

  * Interpreted signals
* Rules:

  * Explicit mappings only
  * No implicit logic
  * No thresholds unless env-defined

---

### 2. `context_resolver.py`

* Pulls **read-only** context from:

  * KillChain
  * Threat Graph
  * Incident Store
* Never infers
* Never mutates

---

### 3. `signal_hasher.py`

* Deterministic SHA256 over canonical JSON

---

## 3. Storage (Immutable)

Under `/uba-signal/storage/`

### `signal_store.py`

* Append-only
* Versioned by observation window
* No updates, no deletes

---

## 4. API Layer

Under `/uba-signal/api/signal_api.py`

Endpoints:

* `interpret_deltas()`
* `get_signals(identity_id)`
* `get_signal_summary(identity_id)`

All calls:

* Schema-validated
* Ledger-anchored
* Deterministic

---

## 5. CLI Tools

Under `/uba-signal/cli/`

* `interpret_signals.py`
* `export_signals.py`
* `export_signal_summary.py`

---

## 6. Audit Ledger Integration (MANDATORY)

New ledger actions:

* `UBA_SIGNAL_INTERPRETED`
* `UBA_SIGNAL_EXPORTED`
* `UBA_SIGNAL_SUMMARY_BUILT`

No silent interpretations.

---

## 7. SEE & HAF INTEGRATION (MANDATORY)

### SEE (System Explanation Engine)

* Every interpreted signal **must reference** an explanation bundle
* Explanation must trace:

  * Drift → Context → Interpretation

### HAF (Human Authority Framework)

* If `authority_required = true`

  * Downstream execution **MUST require human signature**
  * This layer **does not invoke authority itself**

---

## 8. GLOBAL VALIDATOR REQUIREMENTS

Validator must be able to:

* Rebuild signals from:

  * Drift deltas
  * Context references
* Verify:

  * Signal hashes
  * Explanation references
* Detect:

  * Missing deltas
  * Altered interpretation logic
  * Unauthorized execution attempts

---

## 9. DOCUMENTATION

Create `/uba-signal/README.md` with:

* Clear statement:

  > “Signals describe context, not danger.”
* Explicit separation from:

  * UBA Drift
  * Risk Index
  * Policy Engine
* Regulatory interpretation guidance
* Determinism guarantees

---

## EXPLICITLY FORBIDDEN

* ❌ Risk scoring
* ❌ Severity labels
* ❌ Alert generation
* ❌ Automatic escalation
* ❌ “Suspicious” / “Threatening” language
* ❌ Background execution
* ❌ ML or heuristics
* ❌ Threshold tuning logic

---

## SUCCESS CRITERIA (PASS / FAIL)

### PASS only if:

* Signals rebuild bit-for-bit
* No scoring exists
* All schemas have zero optional fields
* No baseline or drift mutation
* Ledger is complete
* Validator replay passes

### FAIL if:

* Any implicit inference exists
* Any alert logic appears
* Any authority bypass exists
* Any scoring appears

---

## NEXT PHASE (DO NOT BUILD YET)

**PHASE M4 — UBA Risk Consumption (Enterprise Risk Index Integration)**
Risk consumes signals — signals never produce risk.

****Promot end****


****Promot Start****

### PHASE M4 — UBA Risk Consumption

**(Enterprise Risk Index Integration — Signal-Consuming Only)**

---

## OBJECTIVE (ABSOLUTE)

Extend the **Enterprise Risk Index Engine** to **consume UBA Signals** as **contextual modifiers**, **never as risk producers**.

UBA **must never raise risk by itself**.
UBA **only explains why risk *already changed*** when correlated with other verified facts.

This phase answers **only**:

> “How does verified behavioral context *modulate* enterprise risk when other risk-producing systems already fired?”

---

## ARCHITECTURAL POSITION (DO NOT VIOLATE)

```
UBA Core        → facts
UBA Drift       → change
UBA Signal      → context
                     ↓
Enterprise Risk Index (THIS PHASE)
                     ↓
Policy / IR / Exec Reporting
```

UBA **does not generate risk**
UBA **does not trigger alerts**
UBA **does not escalate**

---

## HARD CONSTRAINTS (NON-NEGOTIABLE)

1. **UBA is a modifier, never a source**
2. **Risk Index remains the only risk authority**
3. **No new scores, no weights from UBA**
4. **UBA only adjusts confidence / explainability**
5. **All effects must be explanation-traceable**
6. **Deterministic, replayable**
7. **Environment-driven**
8. **Audit-ledger anchored**
9. **Validator-verifiable**
10. **Human authority preserved**

---

## CHANGES TO IMPLEMENT

### LOCATION

`/risk-index/`

---

## 1. Schema Extension (Frozen)

### Update `risk-score.schema.json`

Add **mandatory** fields:

* uba_signal_ids (array)
* uba_context_applied (boolean)
* risk_explanation_bundle_id
* context_modifiers (array of enums)

  * ROLE_EXPANSION_PRESENT
  * ACCESS_SURFACE_EXPANDED
  * TEMPORAL_SHIFT_PRESENT
  * CONTEXTUAL_SHIFT_PRESENT

⚠️ These are **descriptive**, not numeric.

No optional fields allowed.

---

## 2. Engine Changes

### Update `/engine/aggregator.py`

Add:

#### `apply_uba_context()`

Rules:

* Consumes **UBA Signals**
* Modifies:

  * explanation richness
  * confidence interpretation
* NEVER modifies:

  * base score calculation
  * decay math
  * normalization

If no UBA signals → no change.

---

### Update `/engine/normalizer.py`

* Ensure UBA context **cannot push score outside 0–100**
* Ensure **risk bands remain unchanged**

---

## 3. Explanation Integration (MANDATORY)

Every risk computation **must reference**:

* SEE explanation bundle that chains:

  ```
  Incident → KillChain → Graph → UBA Signal → Risk Index
  ```

No explanation → computation fails.

---

## 4. Audit Ledger Integration

New ledger events:

* `RISK_INDEX_COMPUTED_WITH_UBA_CONTEXT`
* `RISK_CONTEXT_APPLIED`

Ledger must record:

* Which UBA signals were consumed
* Which context modifiers applied
* Explanation bundle reference

---

## 5. API Changes

Update `/api/risk_api.py`

Expose:

* `get_risk_with_context(identity_id)`
* `get_risk_explanation(identity_id)`

Responses must include:

* base risk
* UBA context applied (true/false)
* explanation bundle ID

---

## 6. CLI Updates

Add:

* `compute_risk_with_uba.py`
* `export_risk_with_context.py`

---

## 7. Global Validator Updates

Validator must be able to:

* Recompute risk **with and without** UBA context
* Confirm:

  * Base score unchanged
  * Only context flags differ
* Verify explanation bundle integrity
* Detect unauthorized risk influence

---

## 8. DOCUMENTATION UPDATE

Update `/risk-index/README.md`

Add section:

### “UBA Integration Model”

Include explicit statement:

> “UBA does not increase risk.
> UBA explains *why* existing risk is interpreted the way it is.”

Include regulatory positioning:

* Insider threat ≠ malicious intent
* Behavioral drift ≠ threat
* Risk attribution remains multi-factor

---

## EXPLICITLY FORBIDDEN

* ❌ UBA-driven scoring
* ❌ UBA weight factors
* ❌ UBA-only risk increase
* ❌ Automatic escalation from UBA
* ❌ Behavioral intent inference
* ❌ ML involvement
* ❌ Threshold tuning

---

## PASS / FAIL CRITERIA

### PASS only if:

* Risk score identical with and without UBA
* Only explanation/context differs
* Validator replay succeeds
* No UBA influence without other risk signals
* Ledger is complete

### FAIL if:

* UBA alone changes risk
* Any scoring logic references UBA
* Any implicit severity exists
* Any authority bypass exists

---

## NEXT PHASE (DO NOT BUILD YET)

**PHASE M5 — UBA → Alert Interpretation (Human-Centric Alert Framing)**
UBA influences *how alerts are explained*, never when they are fired.

****Promot End****



****Promot Start*****

You are implementing the next **MANDATORY subsystem** for **RansomEye v1.0**.
You are not allowed to ask questions, simplify scope, or introduce optional behavior.
This is **military-grade, regulator-grade software**.
Follow architecture strictly. No shortcuts.

---

# PHASE M5 — UBA Alert Context Engine (Human-Centric, Non-Triggering)

## AUTHORITATIVE INTENT

This subsystem **does NOT create alerts**.
This subsystem **does NOT suppress alerts**.
This subsystem **does NOT escalate alerts**.
This subsystem **does NOT route alerts**.
This subsystem **does NOT score risk**.

**It ONLY explains alerts to humans using UBA context.**

UBA **frames understanding**, never authority.

---

## CORE PRINCIPLE (NON-NEGOTIABLE)

> **UBA may change how an alert is explained — never whether it exists.**

---

## REQUIRED SUBSYSTEM NAME

**`/uba-alert-context/`**

Do **NOT** name it:

* analyzer
* scorer
* evaluator
* enhancer
* intelligence
* inference

Correct name: **UBA Alert Context Engine**

---

## REQUIRED DELIVERABLES

### 1. Schema (Frozen, Zero Optional Fields)

Create schemas under:

```
/uba-alert-context/schema/
```

#### 1.1 `alert-context.schema.json`

**Purpose:** Human-facing contextual explanation attached to an alert

Required fields (ALL mandatory):

1. `alert_id` (UUID)
2. `context_block_id` (UUID)
3. `uba_signal_ids` (array of UUIDs)
4. `context_types` (array of enums)

   * CONTEXTUAL_SHIFT
   * ROLE_EXPANSION
   * ACCESS_SURFACE_CHANGE
   * TEMPORAL_BEHAVIOR_CHANGE
5. `human_readable_summary` (string, controlled vocabulary only)
6. `what_changed` (array of strings, factual)
7. `what_did_not_change` (array of strings, factual)
8. `interpretation_guidance` (enum)

   * INFORMATIONAL
   * CONTEXT_ONLY
   * REVIEW_RECOMMENDED
9. `explanation_bundle_id` (UUID, SEE mandatory)
10. `generated_at` (RFC3339 UTC)

**STRICT RULES**

* No judgment words (no suspicious, malicious, risky)
* No severity labels
* No probabilities
* No free prose outside controlled strings

---

### 2. Engine Implementation

Path:

```
/uba-alert-context/engine/
```

#### 2.1 `context_builder.py`

* Input:

  * Alert (read-only)
  * UBA Signals (read-only)
  * Explanation Bundle (SEE)
* Output:

  * Alert Context Block (immutable)

Rules:

* Deterministic
* Same inputs → same output
* Order-preserving
* No branching logic
* No ML
* No heuristics

#### 2.2 `context_hasher.py`

* Deterministic SHA256 hash of the context block
* Used for validator replay

---

### 3. Storage (Immutable)

Path:

```
/uba-alert-context/storage/
```

#### 3.1 `context_store.py`

* Append-only
* No updates
* No deletes
* Alert context blocks are immutable facts

---

### 4. API

Path:

```
/uba-alert-context/api/
```

#### 4.1 `alert_context_api.py`

Required endpoints (read/write strictly controlled):

* `build_context(alert_id)`
* `get_alert_context(alert_id)`
* `list_alert_contexts(incident_id)`

Rules:

* Read-only access to Alert Engine
* Read-only access to UBA Signal Store
* Write ONLY to context_store
* Emit audit ledger events:

  * `UBA_ALERT_CONTEXT_BUILT`
  * `UBA_ALERT_CONTEXT_RETRIEVED`

---

### 5. CLI Tools

Path:

```
/uba-alert-context/cli/
```

Required tools:

1. `build_alert_context.py`
2. `export_alert_context.py`

Both must be:

* Deterministic
* Offline
* Validator-replayable

---

### 6. Audit Ledger Integration (MANDATORY)

Every operation must emit ledger entries:

* Alert context build
* Alert context export
* Alert context retrieval

Ledger must include:

* alert_id
* context_block_id
* uba_signal_ids
* explanation_bundle_id

---

### 7. Explicit NON-FEATURES (FORBIDDEN)

You MUST NOT:

* Change alert severity
* Suppress alerts
* Escalate alerts
* Trigger notifications
* Modify routing
* Modify alert content
* Introduce ML
* Introduce risk math
* Introduce policy logic
* Introduce human authority
* Introduce automation

---

### 8. Integration Guarantees

* **Alert Engine remains authoritative**
* **UBA remains non-authoritative**
* **SEE remains explanation root**
* **HAF remains authority root**
* **Risk Index remains risk root**

This engine is **purely explanatory**.

---

### 9. Documentation (MANDATORY)

Create:

```
/uba-alert-context/README.md
```

Must include:

* Purpose statement
* Non-authority declaration
* Regulatory positioning
* Analyst guidance examples
* Failure semantics
* Validator replay guarantees

Include explicit statement:

> “Alert Context does not modify alerts. It explains alerts to humans using behavioral context.”

---

### 10. Validation Requirements

Must be verifiable that:

* Alerts exist without context
* Context can be removed without affecting alerts
* Validator can rebuild context from:

  * Audit Ledger
  * UBA Signals
  * Explanation Bundles
* Removing UBA does NOT break alert pipeline

---

## FINAL STATEMENT (MUST BE TRUE)

> UBA Alert Context changes **understanding**, never **outcomes**.

---

### DELIVERABLE EXPECTATION

When complete, you will report:

* File structure
* Schema field counts
* Explicit guarantees
* Verification results

No placeholders.
No TODOs.
No partial work.

****promot end*****

