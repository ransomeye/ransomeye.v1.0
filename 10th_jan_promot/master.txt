*****Promot Start*****

You are working on **RansomEye v1.0 – Clean-Room Rebuild**.

**STRICT CONTEXT (READ CAREFULLY):**

* This is a **clean-room rebuild**. Assume **zero prior code exists**.
* You are in **Phase 1 – System Contracts**.
* **NO SERVICE CODE IS ALLOWED**.
* **NO INSTALLER CODE**.
* **NO DATABASE CODE**.
* Output must be **contracts only**.
* If you feel tempted to “prepare for later” or “add convenience”, **do not**.

---

## OBJECTIVE OF THIS PROMPT

Define the **canonical, immutable system contracts** for RansomEye v1.0.

These contracts will be frozen and **every future component must conform to them**.
If any later code violates these contracts, the code will be deleted.

---

## SCOPE (MUST DELIVER ALL)

Produce **ONLY** the following artifacts:

### 1. Canonical Event Envelope (AUTHORITATIVE)

Deliver:

* JSON Schema (Draft 2020-12)
* Protobuf definition

The envelope **must exactly contain** the following fields (no more, no less):

```json
{
  "event_id": "uuid",
  "machine_id": "string",
  "component": "linux_agent | windows_agent | dpi | core",
  "component_instance_id": "string",
  "observed_at": "RFC3339 UTC",
  "ingested_at": "RFC3339 UTC",
  "sequence": "monotonic_uint64",
  "payload": {},
  "identity": {
    "hostname": "string",
    "boot_id": "string",
    "agent_version": "string"
  },
  "integrity": {
    "hash_sha256": "string",
    "prev_hash_sha256": "string | null"
  }
}
```

Rules:

* **No optional fields**
* **No defaults**
* **No extensions**
* `payload` is opaque but must be typed correctly
* `component` must be an enum
* Timestamps must be strictly validated

---

### 2. Time Semantics Contract (TEXT + MACHINE-READABLE)

Define **explicit, enforceable rules** for:

* `observed_at`
* `ingested_at`
* Clock skew tolerance
* Out-of-order arrival
* Late arrival
* Duplicate arrival

Deliverables:

* Human-readable spec (Markdown)
* Machine-readable policy (JSON)

---

### 3. Failure Semantics Contract (MANDATORY)

Define **explicit behavior** for each component when:

* No events are received
* Events arrive late
* Events are duplicated
* Dependencies are unavailable
* Integrity chain breaks
* Schema validation fails

Rules:

* **Silence is forbidden**
* Every failure must result in:

  * Explicit state
  * Explicit log classification
  * Explicit downstream behavior

Deliverable:

* Structured failure matrix (Markdown table)
* Machine-readable failure policy (JSON)

---

### 4. Contract Bundle Metadata

Produce:

* Contract bundle version
* SHA256 hash placeholder (document where hash will be inserted later)
* Compatibility rules (breaking vs non-breaking)
* Freeze statement (immutable once approved)

---

## OUTPUT FORMAT (MANDATORY)

Return output in this **exact structure**:

```
/contracts/
  event-envelope.schema.json
  event-envelope.proto
  time-semantics.md
  time-semantics.policy.json
  failure-semantics.md
  failure-semantics.policy.json
  CONTRACT_BUNDLE.md
```

Each file must be fully written.

---

## HARD RULES (NON-NEGOTIABLE)

* ❌ Do NOT write code
* ❌ Do NOT reference databases
* ❌ Do NOT reference installers
* ❌ Do NOT reference paths
* ❌ Do NOT reference systemd
* ❌ Do NOT invent future fields
* ❌ Do NOT optimize for convenience

This is a **military-grade contract freeze**, not a draft.

If anything is ambiguous, **make it explicit**.
If something can fail, **define how it fails**.

---

Begin immediately.

*****Prompt End*****


*****Promot Start*****

You are continuing **RansomEye v1.0 – Clean-Room Rebuild**.

**STRICT CONTEXT (DO NOT VIOLATE):**

* Phase 1 (System Contracts) is **COMPLETE and FROZEN**.
* You are now entering **PHASE 2 — DATABASE FIRST**.
* **NO SERVICE CODE IS ALLOWED**.
* **NO INSTALLER CODE**.
* **NO AGENT / DPI CODE**.
* **NO UI CODE**.
* Database design is **authoritative**; future code must conform to it.
* If schema changes later without migration + version bump, the schema is invalid.

---

## OBJECTIVE OF THIS PROMPT

Design the **authoritative, production-grade database schema** for **RansomEye v1.0**, aligned **exactly** to the frozen system contracts and threat model.

This schema must support:

* Linux Agent
* Windows Agent
* DPI Probe
* Ingest
* Correlation Engine
* AI Core (read-only metadata)
* SOC UI (read-only views)

---

## HARD DATABASE PHILOSOPHY (NON-NEGOTIABLE)

* Schema is **not derived from code**
* Code will adapt to schema, not the reverse
* No dynamic columns
* No JSON blobs for core facts (JSON only where explicitly justified)
* Machine-first modeling (host-centric, not event-centric)
* Time-indexed everywhere
* Immutable primary keys
* Explicit foreign keys
* Deterministic querying

---

## SCOPE (MUST DELIVER ALL)

### 1. Core Identity Tables

Define tables for:

* Machines / Hosts
* Components (agent / dpi instances)
* Component identity history (version, boot_id)

Must align with:

* `machine_id`
* `component`
* `component_instance_id`
* `identity.*` fields from the event envelope

---

### 2. Event Storage Model (RAW + NORMALIZED)

Design:

* **Raw event storage** (exact envelope preservation)
* **Normalized tables** for:

  * Process activity
  * File activity
  * Persistence
  * Network intent (agent-side)
  * DPI-derived flows
  * DNS
  * Deception
  * Health / heartbeat

Rules:

* Raw events are immutable
* Normalized tables are query-optimized
* Every normalized row must reference its raw event

---

### 3. Integrity & Ordering

Schema must explicitly support:

* Event hash chains
* Sequence monotonicity per component instance
* Duplicate detection
* Gap detection

No inference in code — DB must support this natively.

---

### 4. Correlation & Incident Tables

Define tables for:

* Incidents
* Incident stages (Clean → Suspicious → Probable → Confirmed)
* Confidence accumulation
* Evidence linkage (event → incident)

Rules:

* One event can contribute to multiple incidents
* Incident state transitions must be auditable
* No deletion of incident history

---

### 5. AI / ML Metadata Tables (READ-ONLY)

Define tables for:

* Feature vectors (references only)
* Clusters
* Novelty scores
* SHAP explanations (references, not blobs)

Rules:

* AI NEVER writes facts
* AI NEVER mutates incidents
* Metadata only, versioned

---

### 6. Indexing, Partitioning & Retention

For every table:

* Primary key
* Foreign keys
* Mandatory indexes
* Time partitioning strategy
* Retention policy (hot / warm / cold)

No hand-waving. Be explicit.

---

### 7. Schema Freeze Artifacts

Produce:

* Versioned schema definition (DDL)
* Schema hash placeholder
* Migration rules (what constitutes breaking vs non-breaking)
* Explicit freeze statement

---

## OUTPUT FORMAT (MANDATORY)

Return output in this **exact structure**:

```
/schemas/
  00_core_identity.sql
  01_raw_events.sql
  02_normalized_agent.sql
  03_normalized_dpi.sql
  04_correlation.sql
  05_ai_metadata.sql
  06_indexes.sql
  07_retention.sql
  SCHEMA_BUNDLE.md
```

* SQL must be **PostgreSQL 14+ compatible**
* Use `UUID`, `TIMESTAMPTZ`, `JSONB` only where justified
* Every file must be complete and executable

---

## HARD RULES (DO NOT BREAK)

* ❌ No assumptions about paths
* ❌ No assumptions about deployment size
* ❌ No sample data
* ❌ No test data
* ❌ No service logic
* ❌ No shortcuts for “later optimization”

This schema must survive:

* Zero data
* One event
* Partial failure
* Adversarial input
* Multi-year growth

---

Begin immediately.
Do not explain — **design**.

*****Prompt End*****

Promot Start

You are continuing RansomEye v1.0 – Clean-Room Rebuild.

PHASE: 3 — INSTALLER BEFORE SERVICES
PREVIOUS PHASES COMPLETE:

Phase 1: System Contracts (Frozen)

Phase 2: Database Schema (Frozen)

STRICT RULES (NON-NEGOTIABLE)

❌ No service code

❌ No agent code

❌ No DPI code

❌ No database schema changes

❌ No systemd unit files yet

❌ No hardcoded paths

❌ No assumptions about install location

This installer must support commercial self-installation at any path.

ALLOWED LANGUAGES ONLY

Bash

Python 3.10+

No other languages permitted.

OBJECTIVE

Design the authoritative unified installer specification for RansomEye v1.0.

The installer is responsible for:

Discovering install root

Creating system user

Generating manifest

Injecting paths via ENV

Enforcing fail-closed startup

SCOPE (MUST DELIVER ALL)
1. Installation Manifest (AUTHORITATIVE)

Define a machine-readable manifest that contains:

Install root (absolute)

Data directories

Log directories

Binary directories

Config directories

Runtime UID/GID

Enabled components

Schema bundle hash

Contract bundle hash

Deliver:

install.manifest.schema.json

Example install.manifest.json (NO PATH ASSUMPTIONS, use placeholders)

2. Environment Variable Contract

Define EXACT ENV VARS that every service must read:

Paths

IDs

Versions

Runtime identity

Deliver:

env.contract.md

env.contract.json

No service may compute paths internally.

3. Privilege Model

Define:

Installer privilege requirements

Runtime privilege drop rules

Agent/DPI exception boundaries

Deliver:

privilege-model.md

4. Failure Semantics (Installer-Specific)

Define:

What causes install abort

What is recoverable

What is fatal

Rollback rules

Deliver:

installer-failure-policy.md

installer-failure-policy.json

OUTPUT FORMAT (MANDATORY)
/installer/
  install.manifest.schema.json
  install.manifest.json
  env.contract.md
  env.contract.json
  privilege-model.md
  installer-failure-policy.md
  installer-failure-policy.json
  INSTALLER_BUNDLE.md

HARD REQUIREMENTS

Installer must be idempotent

Installer must be fail-closed

Installer must leave zero partial state

All paths are injected, never inferred

Manifest is the single source of runtime truth

This installer defines how RansomEye exists on disk.

Begin immediately.
Do not explain — design.

Prompt End


Promot Start

You are continuing RansomEye v1.0 – Clean-Room Rebuild.

PHASE: 4 — MINIMAL DATA PLANE (ONE EVENT)

PREVIOUS PHASES (FROZEN):

Phase 1: System Contracts

Phase 2: Database Schema

Phase 3: Installer Contracts

HARD RULES (NON-NEGOTIABLE)

❌ No correlation engine

❌ No AI / ML / LLM

❌ No enrichment

❌ No heuristics

❌ No retries

❌ No buffering

❌ No background threads

❌ No filesystem/process monitoring

❌ No installer code

❌ No schema changes

❌ No contract changes

This phase exists only to prove:

One valid event → validated → stored → queryable

COMPONENT 1 — LINUX AGENT (MINIMAL)
Allowed Language

Rust only

Responsibilities (ONLY)

Read environment variables defined in env.contract.json

Construct exact canonical event envelope

Populate:

event_id

machine_id

component = linux_agent

component_instance_id

observed_at

sequence = 1

identity.*

integrity.hash_sha256

payload may contain one dummy key/value (explicitly allowed for this phase)

Transmit event to Ingest over HTTP

Forbidden

No local persistence

No retries

No batching

No enrichment

No inference

Deliver:

Minimal Rust binary

Clear module structure

Inline comments explaining contract compliance

COMPONENT 2 — INGEST SERVICE (MINIMAL)
Allowed Language

Python 3.10+ only

Responsibilities (ONLY)

Accept event via HTTP

Validate against:

event-envelope.schema.json

time-semantics.policy.json

Verify hash integrity

Detect duplicates (event_id + sequence)

Write to:

machines

component_instances

raw_events

event_validation_log

Forbidden

No correlation

No enrichment

No retry logic

No background jobs

No AI

No assumptions

OUTPUT FORMAT (MANDATORY)
/services/
  linux-agent/
    src/
    Cargo.toml
    README.md

  ingest/
    app/
    requirements.txt
    README.md


Each README must explain:

What this component does

What it explicitly does NOT do

How it proves Phase 4 correctness

VALIDATION CRITERIA (PASS / FAIL)

PASS only if:

One event is accepted

One row exists in raw_events

Hash chain is valid

No other tables are touched

Restarting ingest does NOT duplicate data

FAIL if:

Anything “helpful” is added

Any future logic leaks in

Begin immediately.
Do not explain — implement exactly.

Prompt End


Promot Start

You are continuing RansomEye v1.0 – Clean-Room Rebuild.

PHASE: 5 — CORRELATION ENGINE (DETERMINISTIC)

PREVIOUS PHASES (FROZEN):

Phase 1: System Contracts

Phase 2: Database Schema

Phase 3: Installer Contracts

Phase 4: Minimal Data Plane

HARD RULES (NON-NEGOTIABLE)

❌ No AI / ML / LLM

❌ No time-window dependency

❌ No probabilistic logic

❌ No heuristics

❌ No enrichment

❌ No retries

❌ No background threads

❌ No async

❌ No schema changes

❌ No contract changes

This engine must be purely deterministic.

OBJECTIVE

Implement the minimal deterministic correlation engine that:

Consumes validated events

Applies explicit contradiction rules

Produces at most one incident per event

INPUT

Read from:

raw_events

Normalized tables (if required)

Use only persisted facts

DETECTION MODEL (MINIMAL)

For this phase, define exactly ONE rule:

If a Linux Agent event exists with component = linux_agent,
THEN:

Either create zero incidents, OR

Create exactly one incident with:

stage = Suspicious

confidence = deterministic constant (e.g. 0.3)

No additional logic is allowed.

INCIDENT REQUIREMENTS

When an incident is created:

Insert into incidents

Insert initial stage into incident_stages

Link triggering event in evidence

All writes must be atomic (single transaction)

OUTPUT FORMAT (MANDATORY)
/services/
  correlation-engine/
    app/
      main.py
      rules.py
      db.py
    requirements.txt
    README.md

README MUST EXPLICITLY STATE

What rules exist

Why rules are deterministic

What this engine does NOT do

Why time is NOT required for correctness

VALIDATION (PASS / FAIL)

PASS only if:

One event → ≤ 1 incident

Restarting engine does NOT duplicate incidents

No time-window logic exists

No ML/AI imports exist

No retries or background jobs exist

FAIL if:

Engine waits for more data

Engine uses time windows

Engine attempts “confidence tuning”

Begin immediately.
Do not explain — implement exactly.

Prompt End


Promot Start

You are continuing RansomEye v1.0 – Clean-Room Rebuild.

PHASE: 6 — AI CORE (READ-ONLY, NON-BLOCKING)

PREVIOUS PHASES (FROZEN):

Phase 1: System Contracts

Phase 2: Database Schema

Phase 3: Installer Contracts

Phase 4: Minimal Data Plane

Phase 5: Deterministic Correlation Engine

HARD RULES (NON-NEGOTIABLE)

❌ AI must NOT create incidents

❌ AI must NOT modify incidents

❌ AI must NOT block pipeline

❌ AI must NOT require real-time inference

❌ AI must NOT be in data plane

❌ No deep learning

❌ No retries

❌ No background schedulers

❌ No schema changes

❌ No contract changes

The system must remain fully correct if AI is disabled.

OBJECTIVE

Implement the minimal AI Core that operates in read-only advisory mode.

The AI Core must:

Consume existing incidents

Perform offline, batch analysis

Produce metadata only

AI FUNCTIONS (MINIMAL, REQUIRED)

Implement exactly three capabilities:

1. Feature Extraction (Deterministic)

Derive numeric features from:

incident confidence

incident stage

evidence count

Persist feature vector references only

2. Unsupervised Clustering

Use scikit-learn (e.g., KMeans or DBSCAN)

Cluster incidents

Persist:

cluster_id

model_version

incident ↔ cluster mapping

3. Explainability (SHAP)

Generate SHAP explanations for:

confidence contribution

evidence contribution

Store references only, not raw arrays

OUTPUT FORMAT (MANDATORY)
/services/
  ai-core/
    app/
      main.py
      feature_extraction.py
      clustering.py
      shap_explainer.py
      db.py
    requirements.txt
    README.md

README MUST EXPLICITLY STATE

AI is read-only

AI cannot block or decide

AI output is advisory only

System remains correct without AI

VALIDATION (PASS / FAIL)

PASS only if:

Incidents are unchanged

Only AI metadata tables are written

Disabling AI has zero impact on detection

SHAP output is generated per run

Models are versioned and reproducible

FAIL if:

AI touches facts

AI alters incident state

AI introduces timing dependency

AI blocks pipeline

Begin immediately.
Do not explain — implement exactly.

Prompt End


Promot Start

You are continuing RansomEye v1.0 – Clean-Room Rebuild.

PHASE: 7 — POLICY ENGINE (SIMULATION-FIRST)

PREVIOUS PHASES (FROZEN):

Phase 1: System Contracts

Phase 2: Database Schema

Phase 3: Installer Contracts

Phase 4: Minimal Data Plane

Phase 5: Deterministic Correlation Engine

Phase 6: AI Core (Read-Only)

HARD RULES (NON-NEGOTIABLE)

❌ No automatic enforcement

❌ No agent execution

❌ No incident modification

❌ No AI / ML / LLM

❌ No background schedulers

❌ No async

❌ No schema changes

❌ No contract changes

Policy Engine operates in SIMULATION MODE BY DEFAULT.

OBJECTIVE

Implement the minimal Policy Engine that:

Consumes existing incidents

Evaluates explicit policy rules

Produces policy decisions and simulations

Signs commands without executing them

POLICY MODEL (MINIMAL)

Define exactly ONE policy rule:

IF incident.stage == SUSPICIOUS
THEN recommend action: ISOLATE_HOST

Rules:

Recommendation only

No execution

Deterministic (no time, no probability)

COMMAND MODEL

When a policy decision is made:

Generate a command payload:

command_type

target_machine_id

incident_id

issued_at

Cryptographically sign the command

Store signed command in DB

DO NOT send to agents

OUTPUT FORMAT (MANDATORY)
/services/
  policy-engine/
    app/
      main.py
      rules.py
      signer.py
      db.py
    requirements.txt
    README.md

README MUST EXPLICITLY STATE

Policy is simulation-first

No commands are executed

Enforcement is disabled by default

All commands are signed and auditable

System correctness does not depend on policy engine

VALIDATION (PASS / FAIL)

PASS only if:

Incidents are unchanged

Policy decisions are recorded

Signed commands are generated

No enforcement occurs

Disabling policy engine has zero impact

FAIL if:

Any command is executed

Any agent is contacted

Incident state is modified

Enforcement occurs implicitly

Begin immediately.
Do not explain — implement exactly.

Prompt End



Promot Start

You are continuing RansomEye v1.0 – Clean-Room Rebuild.

PHASE: 8 — SOC UI (READ-ONLY)

PREVIOUS PHASES (FROZEN):

Phase 1: System Contracts

Phase 2: Database Schema

Phase 3: Installer Contracts

Phase 4: Minimal Data Plane

Phase 5: Correlation Engine

Phase 6: AI Core (Read-Only)

Phase 7: Policy Engine (Simulation-First)

HARD RULES (NON-NEGOTIABLE)

❌ UI must NOT write to DB

❌ UI must NOT query base tables

❌ UI must NOT infer state

❌ UI must NOT trigger actions

❌ UI must NOT contain policy logic

❌ UI must NOT contain AI logic

❌ No schema changes

❌ No contract changes

UI is OBSERVATIONAL ONLY.

OBJECTIVE

Implement the minimal SOC UI that provides read-only visibility into system state.

REQUIRED DB VIEWS (MUST DEFINE)

Define READ-ONLY SQL VIEWS for:

v_active_incidents

incident_id

machine_id

stage

confidence

created_at

v_incident_timeline

incident_id

stage

transitioned_at

v_incident_evidence_summary

incident_id

evidence_count

v_policy_recommendations

incident_id

recommended_action

simulation_mode

created_at

v_ai_insights

incident_id

cluster_id

novelty_score

shap_summary

UI FEATURES (MINIMAL)
Dashboards

Incident list (from v_active_incidents)

Incident detail view:

Timeline

Evidence count

AI insights

Policy recommendations

Constraints

No edits

No buttons that execute actions

No “acknowledge”, “resolve”, or “close”

OUTPUT FORMAT (MANDATORY)
/services/
  ui/
    backend/
      main.py
      views.sql
      requirements.txt
    frontend/
      src/
      package.json
      README.md
    README.md

README MUST EXPLICITLY STATE

UI is read-only

UI does not affect pipeline

UI reads from DB views only

System correctness is independent of UI

VALIDATION (PASS / FAIL)

PASS only if:

UI reads ONLY from views

UI cannot modify data

UI can be disabled without impact

No table writes exist

FAIL if:

Any DB write exists

Any base table is queried

Any action can be triggered

Begin immediately.
Do not explain — implement exactly.

Prompt End


Promot Start

You are continuing RansomEye v1.0 – Clean-Room Rebuild.

PHASE: 9 — VALIDATION HARNESS (WRITTEN FIRST)

PREVIOUS PHASES (FROZEN):

Phase 1: System Contracts

Phase 2: Database Schema

Phase 3: Installer Contracts

Phase 4: Minimal Data Plane

Phase 5: Correlation Engine

Phase 6: AI Core (Read-Only)

Phase 7: Policy Engine (Simulation-First)

Phase 8: SOC UI (Read-Only)

HARD RULES (NON-NEGOTIABLE)

❌ No service logic

❌ No mocks of core logic

❌ No sleeps / timing hacks

❌ No randomness

❌ No skipping failures

❌ No schema changes

❌ No contract changes

Validation must assert real system behavior.

OBJECTIVE

Implement the authoritative validation harness that proves end-to-end correctness of RansomEye v1.0.

VALIDATION CASES (ALL REQUIRED)

Implement tests for:

Cold start correctness

Zero-event correctness

One-event correctness

Duplicate event handling

Failure semantics enforcement

Subsystem disablement (AI, Policy, UI)

Each test must:

Set up environment

Execute scenario

Assert DB state

Assert logs / exit codes

Clean up

OUTPUT FORMAT (MANDATORY)
/validation/
  harness/
    test_cold_start.py
    test_zero_event.py
    test_one_event.py
    test_duplicates.py
    test_failure_semantics.py
    test_subsystem_disablement.py
  README.md

README MUST EXPLICITLY STATE

What is validated

Why failures block release

How to run validation

Determinism guarantees

PASS / FAIL CRITERIA

PASS only if:

All tests pass consistently

Results are deterministic

System is left clean

No silent failures exist

FAIL if:

Any nondeterminism

Any skipped test

Any silent error

Begin immediately.
Do not explain — implement exactly.

Prompt End


Promot Start

You are continuing RansomEye v1.0 – Clean-Room Rebuild.

PHASE: 9.1 — VALIDATION HARDENING (MANDATORY CORRECTION)

HARD RULES (NON-NEGOTIABLE)

❌ NO synthetic events

❌ NO fabricated UUIDs

❌ NO prebuilt payloads

❌ NO fixed timestamps

❌ NO dummy data of any kind

Validation must observe real system behavior only.

OBJECTIVE

Refactor the existing Phase 9 validation harness to meet military-grade forensic correctness.

REQUIRED CHANGES
1. Linux Agent–Driven Validation

Validation must:

Launch the real Linux Agent binary

Wait for agent to emit one real event

Observe resulting DB state

No manual event construction allowed.

2. Replace Fixed Assertions

Replace:

Fixed UUID checks

Fixed timestamp checks

With:

Structural assertions

Cardinality assertions

Contract compliance assertions

Integrity chain verification

3. Policy & AI Validation Tightening

Validation must:

Verify signed command exists

Verify signature cryptographically

Verify command was not executed

Verify AI metadata exists or not, without inspecting content

OUTPUT

Modify only files under:

/validation/harness/


No schema changes.
No service changes.
No contract changes.

PASS CRITERIA

PASS only if:

Validation uses real agents

No synthetic data exists

All assertions are observational

Results remain deterministic

System remains clean

Begin immediately.
Do not explain — fix it.

Prompt End



Promot Start*

You are continuing RansomEye v1.0 – Clean-Room Rebuild.

PHASE: 10.1 — CORE RUNTIME HARDENING (STARTUP & SHUTDOWN)

STRICT CONTEXT (DO NOT VIOLATE)

You are hardening RansomEye Core, not individual services.

Ingest, Correlation, AI Core, Policy Engine, UI Backend run inside one Core runtime.

❌ NO systemd files

❌ NO standalone service assumptions

❌ NO new features

❌ NO retries

❌ NO schema or contract changes

OBJECTIVE (ONLY THIS)

Harden startup and shutdown behavior for RansomEye Core components.

COMPONENTS IN SCOPE

Inside Core:

Ingest

Correlation Engine

AI Core

Policy Engine

UI Backend

Treat them as modules, not services.

REQUIRED HARDENING (IMPLEMENT ALL)
1. Startup Validation (MANDATORY)

On Core startup:

Validate all required environment variables

Validate DB connectivity

Validate schema presence

Validate write permissions where applicable

Validate read-only enforcement where applicable

If ANY check fails:

Log explicit error

Exit process immediately (non-zero)

2. Fail-Fast Invariants

Add invariant checks that terminate Core immediately if violated:

Missing env var

DB connection failure

Schema mismatch

Unauthorized write attempt (read-only module)

Duplicate incident creation attempt

No recovery. No retry.

3. Graceful Shutdown

On SIGTERM / SIGINT:

Stop accepting new work

Finish in-flight DB transactions

Close DB connections cleanly

Exit cleanly with log confirmation

OUTPUT CONSTRAINTS

Modify existing Core code only

Do NOT create new processes

Do NOT introduce background schedulers

Do NOT add retries

Do NOT add systemd files

Each modified Core module must update its README with a new section:

Operational Hardening Guarantees
PASS CRITERIA

PASS only if:

Core fails immediately on bad config

Core shuts down cleanly

No partial state possible

No retries hide failures

Begin immediately.
Do not explain.
Implement only what is asked.

Promot end*


Promot Start*

You are continuing RansomEye v1.0 – Enterprise & Military-Grade Build.

WORK UNIT: Database Hardening & Transaction Safety
(Do NOT use phase numbers anywhere)

STRICT CONTEXT (DO NOT VIOLATE)

This applies to RansomEye Core database usage

Core runs as one unified runtime

❌ No schema changes

❌ No contract changes

❌ No retry loops

❌ No silent fallbacks

❌ No per-module DB ownership confusion

OBJECTIVE (ONLY THIS)

Harden all database interactions to ensure:

Atomicity

Consistency

Explicit failure behavior

Zero partial state

Deterministic outcomes under failure

COMPONENTS IN SCOPE (CORE)

Ingest

Correlation Engine

AI Core

Policy Engine

UI Backend (read-only)

REQUIRED HARDENING (IMPLEMENT ALL)
1. Transaction Discipline (MANDATORY)

For every DB write path:

Explicit transaction begin

Explicit commit on success

Explicit rollback on failure

No implicit autocommit behavior

If rollback fails → terminate Core.

2. Isolation & Consistency

Explicitly set isolation level at connection creation

Log isolation level at startup

Reject runtime if isolation cannot be enforced

3. Deadlock & Integrity Detection

Detect and fail fast on:

Serialization failures

Deadlocks

Foreign-key violations

Unique-constraint violations

No retries.
Log → terminate.

4. Connection Safety

Validate connection health before each critical operation

Detect dropped connections

Fail immediately on broken connection

No reconnection loops

5. Read-Only Enforcement (UI & AI)

Explicitly open read-only DB sessions

Abort process if write attempt occurs

Log security-grade error

OUTPUT CONSTRAINTS

Modify existing DB access layers only

No new abstractions unless required for safety

No background workers

No schedulers

Each modified component must update its README:

Database Safety & Transaction Guarantees
PASS CRITERIA

PASS only if:

No partial writes possible

All failures are explicit and fatal

Isolation level is enforced and logged

Read-only violations terminate immediately

System behavior is deterministic under DB failure

Begin immediately.
Do not explain.
Do not refactor unrelated code.
Harden the database interactions only.

Promot end*




Promot Start*

You are continuing RansomEye v1.0 – Enterprise & Military-Grade Build.

WORK UNIT: Database Safety Completion (AI Core, Policy Engine, UI Backend)

STRICT CONTEXT (DO NOT VIOLATE)

Database schema is frozen

Contracts are frozen

Core runs as one unified runtime

❌ No retries

❌ No silent failures

❌ No best-effort fallbacks

❌ No new abstractions beyond existing common/db/safety.py

OBJECTIVE (ONLY THIS)

Complete database hardening for remaining Core modules using the existing safety utilities.

COMPONENT-SPECIFIC REQUIREMENTS
1. AI Core

File:
services/ai-core/app/db.py

Required changes:

All read paths must use create_readonly_connection()

All write paths must use execute_write_operation()

Enforce isolation level

Abort Core on:

Deadlock

Integrity violation

Unauthorized write attempt

2. Policy Engine

File:
services/policy-engine/app/db.py

Required changes:

Use read-only connections only

Enforce read-only mode explicitly

Abort Core if any write is attempted

Policy Engine must never write to DB.

3. UI Backend

File:
services/ui/backend/main.py

Required changes:

Enforce read-only DB connections at pool level

Ensure query_view() cannot execute writes

Any write attempt → immediate Core termination

4. Documentation (MANDATORY)

Update README for:

AI Core

Policy Engine

UI Backend

Add section:

Database Safety & Transaction Guarantees

Must explicitly state:

Isolation level enforcement

Explicit transaction behavior

Read-only enforcement (where applicable)

Fail-fast semantics

No retries, no partial state

No fluff. No marketing.

PASS CRITERIA

PASS only if:

AI Core writes are fully transaction-safe

Policy Engine cannot write under any condition

UI Backend is read-only by construction

Any DB misuse terminates Core

All READMEs updated correctly

Begin immediately.
Do not refactor unrelated code.
Do not summarize.
Finish database hardening cleanly.

Promot end*




Promot Start*

You are continuing RansomEye v1.0 – Enterprise & Military-Grade Build.

WORK UNIT: Resource & Disk Safety Hardening

STRICT CONTEXT (DO NOT VIOLATE)

Applies to RansomEye Core runtime

Core runs as one unified process

❌ No schema changes

❌ No contract changes

❌ No retries

❌ No background schedulers

❌ No new features

This is safety hardening only.

OBJECTIVE (ONLY THIS)

Harden Core against resource exhaustion and disk failures so the system fails explicitly and safely, never silently.

COMPONENTS IN SCOPE (CORE)

Ingest

Correlation Engine

AI Core

Policy Engine

UI Backend

REQUIRED HARDENING (IMPLEMENT ALL)
1. Disk Safety (MANDATORY)

Implement explicit checks and fail-fast behavior for:

Disk full conditions

Permission denied (logs, temp, runtime dirs)

Read-only filesystem

Rules:

Detect error at write attempt

Log explicit error

Terminate Core immediately

No retries, no degradation

2. Log Safety

Prevent unbounded log growth

Enforce size limits or rotation without losing critical errors

If logging fails → terminate Core (fail-fast)

No silent logging failures.

3. File Descriptor & Resource Limits

Detect exhaustion of file descriptors

Detect inability to open files/sockets

Fail fast with explicit error

4. Memory Safety (BASIC, NOT OPTIMIZATION)

Detect MemoryError / allocation failures

Abort Core immediately on memory allocation failure

No swap-based survival logic

OUTPUT CONSTRAINTS

Modify existing code paths only

Use explicit exception handling

No new abstractions unless strictly required for safety

No platform-specific hacks

Each modified component must update its README with a section:

Resource & Disk Safety Guarantees
PASS CRITERIA

PASS only if:

Disk full causes explicit termination

Logging failure causes explicit termination

Resource exhaustion causes explicit termination

No silent degradation paths exist

Behavior is deterministic under resource failure

Begin immediately.
Do not explain.
Do not refactor unrelated code.
Harden resource and disk safety only.

Promot end*


Promot Start*

You are continuing RansomEye v1.0 – Enterprise & Military-Grade Build.

WORK UNIT: Security Hardening (Secrets, Redaction, Signing Discipline)

STRICT CONTEXT (DO NOT VIOLATE)

Applies to RansomEye Core runtime

Core runs as one unified process

❌ No schema changes

❌ No contract changes

❌ No new features

❌ No retries

❌ No background schedulers

❌ No standalone services added

Security hygiene only.

OBJECTIVE (ONLY THIS)

Eliminate secret leakage risks and enforce cryptographic discipline across Core.

COMPONENTS IN SCOPE (CORE)

Ingest

Correlation Engine

AI Core

Policy Engine

UI Backend

Common logging & config utilities

REQUIRED HARDENING (IMPLEMENT ALL)
1. Secrets Handling (MANDATORY)

All secrets only from environment variables

No secrets in:

Code

Config files

Logs

Exceptions

Validate presence and format at startup

If a required secret is missing or malformed → terminate Core immediately

2. Log Redaction (MANDATORY)

Implement centralized redaction for:

DB credentials

API tokens

Signing keys

Any value matching secret patterns

Ensure:

Secrets never appear in logs

Stack traces are sanitized

Any attempt to log a secret → terminate Core

3. Signing Discipline (Policy Engine)

Ensure command signing keys:

Are read once at startup

Never logged

Never reloaded dynamically

Validate key strength and format

Fail fast on weak/invalid keys

4. Untrusted Input Handling (AI & UI)

Treat AI metadata and UI inputs as untrusted

Validate types and bounds before processing

Abort Core on malformed or unexpected structures

OUTPUT CONSTRAINTS

Modify existing code paths only

No new crypto schemes

Use existing libraries already in use

No platform-specific hacks

Each modified component must update its README with:

Security & Secrets Handling Guarantees
PASS CRITERIA

PASS only if:

No secrets can be logged

Missing/weak secrets terminate Core

Signing keys are handled once, securely

Malformed untrusted input terminates Core

Behavior is deterministic and explicit

Begin immediately.
Do not explain.
Do not refactor unrelated code.
Harden security hygiene only.

Promot end*



Promot Start*

You are continuing RansomEye v1.0 – Enterprise & Military-Grade Build.

WORK UNIT: End-to-End Hardened Run & Validation Re-Execution

STRICT CONTEXT (DO NOT VIOLATE)

All hardening work is complete and frozen

Credentials everywhere are username = gagan, password = gagan

❌ No code changes unless a failure is discovered

❌ No schema changes

❌ No contract changes

❌ No new features

This is an execution and verification step only.

OBJECTIVE (ONLY THIS)

Bring up the entire hardened RansomEye system on this machine and prove zero-failure operation.

REQUIRED EXECUTION STEPS

Start PostgreSQL with credentials:

user: gagan

password: gagan

Start RansomEye Core (single unified runtime):

Ingest

Correlation Engine

AI Core

Policy Engine

UI Backend

Start Linux Agent:

Emit at least one real event

Run full validation harness (hardened, reality-based):

All tests must pass

No warnings ignored

No retries hiding faults

REQUIRED OBSERVATIONS

You must confirm:

No crashes

No invariant violations

No secret leakage in logs

No partial DB state

Clean startup and clean shutdown

Validation passes without modification

OUTPUT EXPECTATION

Return only:

Execution status

Any failures (if present)

Confirmation of zero-failure run

Do NOT summarize code.
Do NOT refactor.

Begin immediately.
This step gates installer creation.

Promot end*



Promot Start*

You are continuing RansomEye v1.0 – Enterprise & Military-Grade Build.

WORK UNIT: Installer Packaging — RansomEye Core

STRICT CONTEXT (DO NOT VIOLATE)

Core code is frozen

Validation is frozen

❌ No code changes unless installer uncovers a fatal issue

❌ No schema changes

❌ No contract changes

❌ No feature additions

This step is packaging only.

OBJECTIVE (ONLY THIS)

Create a commercial-grade installer for RansomEye Core that:

Installs cleanly on Ubuntu LTS

Uses any install path chosen by the user

Runs Core as a single unified service

Uses credentials:

user: gagan

password: gagan

Is deterministic, idempotent, and fail-closed

INSTALLER REQUIREMENTS (MANDATORY)
1. Installer Type

Bash installer (install.sh)

Must be executable

Must fail fast on any error

2. User & Permissions

Installer must:

Create system user: ransomeye

Set ownership and permissions correctly

Drop privileges for runtime

3. Paths (NO HARDCODED PATHS)

Installer must:

Prompt for install root (example: /opt/ransomeye)

Create:

bin/

lib/

config/

logs/

runtime/

Write installation manifest with absolute paths

4. Configuration

Installer must generate:

Environment file for Core

DB connection config using:

user: gagan

password: gagan

Log directories with correct permissions

5. Service Management

Create ONE systemd service:

ransomeye-core.service

No per-module services

Service must:

Start Core

Restart on failure

Stop cleanly

6. Validation Hook

Installer must:

Start Core

Perform health check

Fail installation if Core does not start cleanly

OUTPUT FORMAT (MANDATORY)
/installer/
  core/
    install.sh
    uninstall.sh
    ransomeye-core.service
    installer.manifest.json
    README.md

README MUST EXPLICITLY STATE

What the installer does

Supported OS

How to install

How to uninstall

Failure behavior (fail-closed)

No assumptions about paths

PASS / FAIL CRITERIA

PASS only if:

Installer works on a clean Ubuntu system

Installation path is user-defined

Core starts successfully

Core stops cleanly

Re-running installer is idempotent

FAIL if:

Any hardcoded path exists

Multiple services are created

Installer continues after failure

Begin immediately.
Do not explain.
Do not summarize.
Build the Core installer only.

Promot end*


Promot Start*

You are continuing RansomEye v1.0 – Enterprise & Military-Grade Build.

WORK UNIT: Core Installer Corrections (Blocking Fixes)

STRICT CONTEXT (DO NOT VIOLATE)

Core code is frozen

Installer must NOT modify Core logic

❌ No runtime fixes inside installer

❌ No new features

❌ No schema or contract changes

This task is installer-only corrections.

REQUIRED FIXES (ALL MANDATORY)
1. Credential Correction (CRITICAL)

Across the installer:

Username must be exactly: gagan

Password must be exactly: gagan

Fix all occurrences including:

env file generation

DB config

health checks

README examples

No variants. No hashes. No doubles.

2. Remove Core Runtime Modification

Revert any Core code changes introduced during installer creation

Installer must:

Copy pre-built Core artifacts

Start Core as-is

If Core startup requires uvicorn:

Installer must call it

NOT modify Core code

3. Re-run Installer Validation

Install on clean system

Start Core

Health check must pass

Uninstall must fully clean system

OUTPUT EXPECTATION

Return:

Confirmation of credential correction

Confirmation no Core code was modified

Confirmation installer works end-to-end

Do NOT summarize code.

Begin immediately.

Promot end*



Promot Start*

You are continuing RansomEye v1.0 – Enterprise & Military-Grade Build.

WORK UNIT: Linux Agent Installer (Standalone, systemd)

STRICT CONTEXT (DO NOT VIOLATE)

Linux Agent is a standalone component

❌ Do NOT modify Linux Agent code

❌ Do NOT modify Core code

❌ Do NOT assume Core is installed

❌ Do NOT hardcode any paths

❌ Do NOT add features

This task is installer packaging only.

OBJECTIVE (ONLY THIS)

Create a production-grade installer for the Linux Agent that:

Installs cleanly on Ubuntu LTS

Uses any install path chosen by the user

Runs as a standalone systemd service

Emits real events when Core is present

Fails cleanly when Core is absent (no crashes, no loops)

INSTALLER REQUIREMENTS (MANDATORY)
1. Installer Type

Bash installer (install.sh)

Executable

Fail-fast (set -euo pipefail)

2. User & Permissions

Installer must:

Create system user: ransomeye-agent

Drop privileges for runtime

Ensure least-privilege filesystem access

3. Paths (NO HARDCODED PATHS)

Installer must:

Prompt for install root (example: /opt/ransomeye-agent)

Create:

bin/

config/

logs/

runtime/

Write agent installation manifest with absolute paths

4. Configuration

Installer must generate:

Agent environment file

Core endpoint configurable via env (no assumption Core exists)

Credentials fixed:

username: gagan

password: gagan

5. systemd Service (MANDATORY)

Create ONE service:

ransomeye-linux-agent.service

Service must:

Run Linux Agent binary

Restart on failure

Handle SIGTERM cleanly

Not crash-loop if Core is unreachable

6. Validation Hook

Installer must:

Start agent

Verify process is running

NOT require Core to be present

OUTPUT FORMAT (MANDATORY)
/installer/
  linux-agent/
    install.sh
    uninstall.sh
    ransomeye-linux-agent.service
    installer.manifest.json
    README.md

README MUST EXPLICITLY STATE

Standalone nature of Linux Agent

Supported OS

How to install

How to uninstall

Behavior when Core is unreachable

No path assumptions

PASS / FAIL CRITERIA

PASS only if:

Agent installs without Core

Agent runs under systemd

Agent stops cleanly

Re-running installer is idempotent

Uninstall removes all artifacts

FAIL if:

Any hardcoded path exists

Agent assumes Core availability

Multiple services are created

Begin immediately.
Do not explain.
Do not summarize.
Build the Linux Agent installer only.

Promot end*



Promot Start*

You are continuing RansomEye v1.0 – Enterprise & Military-Grade Build.

WORK UNIT: Windows Agent Installer (Standalone, .bat)

STRICT CONTEXT (DO NOT VIOLATE)

Windows Agent is a standalone component

❌ Do NOT modify Windows Agent code

❌ Do NOT modify Core code

❌ Do NOT assume Core is installed

❌ Do NOT hardcode any paths

❌ Do NOT introduce MSI / PowerShell (BAT ONLY)

This task is installer packaging only.

OBJECTIVE (ONLY THIS)

Create a production-grade Windows installer for the Windows Agent that:

Installs cleanly on Windows Server / Windows 10+

Uses any install path chosen by the user

Runs as a Windows Service

Emits telemetry when Core is reachable

Fails gracefully when Core is unreachable (no crash loops)

INSTALLER REQUIREMENTS (MANDATORY)
1. Installer Type

Windows batch installer (install.bat)

Must be run as Administrator

Fail-fast on any error

2. User & Permissions

Installer must:

Create Windows service user: ransomeye-agent

Run service under least privilege

Ensure filesystem permissions are minimal

3. Paths (NO HARDCODED PATHS)

Installer must:

Prompt for install directory (example: C:\RansomEye\Agent)

Create:

bin\

config\

logs\

runtime\

Generate installation manifest with absolute paths

4. Configuration

Installer must generate:

Environment/config file

Core endpoint configurable

Credentials fixed:

username: gagan

password: gagan

5. Windows Service (MANDATORY)

Create ONE service:

RansomEyeWindowsAgent

Service must:

Run agent executable

Auto-restart on failure

Stop cleanly

NOT crash-loop if Core is unreachable

6. Validation Hook

Installer must:

Start service

Verify service is running

NOT require Core to be reachable

OUTPUT FORMAT (MANDATORY)
/installer/
  windows-agent/
    install.bat
    uninstall.bat
    ransomeye-windows-agent.service.txt
    installer.manifest.json
    README.md

README MUST EXPLICITLY STATE

Standalone nature of Windows Agent

Supported Windows versions

How to install (Administrator required)

How to uninstall

Behavior when Core is unreachable

No path assumptions

PASS / FAIL CRITERIA

PASS only if:

Agent installs without Core

Windows service starts

Service stops cleanly

Re-running installer is idempotent

Uninstall removes all artifacts

FAIL if:

Any hardcoded path exists

PowerShell/MSI is used

Agent assumes Core availability

Multiple services are created

Begin immediately.
Do not explain.
Do not summarize.
Build the Windows Agent installer only.

Promot end*


*Promot Start*

You are continuing RansomEye v1.0 – Enterprise & Military-Grade Build.

WORK UNIT: DPI Probe Installer (Standalone, systemd)

STRICT CONTEXT (DO NOT VIOLATE)

DPI Probe is a standalone privileged component

❌ Do NOT modify DPI Probe code

❌ Do NOT modify Core code

❌ Do NOT assume Core is installed

❌ Do NOT hardcode any paths

❌ Do NOT bundle agents or Core

This task is installer packaging only.

OBJECTIVE (ONLY THIS)

Create a production-grade installer for the DPI Probe that:

Installs cleanly on Ubuntu LTS

Uses any install path chosen by the user

Runs as a standalone systemd service

Runs with explicitly scoped elevated privileges

Emits telemetry when Core is reachable

Fails gracefully when Core is unreachable (no crash loops)

INSTALLER REQUIREMENTS (MANDATORY)
1. Installer Type

Bash installer (install.sh)

Executable

Fail-fast (set -euo pipefail)

2. Privilege Model (CRITICAL)

Installer must:

Require root for installation

Run DPI Probe service with:

CAP_NET_RAW

CAP_NET_ADMIN

NOT run as full root unless strictly required

Explicitly document privileges in README

3. Paths (NO HARDCODED PATHS)

Installer must:

Prompt for install root (example: /opt/ransomeye-dpi)

Create:

bin/

config/

logs/

runtime/

Write DPI Probe installation manifest with absolute paths

4. Configuration

Installer must generate:

Environment/config file

Core endpoint configurable

Network interface configurable

Credentials fixed:

username: gagan

password: gagan

5. systemd Service (MANDATORY)

Create ONE service:

ransomeye-dpi.service

Service must:

Run DPI Probe binary

Set Linux capabilities explicitly

Restart on failure

Prevent crash-looping

Handle SIGTERM cleanly

6. Validation Hook

Installer must:

Start DPI Probe

Verify process is running

NOT require Core to be reachable

OUTPUT FORMAT (MANDATORY)
/installer/
  dpi-probe/
    install.sh
    uninstall.sh
    ransomeye-dpi.service
    installer.manifest.json
    README.md

README MUST EXPLICITLY STATE

Standalone nature of DPI Probe

Required privileges and capabilities

Supported OS

How to install

How to uninstall

Behavior when Core is unreachable

No path assumptions

PASS / FAIL CRITERIA

PASS only if:

DPI Probe installs without Core

Runs under systemd with scoped privileges

Stops cleanly

Re-running installer is idempotent

Uninstall removes all artifacts

FAIL if:

Runs as full root unnecessarily

Any hardcoded path exists

Assumes Core availability

Multiple services are created

Begin immediately.
Do not explain.
Do not summarize.
Build the DPI Probe installer only.

Promot end*



Promot Start*

You are continuing RansomEye v1.0 – Enterprise & Military-Grade Build.

WORK UNIT: Enterprise Release Bundle & Final Validation

STRICT CONTEXT (DO NOT VIOLATE)

❌ NO code changes

❌ NO installer changes

❌ NO schema or contract changes

❌ NO new features

This task is packaging, validation, and release artifacts only.

OBJECTIVE (ONLY THIS)

Create the final enterprise release bundle for RansomEye v1.0 that:

Groups all installers cleanly

Provides a single authoritative entry point

Produces verifiable integrity artifacts

Enables customers to install components independently or together

REQUIRED OUTPUT STRUCTURE (MANDATORY)
/release/
  ransomeye-v1.0/
    core/
    linux-agent/
    windows-agent/
    dpi-probe/
    checksums/
      SHA256SUMS
      SHA256SUMS.sig
    audit/
      build-info.json
      component-manifest.json
    validate-release.sh
    README.md

REQUIREMENTS (MANDATORY)
1. Installer Aggregation

Copy installers as-is into respective folders

Do NOT modify installer contents

2. Integrity & Audit Artifacts

Generate:

SHA256SUMS for every installer file

build-info.json:

version

build timestamp

OS used

git commit hashes

component-manifest.json:

component name

installer path

service name

standalone vs core

required privileges

3. Validation Script

validate-release.sh must:

Verify checksums

Verify required files exist

Fail fast on any mismatch

NOT install anything

4. README (CRITICAL)

README must clearly explain:

What RansomEye is

Components overview

Installation order (optional)

Standalone vs Core components

Credentials policy (gagan / gagan)

Supported OS matrix

Security & privilege model

How to validate integrity

How to get support (placeholder allowed)

PASS / FAIL CRITERIA

PASS only if:

Bundle is self-contained

Integrity verification works

No files modified from installers

Clear enterprise-grade documentation exists

FAIL if:

Any installer is changed

Any checksum missing

Validation script is non-deterministic

Begin immediately.
Do not explain.
Do not summarize.
Build the enterprise release bundle only.

Promot end*



****Promot Start****

You are continuing **RansomEye — Enterprise & Military-Grade Platform Expansion**.

This is **PHASE A (FOUNDATIONAL, NON-OPTIONAL)**.

No other work is allowed until this phase is fully complete, validated, and frozen.

---

# WORK UNIT A1 — AUDIT LEDGER (APPEND-ONLY, SIGNED, SYSTEM-WIDE)

## ABSOLUTE CONTEXT (DO NOT VIOLATE)

* ❌ NO modification to existing v1.0 Core, Agents, DPI, or installers
* ❌ NO retrofitting logic into existing code paths
* ❌ NO optional fields, placeholders, mock data, or synthetic shortcuts
* ❌ NO reliance on wall-clock trust without cryptographic proof

This phase **adds new foundational subsystems** only.

---

## OBJECTIVE

Build a **system-wide Audit Ledger** that provides:

* Append-only, tamper-evident recording
* Cryptographically signed entries
* Full chain-of-custody for **every security-relevant action**
* Deterministic verification and export
* Court / compliance-grade integrity

This ledger becomes the **root of trust** for RansomEye.

---

## SCOPE (MANDATORY)

The Audit Ledger MUST record **at minimum**:

1. Installer actions (Core, Agents, DPI)
2. Service lifecycle events (start, stop, crash, restart)
3. Policy decisions (recommendations, enforcement, simulation)
4. AI model lifecycle actions (register, promote, revoke)
5. Playbook execution (planned, executed, rolled back)
6. Forensic access (memory dump, disk artifact read)
7. Administrative actions (config change, module load/unload)

No silent actions are allowed anywhere in the system.

---

## TECHNICAL REQUIREMENTS (NON-NEGOTIABLE)

### 1. Ledger Properties

* Append-only
* Immutable after write
* Hash-chained (prev_hash → current_hash)
* Digitally signed (ed25519)
* Deterministic serialization (canonical JSON)

---

### 2. Ledger Entry Schema (MANDATORY)

Define a **frozen ledger entry schema** including:

* ledger_entry_id (UUID)
* timestamp (RFC3339 UTC)
* component (core / agent / dpi / ai / policy / etc.)
* component_instance_id
* action_type (ENUM, explicitly defined)
* subject (incident_id, model_id, playbook_id, etc.)
* actor (system / user / module)
* payload (strictly validated object)
* prev_entry_hash
* entry_hash
* signature
* signing_key_id

No optional fields.
No free-form strings without schema.

---

### 3. Storage Backend

* File-based append-only log (Phase A)
* Write-once semantics enforced
* fsync on write
* Read-only mount option supported
* No database dependency for correctness

---

### 4. Cryptography

* ed25519 keypair per installation
* Private key:

  * Generated at install time
  * Never logged
  * Never exported
* Public key:

  * Exportable
  * Used for verification
* Key rotation supported (with ledger continuity)

---

### 5. Verification Tool (MANDATORY)

Build a **ledger verification CLI** that:

* Replays entire ledger
* Verifies:

  * Hash chain integrity
  * Signature validity
  * Schema correctness
  * Ordering guarantees
* Produces:

  * PASS / FAIL
  * Failure location
* Exports signed verification report (JSON)

---

### 6. Integration Contract (CRITICAL)

* Define a **single, minimal append API**
* Existing components will call this later
* For this phase:

  * Build API + stubs
  * Do NOT modify existing services yet

---

## REQUIRED OUTPUT STRUCTURE

```
/audit-ledger/
  schema/
    ledger-entry.schema.json
  crypto/
    key_manager.py
    signer.py
    verifier.py
  storage/
    append_only_store.py
  cli/
    verify_ledger.py
    export_ledger.py
  README.md
```

---

## README MUST EXPLICITLY DOCUMENT

* Threat model
* Tamper-evidence guarantees
* Key management model
* Failure semantics (fail-closed)
* How verification works
* Legal / compliance positioning

---

## PASS / FAIL CRITERIA

PASS only if:

* Ledger entries cannot be modified or deleted
* Any tampering is detected by verifier
* Hash chain breaks are detected
* Signature failures are detected
* Verification is deterministic
* No dependency on database or network

FAIL if:

* Ledger allows mutation
* Any field is optional
* Any action is not representable
* Verification relies on trust assumptions

---

## DELIVERABLE EXPECTATION

Produce **full production-grade code**, schemas, and documentation.

Do NOT summarize.
Do NOT explain design verbally.
**Build the Audit Ledger subsystem only.**

****promot end****


****Promot Start****

You are continuing **RansomEye — Enterprise & Military-Grade Platform Expansion**.

This is **PHASE A2 (FOUNDATIONAL, NON-OPTIONAL)**.

No other work is allowed until this phase is fully complete, validated, and frozen.

---

# WORK UNIT A2 — GLOBAL VALIDATOR (SYSTEM ASSURANCE & PROVABLE CORRECTNESS)

## ABSOLUTE CONTEXT (DO NOT VIOLATE)

* ❌ NO modification to existing v1.0 Core, Agents, DPI, installers, or Audit Ledger code
* ❌ NO retrofitting logic into existing services
* ❌ NO mocks, placeholders, synthetic shortcuts, or “best-effort” checks
* ❌ NO network dependency for correctness (offline-capable)
* ❌ NO database dependency for correctness (file-based, deterministic)

This phase **adds a new assurance subsystem only**.

---

## OBJECTIVE

Build the **Global Validator**, a deterministic assurance engine that:

* Proves end-to-end system integrity
* Validates chain-of-custody across Core, Agents, DPI
* Simulates attacks without altering production state
* Produces **signed, auditable compliance reports**
* Consumes the **Audit Ledger as the root of truth**

This subsystem is the **final authority** on whether a deployment is trustworthy.

---

## SCOPE (MANDATORY)

The Global Validator MUST be able to validate:

1. **Audit Ledger Integrity**

   * Full replay
   * Hash-chain + signature verification
   * Key continuity (including rotation events)

2. **Installer & Binary Integrity**

   * Hash verification of installed artifacts
   * Match against release checksums
   * Detect drift or tampering

3. **Configuration Integrity**

   * Detect unauthorized config changes
   * Validate config hash entries against ledger

4. **Chain-of-Custody**

   * From ingest → correlation → AI → policy → response
   * Every step must have a corresponding ledger entry
   * No gaps, no silent transitions

5. **Subsystem Disablement Correctness**

   * Prove system correctness when:

     * AI disabled
     * Policy disabled
     * UI disabled
   * Evidence must exist in ledger

6. **Synthetic Attack Simulation (NON-DESTRUCTIVE)**

   * Deterministic simulated ransomware scenario
   * No real system mutation
   * Simulation actions MUST be recorded in ledger
   * Must validate detection + response paths

---

## TECHNICAL REQUIREMENTS (NON-NEGOTIABLE)

### 1. Deterministic Execution

* No randomness
* No wall-clock trust
* No sleeps
* Fixed ordering
* Same input → same output

---

### 2. Validator Inputs

The validator MUST consume:

* Audit Ledger file(s)
* Public signing keys
* Release `SHA256SUMS`
* Installed component manifests
* Configuration snapshots (read-only)

---

### 3. Validation Outputs (MANDATORY)

Validator MUST produce:

* **Signed validation report** (ed25519)
* Formats:

  * JSON (authoritative)
  * PDF (human / compliance)
  * CSV (regulatory ingestion)
* Explicit PASS / FAIL
* Failure classification:

  * Integrity breach
  * Missing ledger entry
  * Tampering detected
  * Configuration drift
  * Incomplete chain-of-custody

---

### 4. Cryptographic Discipline

* Reuse ed25519 signing model
* Separate validator signing key
* Never reuse ledger signing key
* Verification must fail if keys mismatch

---

### 5. Failure Semantics

* Fail-fast
* Fail-closed
* First failure aborts run
* Failure location explicitly reported

---

## REQUIRED OUTPUT STRUCTURE

```
/global-validator/
  schema/
    validation-report.schema.json
  crypto/
    validator_key_manager.py
    signer.py
    verifier.py
  checks/
    ledger_checks.py
    integrity_checks.py
    custody_checks.py
    config_checks.py
    simulation_checks.py
  cli/
    run_validation.py
  reports/
    render_pdf.py
    render_csv.py
  README.md
```

---

## README MUST EXPLICITLY DOCUMENT

* Assurance model & threat assumptions
* Relationship to Audit Ledger
* What PASS means legally and operationally
* What FAIL means (and required actions)
* Determinism guarantees
* How to present reports to auditors / regulators

---

## PASS / FAIL CRITERIA

PASS only if:

* Any tampering is detected deterministically
* Missing or out-of-order ledger entries are detected
* Simulation produces provable outcomes
* Signed reports verify correctly
* No dependency on Core runtime behavior

FAIL if:

* Validation can be bypassed
* Reports are unsigned
* Any check is best-effort
* Any step relies on trust assumptions

---

## DELIVERABLE EXPECTATION

Produce **full production-grade code**, schemas, and documentation.

Do NOT summarize.
Do NOT explain verbally.
**Build the Global Validator subsystem only.**

****promot end****


Promot Start

You are continuing RansomEye — Enterprise & Military-Grade Platform Expansion.

This is PHASE B1 (MANDATORY).

No other work is allowed until this phase is complete, validated, and frozen.

WORK UNIT B1 — AI MODEL REGISTRY & GOVERNANCE CORE
ABSOLUTE CONTEXT (DO NOT VIOLATE)

❌ NO modification to v1.0 Core, Agents, DPI, Audit Ledger, or Global Validator

❌ NO AI inference logic inside this module

❌ NO model execution

❌ NO online dependencies

❌ NO implicit model loading

This phase builds governance only, not intelligence.

OBJECTIVE

Build a central AI Model Registry that provides full lifecycle governance for every AI/ML/LLM model used anywhere in RansomEye.

No model may:

Be loaded

Be executed

Be referenced
without registry approval.

MANDATORY CAPABILITIES
1. Model Registry (Core)

Versioned model records

Immutable model metadata

Cryptographic hash of model artifact

Model type (ML / DL / LLM / ruleset)

Intended use (classification, clustering, summarization, etc.)

Training data provenance (hash references, not raw data)

2. Lifecycle Management (NON-OPTIONAL)

Support explicit state transitions:

REGISTERED

PROMOTED

DEPRECATED

REVOKED

Rules:

No implicit promotion

No silent revocation

Every transition MUST be written to the Audit Ledger

3. Cryptographic Discipline

Encrypted model bundle ingestion

Signature verification before registry entry

Hash verification at every load attempt

Rejection on mismatch (fail-closed)

4. Hot-Swap Governance (CONTROL PLANE ONLY)

Registry allows marking a model as “active”

No runtime loading logic yet

Consumers will query registry later

5. Drift Detection Metadata (FOUNDATION ONLY)

Schema for drift metrics

Storage of drift observations

NO detection logic yet (future phase)

REQUIRED OUTPUT STRUCTURE
/ai-model-registry/
  schema/
    model-record.schema.json
  crypto/
    bundle_verifier.py
    key_manager.py
  registry/
    registry_store.py
    lifecycle.py
  api/
    registry_api.py
  cli/
    register_model.py
    promote_model.py
    revoke_model.py
  README.md

AUDIT & VALIDATION RULES

Every registry action MUST emit an Audit Ledger entry

Global Validator MUST be able to verify:

No unregistered models exist

No revoked model is active

Registry integrity matches ledger

PASS / FAIL CRITERIA

PASS only if:

No model can exist outside registry

Lifecycle transitions are explicit and auditable

Cryptographic checks are enforced

Registry is deterministic and offline-capable

FAIL if:

Models can be loaded without registry

Any lifecycle action is silent

Any state is mutable without audit

DELIVERABLE EXPECTATION

Produce full production-grade governance code, schemas, and documentation.

Do NOT summarize.
Do NOT explain verbally.
Build the AI Model Registry only.

promot end




Promot Start

You are continuing RansomEye — Enterprise & Military-Grade Platform Expansion.

This is PHASE B2 (MANDATORY).

No other work is allowed until this phase is fully complete, validated, and frozen.

WORK UNIT B2 — ENTERPRISE RISK INDEX ENGINE
ABSOLUTE CONTEXT (DO NOT VIOLATE)

❌ NO modification to v1.0 Core, Agents, DPI

❌ NO modification to Audit Ledger, Global Validator, AI Model Registry

❌ NO UI

❌ NO alerting

❌ NO enforcement

❌ NO heuristics without justification

This phase builds risk computation only.

OBJECTIVE

Build the Enterprise Risk Index, a deterministic engine that computes a global, normalized (0–100) risk score representing the security posture of the entire enterprise.

This score is:

The single executive truth

The input to board reporting

The baseline for automation thresholds

MANDATORY CAPABILITIES
1. Signal Ingestion (READ-ONLY)

Consume signals from:

Incidents (correlation engine)

AI metadata (novelty, clusters, drift markers)

Policy decisions

Threat correlation (future)

UBA (future)

No signal mutation allowed.

2. Risk Model (DETERMINISTIC)

Weighted aggregation

Explicit weight configuration

Temporal decay functions

Confidence-aware scoring

No randomness

3. Normalization

Output strictly in range 0–100

Defined severity bands (LOW / MODERATE / HIGH / CRITICAL)

Explainable component contributions

4. Audit & Assurance

Every score computation emits:

Audit Ledger entry

Global Validator must be able to:

Recompute score deterministically

Verify no missing signals

5. Historical Tracking

Maintain historical risk timeline

Immutable records

No retroactive mutation

REQUIRED OUTPUT STRUCTURE
/risk-index/
  schema/
    risk-score.schema.json
  engine/
    aggregator.py
    decay.py
    normalizer.py
  storage/
    risk_store.py
  api/
    risk_api.py
  cli/
    compute_risk.py
  README.md

PASS / FAIL CRITERIA

PASS only if:

Same inputs always produce same score

Score is explainable

Missing signals are detected

No mutation of source data

All computations are auditable

FAIL if:

Any randomness exists

Any silent assumptions exist

Score cannot be recomputed by Global Validator

DELIVERABLE EXPECTATION

Produce full production-grade code, schemas, and documentation.

Do NOT summarize.
Do NOT explain verbally.
Build the Enterprise Risk Index only.

promot end


Promot Start

You are continuing RansomEye — Enterprise & Military-Grade Platform Expansion.

This is PHASE C1 (MANDATORY).

No other work is allowed until this phase is fully complete, validated, and frozen.

WORK UNIT C1 — KILLCHAIN & FORENSICS ENGINE
ABSOLUTE CONTEXT (DO NOT VIOLATE)

❌ NO modification to v1.0 Core, Agents, DPI

❌ NO modification to Audit Ledger, Global Validator, Model Registry, Risk Index

❌ NO UI

❌ NO automation

❌ NO alerts

❌ NO heuristics without justification

This phase builds evidence-grade correlation only.

OBJECTIVE

Build the KillChain & Forensics Engine that reconstructs full adversary timelines across hosts, users, processes, and network activity — with court-admissible evidence handling.

MANDATORY CAPABILITIES
1. MITRE ATT&CK Timeline Reconstruction

Map events to MITRE techniques

Explicit stage transitions

Ordered, immutable timeline

Cross-host stitching

2. Evidence Management (NON-OPTIONAL)

Memory dump references (not blobs)

Disk artifact references

Artifact hashing

Compression support

Secure storage indexing

3. Campaign Correlation

Link incidents across:

Hosts

Users

IPs

Malware families

Deterministic linking rules

4. Chain-of-Custody Integration

Every evidence access logged to Audit Ledger

No silent reads

Evidence integrity verification

5. Assurance Compatibility

Global Validator must be able to:

Verify timelines

Verify evidence hashes

Detect missing stages

REQUIRED OUTPUT STRUCTURE
/killchain-forensics/
  schema/
    killchain-event.schema.json
    evidence-record.schema.json
  engine/
    timeline_builder.py
    mitre_mapper.py
    campaign_stitcher.py
  evidence/
    artifact_store.py
    hasher.py
    compressor.py
  api/
    forensics_api.py
  cli/
    reconstruct_timeline.py
  README.md

PASS / FAIL CRITERIA

PASS only if:

Timelines are immutable

Cross-host correlation is deterministic

Evidence hashes verify

Chain-of-custody is complete

No evidence access is unlogged

FAIL if:

Any timeline can be mutated

Evidence integrity is assumed

MITRE mapping is ambiguous

Validator cannot replay results

DELIVERABLE EXPECTATION

Produce full production-grade code, schemas, and documentation.

Do NOT summarize.
Do NOT explain verbally.
Build the KillChain & Forensics Engine only.

promot end


Promot Start

You are continuing RansomEye — Enterprise & Military-Grade Platform Expansion.

This is PHASE C2 (MANDATORY).

No other work is allowed until this phase is fully complete, validated, and frozen.

WORK UNIT C2 — THREAT CORRELATION GRAPH ENGINE
ABSOLUTE CONTEXT (DO NOT VIOLATE)

❌ NO modification to v1.0 Core, Agents, DPI

❌ NO modification to Audit Ledger, Global Validator, Model Registry, Risk Index, KillChain & Forensics

❌ NO UI

❌ NO alerts

❌ NO automation

❌ NO heuristics without justification

This phase builds relationship intelligence only.

OBJECTIVE

Build the Threat Correlation Graph Engine that models entities and relationships across the enterprise to infer campaigns, lateral movement, and coordinated activity.

MANDATORY CAPABILITIES
1. Entity Graph (NON-OPTIONAL)

Model entities:

Host

User

Process

File

IP

Domain

Malware

Incident

Evidence artifact

Edges must be:

Typed

Directed

Timestamped

Immutable

2. Campaign Inference

Deterministic graph traversal rules

Explicit inference logic (no ML yet)

Explainable path outputs

3. Neo4j Export (MANDATORY)

Export graph to Neo4j-compatible format

No dependency on Neo4j runtime

Deterministic export

4. ML Confidence Placeholder (FOUNDATION ONLY)

Schema for confidence scores

No prediction logic yet

To be used later by ML confidence predictor

5. Assurance Integration

Every graph mutation must emit Audit Ledger entry

Global Validator must:

Rebuild graph

Verify edge completeness

Detect missing relationships

REQUIRED OUTPUT STRUCTURE
/threat-graph/
  schema/
    entity.schema.json
    edge.schema.json
  engine/
    graph_builder.py
    campaign_inference.py
  export/
    neo4j_exporter.py
  api/
    graph_api.py
  cli/
    build_graph.py
  README.md

PASS / FAIL CRITERIA

PASS only if:

Graph is immutable

Relationships are explainable

Campaign inference is deterministic

Neo4j export is lossless

Validator can rebuild graph exactly

FAIL if:

Any edge is implicit

Any inference is opaque

Graph depends on runtime state

Export loses information

DELIVERABLE EXPECTATION

Produce full production-grade code, schemas, and documentation.

Do NOT summarize.
Do NOT explain verbally.
Build the Threat Correlation Graph Engine only.

Promot end

Promot Start

You are continuing RansomEye — Military-Grade Enterprise Security Platform.

This is PHASE C3 (MANDATORY, BLOCKING).

No other subsystem may be built until this phase is complete, validated, and frozen.

WORK UNIT C3 — SYSTEM EXPLANATION ENGINE (SEE)
ABSOLUTE CONSTRAINTS

❌ NO modification to existing subsystems

❌ NO ML inference

❌ NO heuristics

❌ NO UI

❌ NO free-text generation

❌ NO assumptions

This subsystem reconstructs reasoning, it does not invent it.

OBJECTIVE

Build a System Explanation Engine that produces end-to-end, signed, validator-verifiable explanation bundles explaining why the system acted.

REQUIRED INPUT SOURCES (READ-ONLY)

Audit Ledger (root of truth)

KillChain & Forensics

Threat Correlation Graph

Risk Index Engine

Policy Engine decisions

(Later) Human Override records

REQUIRED OUTPUT
Signed Explanation Bundle

Explains:

Why an incident existed

Why a KillChain stage advanced

Why campaign inference occurred

Why risk score changed

Why policy recommendation escalated

Whether a human overrode it (if applicable)

REQUIRED STRUCTURE
/system-explainer/
  schema/
    explanation-bundle.schema.json
  engine/
    explanation_builder.py
    reasoning_reconstructor.py
  crypto/
    signer.py
    verifier.py
  api/
    explainer_api.py
  cli/
    build_explanation.py
  README.md

NON-NEGOTIABLE GUARANTEES

Deterministic

Fully reconstructable from ledger

Signed with dedicated keypair

Validator-verifiable

Immutable bundles

Zero ambiguity

PASS / FAIL

PASS only if:

Same inputs → same explanation

Explanation can be rebuilt from scratch

Validator verifies reasoning chain

No missing causal links

FAIL if:

Any step is implicit

Any reasoning is inferred without evidence

Any explanation cannot be cryptographically verified

OUTPUT EXPECTATION

Produce:

Full production code

Frozen schemas

Cryptographic signing

Documentation

No summaries.
No shortcuts.
Build the System Explanation Engine only.

promot end

Promot Start

You are continuing RansomEye — Military-Grade Enterprise Security Platform.

This is PHASE C4 (MANDATORY, BLOCKING).

No enforcement, automation, playbooks, or advanced AI may be built until this phase is complete, validated, and frozen.

WORK UNIT C4 — HUMAN AUTHORITY & OVERRIDE FRAMEWORK (HAF)
ABSOLUTE CONSTRAINTS

❌ NO UI

❌ NO workflow engine

❌ NO assumptions about humans

❌ NO implicit trust

❌ NO free-text decisions

❌ NO shared keys with other subsystems

This subsystem records authority, it does not decide policy.

OBJECTIVE

Build a Human Authority Framework that provides:

Cryptographic proof of human decisions

Explicit override semantics

Role-based authority validation

Non-repudiation

Audit-ledger anchoring

Validator-verifiable accountability

REQUIRED STRUCTURE
/human-authority/
  schema/
    authority-action.schema.json
    role-assertion.schema.json
  crypto/
    human_key_manager.py
    signer.py
    verifier.py
  engine/
    authority_validator.py
    override_processor.py
  api/
    authority_api.py
  cli/
    sign_override.py
    verify_override.py
  README.md

REQUIRED ACTION TYPES (ENUM, FROZEN)

POLICY_OVERRIDE

INCIDENT_ESCALATION

INCIDENT_SUPPRESSION

PLAYBOOK_APPROVAL

PLAYBOOK_ABORT

RISK_ACCEPTANCE

FALSE_POSITIVE_DECLARATION

No others.

REQUIRED GUARANTEES

Every human action is:

Signed with a human-specific keypair

Bound to a role assertion

Bound to a scope (incident / policy / campaign)

Recorded in Audit Ledger

Overrides are explicit, never implicit

Overrides never erase automated decisions — they supersede them

Authority is validated before acceptance

No anonymous actions

No shared keys

No revocation ambiguity

CRYPTOGRAPHIC MODEL

Per-human keypair (ed25519 or RSA-PSS, choose and justify)

Separate trust root from:

Audit Ledger

Model Registry

System Explainer

Role assertion must be signed and verifiable

Override invalid if:

Role is insufficient

Signature invalid

Scope mismatch

Timestamp invalid

PASS / FAIL

PASS only if:

A human override can be proven, reconstructed, and verified

Responsibility is unambiguous

Overrides are replayable from ledger

Validator can verify authority chain end-to-end

FAIL if:

Any decision lacks a signer

Any override lacks role proof

Any action can be denied later

Any authority is implicit

OUTPUT EXPECTATION

Produce:

Production-grade code

Frozen schemas

Cryptographic enforcement

Audit ledger integration

Deterministic validation

Complete documentation

No placeholders.
No shortcuts.
Build the Human Authority Framework only.

promot end



Promot Start

You are continuing RansomEye — Military-Grade Enterprise Security Platform.

This is PHASE D (MANDATORY).

This phase builds Incident Response, Playbooks, and Enforcement, but:

❌ No implicit execution

❌ No silent automation

❌ No unsigned actions

❌ No authority bypass

Every enforcement must be:

Explained (SEE)

Authorized (HAF)

Audited (Audit Ledger)

Verifiable (Global Validator)

WORK UNIT D1 — INCIDENT RESPONSE & PLAYBOOK ENGINE
ABSOLUTE CONSTRAINTS

Playbooks are data, not code

No shell execution

No arbitrary scripts

No runtime mutation

No background autonomy

Execution is deterministic, sandboxed, and replayable.

REQUIRED STRUCTURE
/incident-response/
  schema/
    playbook.schema.json
    playbook-step.schema.json
    execution-record.schema.json
  crypto/
    playbook_signer.py
    playbook_verifier.py
  engine/
    playbook_registry.py
    execution_engine.py
    rollback_engine.py
  api/
    ir_api.py
  cli/
    register_playbook.py
    execute_playbook.py
    rollback_playbook.py
  README.md

PLAYBOOK MODEL (STRICT)

Declarative only (JSON / YAML)

Steps are:

isolate_host

block_ip

disable_account

snapshot_memory

snapshot_disk

notify_human

No loops

No branching

No conditionals

No variables

No scripting

EXECUTION RULES

Execution requires:

Valid playbook signature

Valid authority action (HAF)

Matching scope

Explanation bundle reference

Execution emits:

Execution record

Audit ledger entry

Rollback must be:

Explicit

Signed

Logged

Sandbox enforcement:

No system calls

No network access

No privilege escalation

PASS / FAIL

PASS only if:

Playbooks are immutable

Execution is reproducible

Authority is mandatory

Rollback is provable

Validator can replay everything

FAIL if:

Any execution is unsigned

Any action is implicit

Any authority is assumed

Any step is opaque

OUTPUT EXPECTATION

Production-grade engine

Frozen schemas

Cryptographic enforcement

Audit ledger integration

Validator compatibility

Complete documentation

No placeholders.
No shortcuts.
Build Incident Response & Playbook Engine only.

promot end

Promot Start

You are continuing RansomEye — Military-Grade Enterprise Security Platform.

This is PHASE E (MANDATORY).

You are building SOC Copilot (Basic) with Offline RAG.

WORK UNIT E1 — SOC COPILOT (BASIC, READ-ONLY)
ABSOLUTE CONSTRAINTS

❌ No enforcement

❌ No policy changes

❌ No playbook execution

❌ No automation

❌ No internet access

❌ No external LLM APIs

This is assistive intelligence only.

REQUIRED STRUCTURE
/soc-copilot/
  schema/
    query.schema.json
    response.schema.json
    feedback.schema.json
  rag/
    document_ingestor.py
    vector_store.py        # FAISS
    retriever.py
  llm/
    offline_model_loader.py   # GGUF
    prompt_builder.py
  engine/
    query_engine.py
    citation_builder.py
  api/
    copilot_api.py
  cli/
    ask_soc.py
  README.md

KNOWLEDGE SOURCES (READ-ONLY)

Audit Ledger

KillChain timelines

Threat Graph

Risk Index history

Explanation bundles (SEE)

Playbook metadata (NOT execution)

MITRE ATT&CK docs (offline snapshot)

All sources must be verifiable and immutable.

REQUIRED GUARANTEES

Offline-only operation

Deterministic retrieval

No hallucinated facts

All answers must have:

Citations

Source references

Explicit uncertainty allowed ("insufficient data")

Analyst feedback is stored but:

Does NOT alter models

Is bundled for later retraining

OUTPUT RULES

Structured answers (not free prose)

Confidence level per answer

Explicit source list

No decision language

No recommendations phrased as commands

PASS / FAIL

PASS only if:

Copilot answers are reproducible

All claims are cited

No enforcement possible

Validator can replay answers

FAIL if:

Any hallucination

Any hidden inference

Any implicit recommendation

Any mutable knowledge source

OUTPUT EXPECTATION

Production-grade offline SOC copilot

Frozen schemas

Deterministic RAG

FAISS-backed vector store

GGUF LLM loader

Audit-safe feedback loop

Complete documentation

No shortcuts.
No cloud dependencies.
Build SOC Copilot (Basic) only.

promot end
