*****Promot Start*****

You are working on **RansomEye v1.0 – Clean-Room Rebuild**.

**STRICT CONTEXT (READ CAREFULLY):**

* This is a **clean-room rebuild**. Assume **zero prior code exists**.
* You are in **Phase 1 – System Contracts**.
* **NO SERVICE CODE IS ALLOWED**.
* **NO INSTALLER CODE**.
* **NO DATABASE CODE**.
* Output must be **contracts only**.
* If you feel tempted to “prepare for later” or “add convenience”, **do not**.

---

## OBJECTIVE OF THIS PROMPT

Define the **canonical, immutable system contracts** for RansomEye v1.0.

These contracts will be frozen and **every future component must conform to them**.
If any later code violates these contracts, the code will be deleted.

---

## SCOPE (MUST DELIVER ALL)

Produce **ONLY** the following artifacts:

### 1. Canonical Event Envelope (AUTHORITATIVE)

Deliver:

* JSON Schema (Draft 2020-12)
* Protobuf definition

The envelope **must exactly contain** the following fields (no more, no less):

```json
{
  "event_id": "uuid",
  "machine_id": "string",
  "component": "linux_agent | windows_agent | dpi | core",
  "component_instance_id": "string",
  "observed_at": "RFC3339 UTC",
  "ingested_at": "RFC3339 UTC",
  "sequence": "monotonic_uint64",
  "payload": {},
  "identity": {
    "hostname": "string",
    "boot_id": "string",
    "agent_version": "string"
  },
  "integrity": {
    "hash_sha256": "string",
    "prev_hash_sha256": "string | null"
  }
}
```

Rules:

* **No optional fields**
* **No defaults**
* **No extensions**
* `payload` is opaque but must be typed correctly
* `component` must be an enum
* Timestamps must be strictly validated

---

### 2. Time Semantics Contract (TEXT + MACHINE-READABLE)

Define **explicit, enforceable rules** for:

* `observed_at`
* `ingested_at`
* Clock skew tolerance
* Out-of-order arrival
* Late arrival
* Duplicate arrival

Deliverables:

* Human-readable spec (Markdown)
* Machine-readable policy (JSON)

---

### 3. Failure Semantics Contract (MANDATORY)

Define **explicit behavior** for each component when:

* No events are received
* Events arrive late
* Events are duplicated
* Dependencies are unavailable
* Integrity chain breaks
* Schema validation fails

Rules:

* **Silence is forbidden**
* Every failure must result in:

  * Explicit state
  * Explicit log classification
  * Explicit downstream behavior

Deliverable:

* Structured failure matrix (Markdown table)
* Machine-readable failure policy (JSON)

---

### 4. Contract Bundle Metadata

Produce:

* Contract bundle version
* SHA256 hash placeholder (document where hash will be inserted later)
* Compatibility rules (breaking vs non-breaking)
* Freeze statement (immutable once approved)

---

## OUTPUT FORMAT (MANDATORY)

Return output in this **exact structure**:

```
/contracts/
  event-envelope.schema.json
  event-envelope.proto
  time-semantics.md
  time-semantics.policy.json
  failure-semantics.md
  failure-semantics.policy.json
  CONTRACT_BUNDLE.md
```

Each file must be fully written.

---

## HARD RULES (NON-NEGOTIABLE)

* ❌ Do NOT write code
* ❌ Do NOT reference databases
* ❌ Do NOT reference installers
* ❌ Do NOT reference paths
* ❌ Do NOT reference systemd
* ❌ Do NOT invent future fields
* ❌ Do NOT optimize for convenience

This is a **military-grade contract freeze**, not a draft.

If anything is ambiguous, **make it explicit**.
If something can fail, **define how it fails**.

---

Begin immediately.

*****Prompt End*****


*****Promot Start*****

You are continuing **RansomEye v1.0 – Clean-Room Rebuild**.

**STRICT CONTEXT (DO NOT VIOLATE):**

* Phase 1 (System Contracts) is **COMPLETE and FROZEN**.
* You are now entering **PHASE 2 — DATABASE FIRST**.
* **NO SERVICE CODE IS ALLOWED**.
* **NO INSTALLER CODE**.
* **NO AGENT / DPI CODE**.
* **NO UI CODE**.
* Database design is **authoritative**; future code must conform to it.
* If schema changes later without migration + version bump, the schema is invalid.

---

## OBJECTIVE OF THIS PROMPT

Design the **authoritative, production-grade database schema** for **RansomEye v1.0**, aligned **exactly** to the frozen system contracts and threat model.

This schema must support:

* Linux Agent
* Windows Agent
* DPI Probe
* Ingest
* Correlation Engine
* AI Core (read-only metadata)
* SOC UI (read-only views)

---

## HARD DATABASE PHILOSOPHY (NON-NEGOTIABLE)

* Schema is **not derived from code**
* Code will adapt to schema, not the reverse
* No dynamic columns
* No JSON blobs for core facts (JSON only where explicitly justified)
* Machine-first modeling (host-centric, not event-centric)
* Time-indexed everywhere
* Immutable primary keys
* Explicit foreign keys
* Deterministic querying

---

## SCOPE (MUST DELIVER ALL)

### 1. Core Identity Tables

Define tables for:

* Machines / Hosts
* Components (agent / dpi instances)
* Component identity history (version, boot_id)

Must align with:

* `machine_id`
* `component`
* `component_instance_id`
* `identity.*` fields from the event envelope

---

### 2. Event Storage Model (RAW + NORMALIZED)

Design:

* **Raw event storage** (exact envelope preservation)
* **Normalized tables** for:

  * Process activity
  * File activity
  * Persistence
  * Network intent (agent-side)
  * DPI-derived flows
  * DNS
  * Deception
  * Health / heartbeat

Rules:

* Raw events are immutable
* Normalized tables are query-optimized
* Every normalized row must reference its raw event

---

### 3. Integrity & Ordering

Schema must explicitly support:

* Event hash chains
* Sequence monotonicity per component instance
* Duplicate detection
* Gap detection

No inference in code — DB must support this natively.

---

### 4. Correlation & Incident Tables

Define tables for:

* Incidents
* Incident stages (Clean → Suspicious → Probable → Confirmed)
* Confidence accumulation
* Evidence linkage (event → incident)

Rules:

* One event can contribute to multiple incidents
* Incident state transitions must be auditable
* No deletion of incident history

---

### 5. AI / ML Metadata Tables (READ-ONLY)

Define tables for:

* Feature vectors (references only)
* Clusters
* Novelty scores
* SHAP explanations (references, not blobs)

Rules:

* AI NEVER writes facts
* AI NEVER mutates incidents
* Metadata only, versioned

---

### 6. Indexing, Partitioning & Retention

For every table:

* Primary key
* Foreign keys
* Mandatory indexes
* Time partitioning strategy
* Retention policy (hot / warm / cold)

No hand-waving. Be explicit.

---

### 7. Schema Freeze Artifacts

Produce:

* Versioned schema definition (DDL)
* Schema hash placeholder
* Migration rules (what constitutes breaking vs non-breaking)
* Explicit freeze statement

---

## OUTPUT FORMAT (MANDATORY)

Return output in this **exact structure**:

```
/schemas/
  00_core_identity.sql
  01_raw_events.sql
  02_normalized_agent.sql
  03_normalized_dpi.sql
  04_correlation.sql
  05_ai_metadata.sql
  06_indexes.sql
  07_retention.sql
  SCHEMA_BUNDLE.md
```

* SQL must be **PostgreSQL 14+ compatible**
* Use `UUID`, `TIMESTAMPTZ`, `JSONB` only where justified
* Every file must be complete and executable

---

## HARD RULES (DO NOT BREAK)

* ❌ No assumptions about paths
* ❌ No assumptions about deployment size
* ❌ No sample data
* ❌ No test data
* ❌ No service logic
* ❌ No shortcuts for “later optimization”

This schema must survive:

* Zero data
* One event
* Partial failure
* Adversarial input
* Multi-year growth

---

Begin immediately.
Do not explain — **design**.

*****Prompt End*****

Promot Start

You are continuing RansomEye v1.0 – Clean-Room Rebuild.

PHASE: 3 — INSTALLER BEFORE SERVICES
PREVIOUS PHASES COMPLETE:

Phase 1: System Contracts (Frozen)

Phase 2: Database Schema (Frozen)

STRICT RULES (NON-NEGOTIABLE)

❌ No service code

❌ No agent code

❌ No DPI code

❌ No database schema changes

❌ No systemd unit files yet

❌ No hardcoded paths

❌ No assumptions about install location

This installer must support commercial self-installation at any path.

ALLOWED LANGUAGES ONLY

Bash

Python 3.10+

No other languages permitted.

OBJECTIVE

Design the authoritative unified installer specification for RansomEye v1.0.

The installer is responsible for:

Discovering install root

Creating system user

Generating manifest

Injecting paths via ENV

Enforcing fail-closed startup

SCOPE (MUST DELIVER ALL)
1. Installation Manifest (AUTHORITATIVE)

Define a machine-readable manifest that contains:

Install root (absolute)

Data directories

Log directories

Binary directories

Config directories

Runtime UID/GID

Enabled components

Schema bundle hash

Contract bundle hash

Deliver:

install.manifest.schema.json

Example install.manifest.json (NO PATH ASSUMPTIONS, use placeholders)

2. Environment Variable Contract

Define EXACT ENV VARS that every service must read:

Paths

IDs

Versions

Runtime identity

Deliver:

env.contract.md

env.contract.json

No service may compute paths internally.

3. Privilege Model

Define:

Installer privilege requirements

Runtime privilege drop rules

Agent/DPI exception boundaries

Deliver:

privilege-model.md

4. Failure Semantics (Installer-Specific)

Define:

What causes install abort

What is recoverable

What is fatal

Rollback rules

Deliver:

installer-failure-policy.md

installer-failure-policy.json

OUTPUT FORMAT (MANDATORY)
/installer/
  install.manifest.schema.json
  install.manifest.json
  env.contract.md
  env.contract.json
  privilege-model.md
  installer-failure-policy.md
  installer-failure-policy.json
  INSTALLER_BUNDLE.md

HARD REQUIREMENTS

Installer must be idempotent

Installer must be fail-closed

Installer must leave zero partial state

All paths are injected, never inferred

Manifest is the single source of runtime truth

This installer defines how RansomEye exists on disk.

Begin immediately.
Do not explain — design.

Prompt End


Promot Start

You are continuing RansomEye v1.0 – Clean-Room Rebuild.

PHASE: 4 — MINIMAL DATA PLANE (ONE EVENT)

PREVIOUS PHASES (FROZEN):

Phase 1: System Contracts

Phase 2: Database Schema

Phase 3: Installer Contracts

HARD RULES (NON-NEGOTIABLE)

❌ No correlation engine

❌ No AI / ML / LLM

❌ No enrichment

❌ No heuristics

❌ No retries

❌ No buffering

❌ No background threads

❌ No filesystem/process monitoring

❌ No installer code

❌ No schema changes

❌ No contract changes

This phase exists only to prove:

One valid event → validated → stored → queryable

COMPONENT 1 — LINUX AGENT (MINIMAL)
Allowed Language

Rust only

Responsibilities (ONLY)

Read environment variables defined in env.contract.json

Construct exact canonical event envelope

Populate:

event_id

machine_id

component = linux_agent

component_instance_id

observed_at

sequence = 1

identity.*

integrity.hash_sha256

payload may contain one dummy key/value (explicitly allowed for this phase)

Transmit event to Ingest over HTTP

Forbidden

No local persistence

No retries

No batching

No enrichment

No inference

Deliver:

Minimal Rust binary

Clear module structure

Inline comments explaining contract compliance

COMPONENT 2 — INGEST SERVICE (MINIMAL)
Allowed Language

Python 3.10+ only

Responsibilities (ONLY)

Accept event via HTTP

Validate against:

event-envelope.schema.json

time-semantics.policy.json

Verify hash integrity

Detect duplicates (event_id + sequence)

Write to:

machines

component_instances

raw_events

event_validation_log

Forbidden

No correlation

No enrichment

No retry logic

No background jobs

No AI

No assumptions

OUTPUT FORMAT (MANDATORY)
/services/
  linux-agent/
    src/
    Cargo.toml
    README.md

  ingest/
    app/
    requirements.txt
    README.md


Each README must explain:

What this component does

What it explicitly does NOT do

How it proves Phase 4 correctness

VALIDATION CRITERIA (PASS / FAIL)

PASS only if:

One event is accepted

One row exists in raw_events

Hash chain is valid

No other tables are touched

Restarting ingest does NOT duplicate data

FAIL if:

Anything “helpful” is added

Any future logic leaks in

Begin immediately.
Do not explain — implement exactly.

Prompt End


Promot Start

You are continuing RansomEye v1.0 – Clean-Room Rebuild.

PHASE: 5 — CORRELATION ENGINE (DETERMINISTIC)

PREVIOUS PHASES (FROZEN):

Phase 1: System Contracts

Phase 2: Database Schema

Phase 3: Installer Contracts

Phase 4: Minimal Data Plane

HARD RULES (NON-NEGOTIABLE)

❌ No AI / ML / LLM

❌ No time-window dependency

❌ No probabilistic logic

❌ No heuristics

❌ No enrichment

❌ No retries

❌ No background threads

❌ No async

❌ No schema changes

❌ No contract changes

This engine must be purely deterministic.

OBJECTIVE

Implement the minimal deterministic correlation engine that:

Consumes validated events

Applies explicit contradiction rules

Produces at most one incident per event

INPUT

Read from:

raw_events

Normalized tables (if required)

Use only persisted facts

DETECTION MODEL (MINIMAL)

For this phase, define exactly ONE rule:

If a Linux Agent event exists with component = linux_agent,
THEN:

Either create zero incidents, OR

Create exactly one incident with:

stage = Suspicious

confidence = deterministic constant (e.g. 0.3)

No additional logic is allowed.

INCIDENT REQUIREMENTS

When an incident is created:

Insert into incidents

Insert initial stage into incident_stages

Link triggering event in evidence

All writes must be atomic (single transaction)

OUTPUT FORMAT (MANDATORY)
/services/
  correlation-engine/
    app/
      main.py
      rules.py
      db.py
    requirements.txt
    README.md

README MUST EXPLICITLY STATE

What rules exist

Why rules are deterministic

What this engine does NOT do

Why time is NOT required for correctness

VALIDATION (PASS / FAIL)

PASS only if:

One event → ≤ 1 incident

Restarting engine does NOT duplicate incidents

No time-window logic exists

No ML/AI imports exist

No retries or background jobs exist

FAIL if:

Engine waits for more data

Engine uses time windows

Engine attempts “confidence tuning”

Begin immediately.
Do not explain — implement exactly.

Prompt End


Promot Start

You are continuing RansomEye v1.0 – Clean-Room Rebuild.

PHASE: 6 — AI CORE (READ-ONLY, NON-BLOCKING)

PREVIOUS PHASES (FROZEN):

Phase 1: System Contracts

Phase 2: Database Schema

Phase 3: Installer Contracts

Phase 4: Minimal Data Plane

Phase 5: Deterministic Correlation Engine

HARD RULES (NON-NEGOTIABLE)

❌ AI must NOT create incidents

❌ AI must NOT modify incidents

❌ AI must NOT block pipeline

❌ AI must NOT require real-time inference

❌ AI must NOT be in data plane

❌ No deep learning

❌ No retries

❌ No background schedulers

❌ No schema changes

❌ No contract changes

The system must remain fully correct if AI is disabled.

OBJECTIVE

Implement the minimal AI Core that operates in read-only advisory mode.

The AI Core must:

Consume existing incidents

Perform offline, batch analysis

Produce metadata only

AI FUNCTIONS (MINIMAL, REQUIRED)

Implement exactly three capabilities:

1. Feature Extraction (Deterministic)

Derive numeric features from:

incident confidence

incident stage

evidence count

Persist feature vector references only

2. Unsupervised Clustering

Use scikit-learn (e.g., KMeans or DBSCAN)

Cluster incidents

Persist:

cluster_id

model_version

incident ↔ cluster mapping

3. Explainability (SHAP)

Generate SHAP explanations for:

confidence contribution

evidence contribution

Store references only, not raw arrays

OUTPUT FORMAT (MANDATORY)
/services/
  ai-core/
    app/
      main.py
      feature_extraction.py
      clustering.py
      shap_explainer.py
      db.py
    requirements.txt
    README.md

README MUST EXPLICITLY STATE

AI is read-only

AI cannot block or decide

AI output is advisory only

System remains correct without AI

VALIDATION (PASS / FAIL)

PASS only if:

Incidents are unchanged

Only AI metadata tables are written

Disabling AI has zero impact on detection

SHAP output is generated per run

Models are versioned and reproducible

FAIL if:

AI touches facts

AI alters incident state

AI introduces timing dependency

AI blocks pipeline

Begin immediately.
Do not explain — implement exactly.

Prompt End


Promot Start

You are continuing RansomEye v1.0 – Clean-Room Rebuild.

PHASE: 7 — POLICY ENGINE (SIMULATION-FIRST)

PREVIOUS PHASES (FROZEN):

Phase 1: System Contracts

Phase 2: Database Schema

Phase 3: Installer Contracts

Phase 4: Minimal Data Plane

Phase 5: Deterministic Correlation Engine

Phase 6: AI Core (Read-Only)

HARD RULES (NON-NEGOTIABLE)

❌ No automatic enforcement

❌ No agent execution

❌ No incident modification

❌ No AI / ML / LLM

❌ No background schedulers

❌ No async

❌ No schema changes

❌ No contract changes

Policy Engine operates in SIMULATION MODE BY DEFAULT.

OBJECTIVE

Implement the minimal Policy Engine that:

Consumes existing incidents

Evaluates explicit policy rules

Produces policy decisions and simulations

Signs commands without executing them

POLICY MODEL (MINIMAL)

Define exactly ONE policy rule:

IF incident.stage == SUSPICIOUS
THEN recommend action: ISOLATE_HOST

Rules:

Recommendation only

No execution

Deterministic (no time, no probability)

COMMAND MODEL

When a policy decision is made:

Generate a command payload:

command_type

target_machine_id

incident_id

issued_at

Cryptographically sign the command

Store signed command in DB

DO NOT send to agents

OUTPUT FORMAT (MANDATORY)
/services/
  policy-engine/
    app/
      main.py
      rules.py
      signer.py
      db.py
    requirements.txt
    README.md

README MUST EXPLICITLY STATE

Policy is simulation-first

No commands are executed

Enforcement is disabled by default

All commands are signed and auditable

System correctness does not depend on policy engine

VALIDATION (PASS / FAIL)

PASS only if:

Incidents are unchanged

Policy decisions are recorded

Signed commands are generated

No enforcement occurs

Disabling policy engine has zero impact

FAIL if:

Any command is executed

Any agent is contacted

Incident state is modified

Enforcement occurs implicitly

Begin immediately.
Do not explain — implement exactly.

Prompt End



Promot Start

You are continuing RansomEye v1.0 – Clean-Room Rebuild.

PHASE: 8 — SOC UI (READ-ONLY)

PREVIOUS PHASES (FROZEN):

Phase 1: System Contracts

Phase 2: Database Schema

Phase 3: Installer Contracts

Phase 4: Minimal Data Plane

Phase 5: Correlation Engine

Phase 6: AI Core (Read-Only)

Phase 7: Policy Engine (Simulation-First)

HARD RULES (NON-NEGOTIABLE)

❌ UI must NOT write to DB

❌ UI must NOT query base tables

❌ UI must NOT infer state

❌ UI must NOT trigger actions

❌ UI must NOT contain policy logic

❌ UI must NOT contain AI logic

❌ No schema changes

❌ No contract changes

UI is OBSERVATIONAL ONLY.

OBJECTIVE

Implement the minimal SOC UI that provides read-only visibility into system state.

REQUIRED DB VIEWS (MUST DEFINE)

Define READ-ONLY SQL VIEWS for:

v_active_incidents

incident_id

machine_id

stage

confidence

created_at

v_incident_timeline

incident_id

stage

transitioned_at

v_incident_evidence_summary

incident_id

evidence_count

v_policy_recommendations

incident_id

recommended_action

simulation_mode

created_at

v_ai_insights

incident_id

cluster_id

novelty_score

shap_summary

UI FEATURES (MINIMAL)
Dashboards

Incident list (from v_active_incidents)

Incident detail view:

Timeline

Evidence count

AI insights

Policy recommendations

Constraints

No edits

No buttons that execute actions

No “acknowledge”, “resolve”, or “close”

OUTPUT FORMAT (MANDATORY)
/services/
  ui/
    backend/
      main.py
      views.sql
      requirements.txt
    frontend/
      src/
      package.json
      README.md
    README.md

README MUST EXPLICITLY STATE

UI is read-only

UI does not affect pipeline

UI reads from DB views only

System correctness is independent of UI

VALIDATION (PASS / FAIL)

PASS only if:

UI reads ONLY from views

UI cannot modify data

UI can be disabled without impact

No table writes exist

FAIL if:

Any DB write exists

Any base table is queried

Any action can be triggered

Begin immediately.
Do not explain — implement exactly.

Prompt End


Promot Start

You are continuing RansomEye v1.0 – Clean-Room Rebuild.

PHASE: 9 — VALIDATION HARNESS (WRITTEN FIRST)

PREVIOUS PHASES (FROZEN):

Phase 1: System Contracts

Phase 2: Database Schema

Phase 3: Installer Contracts

Phase 4: Minimal Data Plane

Phase 5: Correlation Engine

Phase 6: AI Core (Read-Only)

Phase 7: Policy Engine (Simulation-First)

Phase 8: SOC UI (Read-Only)

HARD RULES (NON-NEGOTIABLE)

❌ No service logic

❌ No mocks of core logic

❌ No sleeps / timing hacks

❌ No randomness

❌ No skipping failures

❌ No schema changes

❌ No contract changes

Validation must assert real system behavior.

OBJECTIVE

Implement the authoritative validation harness that proves end-to-end correctness of RansomEye v1.0.

VALIDATION CASES (ALL REQUIRED)

Implement tests for:

Cold start correctness

Zero-event correctness

One-event correctness

Duplicate event handling

Failure semantics enforcement

Subsystem disablement (AI, Policy, UI)

Each test must:

Set up environment

Execute scenario

Assert DB state

Assert logs / exit codes

Clean up

OUTPUT FORMAT (MANDATORY)
/validation/
  harness/
    test_cold_start.py
    test_zero_event.py
    test_one_event.py
    test_duplicates.py
    test_failure_semantics.py
    test_subsystem_disablement.py
  README.md

README MUST EXPLICITLY STATE

What is validated

Why failures block release

How to run validation

Determinism guarantees

PASS / FAIL CRITERIA

PASS only if:

All tests pass consistently

Results are deterministic

System is left clean

No silent failures exist

FAIL if:

Any nondeterminism

Any skipped test

Any silent error

Begin immediately.
Do not explain — implement exactly.

Prompt End


Promot Start

You are continuing RansomEye v1.0 – Clean-Room Rebuild.

PHASE: 9.1 — VALIDATION HARDENING (MANDATORY CORRECTION)

HARD RULES (NON-NEGOTIABLE)

❌ NO synthetic events

❌ NO fabricated UUIDs

❌ NO prebuilt payloads

❌ NO fixed timestamps

❌ NO dummy data of any kind

Validation must observe real system behavior only.

OBJECTIVE

Refactor the existing Phase 9 validation harness to meet military-grade forensic correctness.

REQUIRED CHANGES
1. Linux Agent–Driven Validation

Validation must:

Launch the real Linux Agent binary

Wait for agent to emit one real event

Observe resulting DB state

No manual event construction allowed.

2. Replace Fixed Assertions

Replace:

Fixed UUID checks

Fixed timestamp checks

With:

Structural assertions

Cardinality assertions

Contract compliance assertions

Integrity chain verification

3. Policy & AI Validation Tightening

Validation must:

Verify signed command exists

Verify signature cryptographically

Verify command was not executed

Verify AI metadata exists or not, without inspecting content

OUTPUT

Modify only files under:

/validation/harness/


No schema changes.
No service changes.
No contract changes.

PASS CRITERIA

PASS only if:

Validation uses real agents

No synthetic data exists

All assertions are observational

Results remain deterministic

System remains clean

Begin immediately.
Do not explain — fix it.

Prompt End



Promot Start*

You are continuing RansomEye v1.0 – Clean-Room Rebuild.

PHASE: 10.1 — CORE RUNTIME HARDENING (STARTUP & SHUTDOWN)

STRICT CONTEXT (DO NOT VIOLATE)

You are hardening RansomEye Core, not individual services.

Ingest, Correlation, AI Core, Policy Engine, UI Backend run inside one Core runtime.

❌ NO systemd files

❌ NO standalone service assumptions

❌ NO new features

❌ NO retries

❌ NO schema or contract changes

OBJECTIVE (ONLY THIS)

Harden startup and shutdown behavior for RansomEye Core components.

COMPONENTS IN SCOPE

Inside Core:

Ingest

Correlation Engine

AI Core

Policy Engine

UI Backend

Treat them as modules, not services.

REQUIRED HARDENING (IMPLEMENT ALL)
1. Startup Validation (MANDATORY)

On Core startup:

Validate all required environment variables

Validate DB connectivity

Validate schema presence

Validate write permissions where applicable

Validate read-only enforcement where applicable

If ANY check fails:

Log explicit error

Exit process immediately (non-zero)

2. Fail-Fast Invariants

Add invariant checks that terminate Core immediately if violated:

Missing env var

DB connection failure

Schema mismatch

Unauthorized write attempt (read-only module)

Duplicate incident creation attempt

No recovery. No retry.

3. Graceful Shutdown

On SIGTERM / SIGINT:

Stop accepting new work

Finish in-flight DB transactions

Close DB connections cleanly

Exit cleanly with log confirmation

OUTPUT CONSTRAINTS

Modify existing Core code only

Do NOT create new processes

Do NOT introduce background schedulers

Do NOT add retries

Do NOT add systemd files

Each modified Core module must update its README with a new section:

Operational Hardening Guarantees
PASS CRITERIA

PASS only if:

Core fails immediately on bad config

Core shuts down cleanly

No partial state possible

No retries hide failures

Begin immediately.
Do not explain.
Implement only what is asked.

Promot end*


Promot Start*

You are continuing RansomEye v1.0 – Enterprise & Military-Grade Build.

WORK UNIT: Database Hardening & Transaction Safety
(Do NOT use phase numbers anywhere)

STRICT CONTEXT (DO NOT VIOLATE)

This applies to RansomEye Core database usage

Core runs as one unified runtime

❌ No schema changes

❌ No contract changes

❌ No retry loops

❌ No silent fallbacks

❌ No per-module DB ownership confusion

OBJECTIVE (ONLY THIS)

Harden all database interactions to ensure:

Atomicity

Consistency

Explicit failure behavior

Zero partial state

Deterministic outcomes under failure

COMPONENTS IN SCOPE (CORE)

Ingest

Correlation Engine

AI Core

Policy Engine

UI Backend (read-only)

REQUIRED HARDENING (IMPLEMENT ALL)
1. Transaction Discipline (MANDATORY)

For every DB write path:

Explicit transaction begin

Explicit commit on success

Explicit rollback on failure

No implicit autocommit behavior

If rollback fails → terminate Core.

2. Isolation & Consistency

Explicitly set isolation level at connection creation

Log isolation level at startup

Reject runtime if isolation cannot be enforced

3. Deadlock & Integrity Detection

Detect and fail fast on:

Serialization failures

Deadlocks

Foreign-key violations

Unique-constraint violations

No retries.
Log → terminate.

4. Connection Safety

Validate connection health before each critical operation

Detect dropped connections

Fail immediately on broken connection

No reconnection loops

5. Read-Only Enforcement (UI & AI)

Explicitly open read-only DB sessions

Abort process if write attempt occurs

Log security-grade error

OUTPUT CONSTRAINTS

Modify existing DB access layers only

No new abstractions unless required for safety

No background workers

No schedulers

Each modified component must update its README:

Database Safety & Transaction Guarantees
PASS CRITERIA

PASS only if:

No partial writes possible

All failures are explicit and fatal

Isolation level is enforced and logged

Read-only violations terminate immediately

System behavior is deterministic under DB failure

Begin immediately.
Do not explain.
Do not refactor unrelated code.
Harden the database interactions only.

Promot end*




Promot Start*

You are continuing RansomEye v1.0 – Enterprise & Military-Grade Build.

WORK UNIT: Database Safety Completion (AI Core, Policy Engine, UI Backend)

STRICT CONTEXT (DO NOT VIOLATE)

Database schema is frozen

Contracts are frozen

Core runs as one unified runtime

❌ No retries

❌ No silent failures

❌ No best-effort fallbacks

❌ No new abstractions beyond existing common/db/safety.py

OBJECTIVE (ONLY THIS)

Complete database hardening for remaining Core modules using the existing safety utilities.

COMPONENT-SPECIFIC REQUIREMENTS
1. AI Core

File:
services/ai-core/app/db.py

Required changes:

All read paths must use create_readonly_connection()

All write paths must use execute_write_operation()

Enforce isolation level

Abort Core on:

Deadlock

Integrity violation

Unauthorized write attempt

2. Policy Engine

File:
services/policy-engine/app/db.py

Required changes:

Use read-only connections only

Enforce read-only mode explicitly

Abort Core if any write is attempted

Policy Engine must never write to DB.

3. UI Backend

File:
services/ui/backend/main.py

Required changes:

Enforce read-only DB connections at pool level

Ensure query_view() cannot execute writes

Any write attempt → immediate Core termination

4. Documentation (MANDATORY)

Update README for:

AI Core

Policy Engine

UI Backend

Add section:

Database Safety & Transaction Guarantees

Must explicitly state:

Isolation level enforcement

Explicit transaction behavior

Read-only enforcement (where applicable)

Fail-fast semantics

No retries, no partial state

No fluff. No marketing.

PASS CRITERIA

PASS only if:

AI Core writes are fully transaction-safe

Policy Engine cannot write under any condition

UI Backend is read-only by construction

Any DB misuse terminates Core

All READMEs updated correctly

Begin immediately.
Do not refactor unrelated code.
Do not summarize.
Finish database hardening cleanly.

Promot end*




Promot Start*

You are continuing RansomEye v1.0 – Enterprise & Military-Grade Build.

WORK UNIT: Resource & Disk Safety Hardening

STRICT CONTEXT (DO NOT VIOLATE)

Applies to RansomEye Core runtime

Core runs as one unified process

❌ No schema changes

❌ No contract changes

❌ No retries

❌ No background schedulers

❌ No new features

This is safety hardening only.

OBJECTIVE (ONLY THIS)

Harden Core against resource exhaustion and disk failures so the system fails explicitly and safely, never silently.

COMPONENTS IN SCOPE (CORE)

Ingest

Correlation Engine

AI Core

Policy Engine

UI Backend

REQUIRED HARDENING (IMPLEMENT ALL)
1. Disk Safety (MANDATORY)

Implement explicit checks and fail-fast behavior for:

Disk full conditions

Permission denied (logs, temp, runtime dirs)

Read-only filesystem

Rules:

Detect error at write attempt

Log explicit error

Terminate Core immediately

No retries, no degradation

2. Log Safety

Prevent unbounded log growth

Enforce size limits or rotation without losing critical errors

If logging fails → terminate Core (fail-fast)

No silent logging failures.

3. File Descriptor & Resource Limits

Detect exhaustion of file descriptors

Detect inability to open files/sockets

Fail fast with explicit error

4. Memory Safety (BASIC, NOT OPTIMIZATION)

Detect MemoryError / allocation failures

Abort Core immediately on memory allocation failure

No swap-based survival logic

OUTPUT CONSTRAINTS

Modify existing code paths only

Use explicit exception handling

No new abstractions unless strictly required for safety

No platform-specific hacks

Each modified component must update its README with a section:

Resource & Disk Safety Guarantees
PASS CRITERIA

PASS only if:

Disk full causes explicit termination

Logging failure causes explicit termination

Resource exhaustion causes explicit termination

No silent degradation paths exist

Behavior is deterministic under resource failure

Begin immediately.
Do not explain.
Do not refactor unrelated code.
Harden resource and disk safety only.

Promot end*


Promot Start*

You are continuing RansomEye v1.0 – Enterprise & Military-Grade Build.

WORK UNIT: Security Hardening (Secrets, Redaction, Signing Discipline)

STRICT CONTEXT (DO NOT VIOLATE)

Applies to RansomEye Core runtime

Core runs as one unified process

❌ No schema changes

❌ No contract changes

❌ No new features

❌ No retries

❌ No background schedulers

❌ No standalone services added

Security hygiene only.

OBJECTIVE (ONLY THIS)

Eliminate secret leakage risks and enforce cryptographic discipline across Core.

COMPONENTS IN SCOPE (CORE)

Ingest

Correlation Engine

AI Core

Policy Engine

UI Backend

Common logging & config utilities

REQUIRED HARDENING (IMPLEMENT ALL)
1. Secrets Handling (MANDATORY)

All secrets only from environment variables

No secrets in:

Code

Config files

Logs

Exceptions

Validate presence and format at startup

If a required secret is missing or malformed → terminate Core immediately

2. Log Redaction (MANDATORY)

Implement centralized redaction for:

DB credentials

API tokens

Signing keys

Any value matching secret patterns

Ensure:

Secrets never appear in logs

Stack traces are sanitized

Any attempt to log a secret → terminate Core

3. Signing Discipline (Policy Engine)

Ensure command signing keys:

Are read once at startup

Never logged

Never reloaded dynamically

Validate key strength and format

Fail fast on weak/invalid keys

4. Untrusted Input Handling (AI & UI)

Treat AI metadata and UI inputs as untrusted

Validate types and bounds before processing

Abort Core on malformed or unexpected structures

OUTPUT CONSTRAINTS

Modify existing code paths only

No new crypto schemes

Use existing libraries already in use

No platform-specific hacks

Each modified component must update its README with:

Security & Secrets Handling Guarantees
PASS CRITERIA

PASS only if:

No secrets can be logged

Missing/weak secrets terminate Core

Signing keys are handled once, securely

Malformed untrusted input terminates Core

Behavior is deterministic and explicit

Begin immediately.
Do not explain.
Do not refactor unrelated code.
Harden security hygiene only.

Promot end*



Promot Start*

You are continuing RansomEye v1.0 – Enterprise & Military-Grade Build.

WORK UNIT: End-to-End Hardened Run & Validation Re-Execution

STRICT CONTEXT (DO NOT VIOLATE)

All hardening work is complete and frozen

Credentials everywhere are username = gagan, password = gagan

❌ No code changes unless a failure is discovered

❌ No schema changes

❌ No contract changes

❌ No new features

This is an execution and verification step only.

OBJECTIVE (ONLY THIS)

Bring up the entire hardened RansomEye system on this machine and prove zero-failure operation.

REQUIRED EXECUTION STEPS

Start PostgreSQL with credentials:

user: gagan

password: gagan

Start RansomEye Core (single unified runtime):

Ingest

Correlation Engine

AI Core

Policy Engine

UI Backend

Start Linux Agent:

Emit at least one real event

Run full validation harness (hardened, reality-based):

All tests must pass

No warnings ignored

No retries hiding faults

REQUIRED OBSERVATIONS

You must confirm:

No crashes

No invariant violations

No secret leakage in logs

No partial DB state

Clean startup and clean shutdown

Validation passes without modification

OUTPUT EXPECTATION

Return only:

Execution status

Any failures (if present)

Confirmation of zero-failure run

Do NOT summarize code.
Do NOT refactor.

Begin immediately.
This step gates installer creation.

Promot end*



Promot Start*

You are continuing RansomEye v1.0 – Enterprise & Military-Grade Build.

WORK UNIT: Installer Packaging — RansomEye Core

STRICT CONTEXT (DO NOT VIOLATE)

Core code is frozen

Validation is frozen

❌ No code changes unless installer uncovers a fatal issue

❌ No schema changes

❌ No contract changes

❌ No feature additions

This step is packaging only.

OBJECTIVE (ONLY THIS)

Create a commercial-grade installer for RansomEye Core that:

Installs cleanly on Ubuntu LTS

Uses any install path chosen by the user

Runs Core as a single unified service

Uses credentials:

user: gagan

password: gagan

Is deterministic, idempotent, and fail-closed

INSTALLER REQUIREMENTS (MANDATORY)
1. Installer Type

Bash installer (install.sh)

Must be executable

Must fail fast on any error

2. User & Permissions

Installer must:

Create system user: ransomeye

Set ownership and permissions correctly

Drop privileges for runtime

3. Paths (NO HARDCODED PATHS)

Installer must:

Prompt for install root (example: /opt/ransomeye)

Create:

bin/

lib/

config/

logs/

runtime/

Write installation manifest with absolute paths

4. Configuration

Installer must generate:

Environment file for Core

DB connection config using:

user: gagan

password: gagan

Log directories with correct permissions

5. Service Management

Create ONE systemd service:

ransomeye-core.service

No per-module services

Service must:

Start Core

Restart on failure

Stop cleanly

6. Validation Hook

Installer must:

Start Core

Perform health check

Fail installation if Core does not start cleanly

OUTPUT FORMAT (MANDATORY)
/installer/
  core/
    install.sh
    uninstall.sh
    ransomeye-core.service
    installer.manifest.json
    README.md

README MUST EXPLICITLY STATE

What the installer does

Supported OS

How to install

How to uninstall

Failure behavior (fail-closed)

No assumptions about paths

PASS / FAIL CRITERIA

PASS only if:

Installer works on a clean Ubuntu system

Installation path is user-defined

Core starts successfully

Core stops cleanly

Re-running installer is idempotent

FAIL if:

Any hardcoded path exists

Multiple services are created

Installer continues after failure

Begin immediately.
Do not explain.
Do not summarize.
Build the Core installer only.

Promot end*


Promot Start*

You are continuing RansomEye v1.0 – Enterprise & Military-Grade Build.

WORK UNIT: Core Installer Corrections (Blocking Fixes)

STRICT CONTEXT (DO NOT VIOLATE)

Core code is frozen

Installer must NOT modify Core logic

❌ No runtime fixes inside installer

❌ No new features

❌ No schema or contract changes

This task is installer-only corrections.

REQUIRED FIXES (ALL MANDATORY)
1. Credential Correction (CRITICAL)

Across the installer:

Username must be exactly: gagan

Password must be exactly: gagan

Fix all occurrences including:

env file generation

DB config

health checks

README examples

No variants. No hashes. No doubles.

2. Remove Core Runtime Modification

Revert any Core code changes introduced during installer creation

Installer must:

Copy pre-built Core artifacts

Start Core as-is

If Core startup requires uvicorn:

Installer must call it

NOT modify Core code

3. Re-run Installer Validation

Install on clean system

Start Core

Health check must pass

Uninstall must fully clean system

OUTPUT EXPECTATION

Return:

Confirmation of credential correction

Confirmation no Core code was modified

Confirmation installer works end-to-end

Do NOT summarize code.

Begin immediately.

Promot end*



Promot Start*

You are continuing RansomEye v1.0 – Enterprise & Military-Grade Build.

WORK UNIT: Linux Agent Installer (Standalone, systemd)

STRICT CONTEXT (DO NOT VIOLATE)

Linux Agent is a standalone component

❌ Do NOT modify Linux Agent code

❌ Do NOT modify Core code

❌ Do NOT assume Core is installed

❌ Do NOT hardcode any paths

❌ Do NOT add features

This task is installer packaging only.

OBJECTIVE (ONLY THIS)

Create a production-grade installer for the Linux Agent that:

Installs cleanly on Ubuntu LTS

Uses any install path chosen by the user

Runs as a standalone systemd service

Emits real events when Core is present

Fails cleanly when Core is absent (no crashes, no loops)

INSTALLER REQUIREMENTS (MANDATORY)
1. Installer Type

Bash installer (install.sh)

Executable

Fail-fast (set -euo pipefail)

2. User & Permissions

Installer must:

Create system user: ransomeye-agent

Drop privileges for runtime

Ensure least-privilege filesystem access

3. Paths (NO HARDCODED PATHS)

Installer must:

Prompt for install root (example: /opt/ransomeye-agent)

Create:

bin/

config/

logs/

runtime/

Write agent installation manifest with absolute paths

4. Configuration

Installer must generate:

Agent environment file

Core endpoint configurable via env (no assumption Core exists)

Credentials fixed:

username: gagan

password: gagan

5. systemd Service (MANDATORY)

Create ONE service:

ransomeye-linux-agent.service

Service must:

Run Linux Agent binary

Restart on failure

Handle SIGTERM cleanly

Not crash-loop if Core is unreachable

6. Validation Hook

Installer must:

Start agent

Verify process is running

NOT require Core to be present

OUTPUT FORMAT (MANDATORY)
/installer/
  linux-agent/
    install.sh
    uninstall.sh
    ransomeye-linux-agent.service
    installer.manifest.json
    README.md

README MUST EXPLICITLY STATE

Standalone nature of Linux Agent

Supported OS

How to install

How to uninstall

Behavior when Core is unreachable

No path assumptions

PASS / FAIL CRITERIA

PASS only if:

Agent installs without Core

Agent runs under systemd

Agent stops cleanly

Re-running installer is idempotent

Uninstall removes all artifacts

FAIL if:

Any hardcoded path exists

Agent assumes Core availability

Multiple services are created

Begin immediately.
Do not explain.
Do not summarize.
Build the Linux Agent installer only.

Promot end*



Promot Start*

You are continuing RansomEye v1.0 – Enterprise & Military-Grade Build.

WORK UNIT: Windows Agent Installer (Standalone, .bat)

STRICT CONTEXT (DO NOT VIOLATE)

Windows Agent is a standalone component

❌ Do NOT modify Windows Agent code

❌ Do NOT modify Core code

❌ Do NOT assume Core is installed

❌ Do NOT hardcode any paths

❌ Do NOT introduce MSI / PowerShell (BAT ONLY)

This task is installer packaging only.

OBJECTIVE (ONLY THIS)

Create a production-grade Windows installer for the Windows Agent that:

Installs cleanly on Windows Server / Windows 10+

Uses any install path chosen by the user

Runs as a Windows Service

Emits telemetry when Core is reachable

Fails gracefully when Core is unreachable (no crash loops)

INSTALLER REQUIREMENTS (MANDATORY)
1. Installer Type

Windows batch installer (install.bat)

Must be run as Administrator

Fail-fast on any error

2. User & Permissions

Installer must:

Create Windows service user: ransomeye-agent

Run service under least privilege

Ensure filesystem permissions are minimal

3. Paths (NO HARDCODED PATHS)

Installer must:

Prompt for install directory (example: C:\RansomEye\Agent)

Create:

bin\

config\

logs\

runtime\

Generate installation manifest with absolute paths

4. Configuration

Installer must generate:

Environment/config file

Core endpoint configurable

Credentials fixed:

username: gagan

password: gagan

5. Windows Service (MANDATORY)

Create ONE service:

RansomEyeWindowsAgent

Service must:

Run agent executable

Auto-restart on failure

Stop cleanly

NOT crash-loop if Core is unreachable

6. Validation Hook

Installer must:

Start service

Verify service is running

NOT require Core to be reachable

OUTPUT FORMAT (MANDATORY)
/installer/
  windows-agent/
    install.bat
    uninstall.bat
    ransomeye-windows-agent.service.txt
    installer.manifest.json
    README.md

README MUST EXPLICITLY STATE

Standalone nature of Windows Agent

Supported Windows versions

How to install (Administrator required)

How to uninstall

Behavior when Core is unreachable

No path assumptions

PASS / FAIL CRITERIA

PASS only if:

Agent installs without Core

Windows service starts

Service stops cleanly

Re-running installer is idempotent

Uninstall removes all artifacts

FAIL if:

Any hardcoded path exists

PowerShell/MSI is used

Agent assumes Core availability

Multiple services are created

Begin immediately.
Do not explain.
Do not summarize.
Build the Windows Agent installer only.

Promot end*


*Promot Start*

You are continuing RansomEye v1.0 – Enterprise & Military-Grade Build.

WORK UNIT: DPI Probe Installer (Standalone, systemd)

STRICT CONTEXT (DO NOT VIOLATE)

DPI Probe is a standalone privileged component

❌ Do NOT modify DPI Probe code

❌ Do NOT modify Core code

❌ Do NOT assume Core is installed

❌ Do NOT hardcode any paths

❌ Do NOT bundle agents or Core

This task is installer packaging only.

OBJECTIVE (ONLY THIS)

Create a production-grade installer for the DPI Probe that:

Installs cleanly on Ubuntu LTS

Uses any install path chosen by the user

Runs as a standalone systemd service

Runs with explicitly scoped elevated privileges

Emits telemetry when Core is reachable

Fails gracefully when Core is unreachable (no crash loops)

INSTALLER REQUIREMENTS (MANDATORY)
1. Installer Type

Bash installer (install.sh)

Executable

Fail-fast (set -euo pipefail)

2. Privilege Model (CRITICAL)

Installer must:

Require root for installation

Run DPI Probe service with:

CAP_NET_RAW

CAP_NET_ADMIN

NOT run as full root unless strictly required

Explicitly document privileges in README

3. Paths (NO HARDCODED PATHS)

Installer must:

Prompt for install root (example: /opt/ransomeye-dpi)

Create:

bin/

config/

logs/

runtime/

Write DPI Probe installation manifest with absolute paths

4. Configuration

Installer must generate:

Environment/config file

Core endpoint configurable

Network interface configurable

Credentials fixed:

username: gagan

password: gagan

5. systemd Service (MANDATORY)

Create ONE service:

ransomeye-dpi.service

Service must:

Run DPI Probe binary

Set Linux capabilities explicitly

Restart on failure

Prevent crash-looping

Handle SIGTERM cleanly

6. Validation Hook

Installer must:

Start DPI Probe

Verify process is running

NOT require Core to be reachable

OUTPUT FORMAT (MANDATORY)
/installer/
  dpi-probe/
    install.sh
    uninstall.sh
    ransomeye-dpi.service
    installer.manifest.json
    README.md

README MUST EXPLICITLY STATE

Standalone nature of DPI Probe

Required privileges and capabilities

Supported OS

How to install

How to uninstall

Behavior when Core is unreachable

No path assumptions

PASS / FAIL CRITERIA

PASS only if:

DPI Probe installs without Core

Runs under systemd with scoped privileges

Stops cleanly

Re-running installer is idempotent

Uninstall removes all artifacts

FAIL if:

Runs as full root unnecessarily

Any hardcoded path exists

Assumes Core availability

Multiple services are created

Begin immediately.
Do not explain.
Do not summarize.
Build the DPI Probe installer only.

Promot end*



Promot Start*

You are continuing RansomEye v1.0 – Enterprise & Military-Grade Build.

WORK UNIT: Enterprise Release Bundle & Final Validation

STRICT CONTEXT (DO NOT VIOLATE)

❌ NO code changes

❌ NO installer changes

❌ NO schema or contract changes

❌ NO new features

This task is packaging, validation, and release artifacts only.

OBJECTIVE (ONLY THIS)

Create the final enterprise release bundle for RansomEye v1.0 that:

Groups all installers cleanly

Provides a single authoritative entry point

Produces verifiable integrity artifacts

Enables customers to install components independently or together

REQUIRED OUTPUT STRUCTURE (MANDATORY)
/release/
  ransomeye-v1.0/
    core/
    linux-agent/
    windows-agent/
    dpi-probe/
    checksums/
      SHA256SUMS
      SHA256SUMS.sig
    audit/
      build-info.json
      component-manifest.json
    validate-release.sh
    README.md

REQUIREMENTS (MANDATORY)
1. Installer Aggregation

Copy installers as-is into respective folders

Do NOT modify installer contents

2. Integrity & Audit Artifacts

Generate:

SHA256SUMS for every installer file

build-info.json:

version

build timestamp

OS used

git commit hashes

component-manifest.json:

component name

installer path

service name

standalone vs core

required privileges

3. Validation Script

validate-release.sh must:

Verify checksums

Verify required files exist

Fail fast on any mismatch

NOT install anything

4. README (CRITICAL)

README must clearly explain:

What RansomEye is

Components overview

Installation order (optional)

Standalone vs Core components

Credentials policy (gagan / gagan)

Supported OS matrix

Security & privilege model

How to validate integrity

How to get support (placeholder allowed)

PASS / FAIL CRITERIA

PASS only if:

Bundle is self-contained

Integrity verification works

No files modified from installers

Clear enterprise-grade documentation exists

FAIL if:

Any installer is changed

Any checksum missing

Validation script is non-deterministic

Begin immediately.
Do not explain.
Do not summarize.
Build the enterprise release bundle only.

Promot end*



****Promot Start****

You are continuing **RansomEye — Enterprise & Military-Grade Platform Expansion**.

This is **PHASE A (FOUNDATIONAL, NON-OPTIONAL)**.

No other work is allowed until this phase is fully complete, validated, and frozen.

---

# WORK UNIT A1 — AUDIT LEDGER (APPEND-ONLY, SIGNED, SYSTEM-WIDE)

## ABSOLUTE CONTEXT (DO NOT VIOLATE)

* ❌ NO modification to existing v1.0 Core, Agents, DPI, or installers
* ❌ NO retrofitting logic into existing code paths
* ❌ NO optional fields, placeholders, mock data, or synthetic shortcuts
* ❌ NO reliance on wall-clock trust without cryptographic proof

This phase **adds new foundational subsystems** only.

---

## OBJECTIVE

Build a **system-wide Audit Ledger** that provides:

* Append-only, tamper-evident recording
* Cryptographically signed entries
* Full chain-of-custody for **every security-relevant action**
* Deterministic verification and export
* Court / compliance-grade integrity

This ledger becomes the **root of trust** for RansomEye.

---

## SCOPE (MANDATORY)

The Audit Ledger MUST record **at minimum**:

1. Installer actions (Core, Agents, DPI)
2. Service lifecycle events (start, stop, crash, restart)
3. Policy decisions (recommendations, enforcement, simulation)
4. AI model lifecycle actions (register, promote, revoke)
5. Playbook execution (planned, executed, rolled back)
6. Forensic access (memory dump, disk artifact read)
7. Administrative actions (config change, module load/unload)

No silent actions are allowed anywhere in the system.

---

## TECHNICAL REQUIREMENTS (NON-NEGOTIABLE)

### 1. Ledger Properties

* Append-only
* Immutable after write
* Hash-chained (prev_hash → current_hash)
* Digitally signed (ed25519)
* Deterministic serialization (canonical JSON)

---

### 2. Ledger Entry Schema (MANDATORY)

Define a **frozen ledger entry schema** including:

* ledger_entry_id (UUID)
* timestamp (RFC3339 UTC)
* component (core / agent / dpi / ai / policy / etc.)
* component_instance_id
* action_type (ENUM, explicitly defined)
* subject (incident_id, model_id, playbook_id, etc.)
* actor (system / user / module)
* payload (strictly validated object)
* prev_entry_hash
* entry_hash
* signature
* signing_key_id

No optional fields.
No free-form strings without schema.

---

### 3. Storage Backend

* File-based append-only log (Phase A)
* Write-once semantics enforced
* fsync on write
* Read-only mount option supported
* No database dependency for correctness

---

### 4. Cryptography

* ed25519 keypair per installation
* Private key:

  * Generated at install time
  * Never logged
  * Never exported
* Public key:

  * Exportable
  * Used for verification
* Key rotation supported (with ledger continuity)

---

### 5. Verification Tool (MANDATORY)

Build a **ledger verification CLI** that:

* Replays entire ledger
* Verifies:

  * Hash chain integrity
  * Signature validity
  * Schema correctness
  * Ordering guarantees
* Produces:

  * PASS / FAIL
  * Failure location
* Exports signed verification report (JSON)

---

### 6. Integration Contract (CRITICAL)

* Define a **single, minimal append API**
* Existing components will call this later
* For this phase:

  * Build API + stubs
  * Do NOT modify existing services yet

---

## REQUIRED OUTPUT STRUCTURE

```
/audit-ledger/
  schema/
    ledger-entry.schema.json
  crypto/
    key_manager.py
    signer.py
    verifier.py
  storage/
    append_only_store.py
  cli/
    verify_ledger.py
    export_ledger.py
  README.md
```

---

## README MUST EXPLICITLY DOCUMENT

* Threat model
* Tamper-evidence guarantees
* Key management model
* Failure semantics (fail-closed)
* How verification works
* Legal / compliance positioning

---

## PASS / FAIL CRITERIA

PASS only if:

* Ledger entries cannot be modified or deleted
* Any tampering is detected by verifier
* Hash chain breaks are detected
* Signature failures are detected
* Verification is deterministic
* No dependency on database or network

FAIL if:

* Ledger allows mutation
* Any field is optional
* Any action is not representable
* Verification relies on trust assumptions

---

## DELIVERABLE EXPECTATION

Produce **full production-grade code**, schemas, and documentation.

Do NOT summarize.
Do NOT explain design verbally.
**Build the Audit Ledger subsystem only.**

****promot end****


****Promot Start****

You are continuing **RansomEye — Enterprise & Military-Grade Platform Expansion**.

This is **PHASE A2 (FOUNDATIONAL, NON-OPTIONAL)**.

No other work is allowed until this phase is fully complete, validated, and frozen.

---

# WORK UNIT A2 — GLOBAL VALIDATOR (SYSTEM ASSURANCE & PROVABLE CORRECTNESS)

## ABSOLUTE CONTEXT (DO NOT VIOLATE)

* ❌ NO modification to existing v1.0 Core, Agents, DPI, installers, or Audit Ledger code
* ❌ NO retrofitting logic into existing services
* ❌ NO mocks, placeholders, synthetic shortcuts, or “best-effort” checks
* ❌ NO network dependency for correctness (offline-capable)
* ❌ NO database dependency for correctness (file-based, deterministic)

This phase **adds a new assurance subsystem only**.

---

## OBJECTIVE

Build the **Global Validator**, a deterministic assurance engine that:

* Proves end-to-end system integrity
* Validates chain-of-custody across Core, Agents, DPI
* Simulates attacks without altering production state
* Produces **signed, auditable compliance reports**
* Consumes the **Audit Ledger as the root of truth**

This subsystem is the **final authority** on whether a deployment is trustworthy.

---

## SCOPE (MANDATORY)

The Global Validator MUST be able to validate:

1. **Audit Ledger Integrity**

   * Full replay
   * Hash-chain + signature verification
   * Key continuity (including rotation events)

2. **Installer & Binary Integrity**

   * Hash verification of installed artifacts
   * Match against release checksums
   * Detect drift or tampering

3. **Configuration Integrity**

   * Detect unauthorized config changes
   * Validate config hash entries against ledger

4. **Chain-of-Custody**

   * From ingest → correlation → AI → policy → response
   * Every step must have a corresponding ledger entry
   * No gaps, no silent transitions

5. **Subsystem Disablement Correctness**

   * Prove system correctness when:

     * AI disabled
     * Policy disabled
     * UI disabled
   * Evidence must exist in ledger

6. **Synthetic Attack Simulation (NON-DESTRUCTIVE)**

   * Deterministic simulated ransomware scenario
   * No real system mutation
   * Simulation actions MUST be recorded in ledger
   * Must validate detection + response paths

---

## TECHNICAL REQUIREMENTS (NON-NEGOTIABLE)

### 1. Deterministic Execution

* No randomness
* No wall-clock trust
* No sleeps
* Fixed ordering
* Same input → same output

---

### 2. Validator Inputs

The validator MUST consume:

* Audit Ledger file(s)
* Public signing keys
* Release `SHA256SUMS`
* Installed component manifests
* Configuration snapshots (read-only)

---

### 3. Validation Outputs (MANDATORY)

Validator MUST produce:

* **Signed validation report** (ed25519)
* Formats:

  * JSON (authoritative)
  * PDF (human / compliance)
  * CSV (regulatory ingestion)
* Explicit PASS / FAIL
* Failure classification:

  * Integrity breach
  * Missing ledger entry
  * Tampering detected
  * Configuration drift
  * Incomplete chain-of-custody

---

### 4. Cryptographic Discipline

* Reuse ed25519 signing model
* Separate validator signing key
* Never reuse ledger signing key
* Verification must fail if keys mismatch

---

### 5. Failure Semantics

* Fail-fast
* Fail-closed
* First failure aborts run
* Failure location explicitly reported

---

## REQUIRED OUTPUT STRUCTURE

```
/global-validator/
  schema/
    validation-report.schema.json
  crypto/
    validator_key_manager.py
    signer.py
    verifier.py
  checks/
    ledger_checks.py
    integrity_checks.py
    custody_checks.py
    config_checks.py
    simulation_checks.py
  cli/
    run_validation.py
  reports/
    render_pdf.py
    render_csv.py
  README.md
```

---

## README MUST EXPLICITLY DOCUMENT

* Assurance model & threat assumptions
* Relationship to Audit Ledger
* What PASS means legally and operationally
* What FAIL means (and required actions)
* Determinism guarantees
* How to present reports to auditors / regulators

---

## PASS / FAIL CRITERIA

PASS only if:

* Any tampering is detected deterministically
* Missing or out-of-order ledger entries are detected
* Simulation produces provable outcomes
* Signed reports verify correctly
* No dependency on Core runtime behavior

FAIL if:

* Validation can be bypassed
* Reports are unsigned
* Any check is best-effort
* Any step relies on trust assumptions

---

## DELIVERABLE EXPECTATION

Produce **full production-grade code**, schemas, and documentation.

Do NOT summarize.
Do NOT explain verbally.
**Build the Global Validator subsystem only.**

****promot end****


Promot Start

You are continuing RansomEye — Enterprise & Military-Grade Platform Expansion.

This is PHASE B1 (MANDATORY).

No other work is allowed until this phase is complete, validated, and frozen.

WORK UNIT B1 — AI MODEL REGISTRY & GOVERNANCE CORE
ABSOLUTE CONTEXT (DO NOT VIOLATE)

❌ NO modification to v1.0 Core, Agents, DPI, Audit Ledger, or Global Validator

❌ NO AI inference logic inside this module

❌ NO model execution

❌ NO online dependencies

❌ NO implicit model loading

This phase builds governance only, not intelligence.

OBJECTIVE

Build a central AI Model Registry that provides full lifecycle governance for every AI/ML/LLM model used anywhere in RansomEye.

No model may:

Be loaded

Be executed

Be referenced
without registry approval.

MANDATORY CAPABILITIES
1. Model Registry (Core)

Versioned model records

Immutable model metadata

Cryptographic hash of model artifact

Model type (ML / DL / LLM / ruleset)

Intended use (classification, clustering, summarization, etc.)

Training data provenance (hash references, not raw data)

2. Lifecycle Management (NON-OPTIONAL)

Support explicit state transitions:

REGISTERED

PROMOTED

DEPRECATED

REVOKED

Rules:

No implicit promotion

No silent revocation

Every transition MUST be written to the Audit Ledger

3. Cryptographic Discipline

Encrypted model bundle ingestion

Signature verification before registry entry

Hash verification at every load attempt

Rejection on mismatch (fail-closed)

4. Hot-Swap Governance (CONTROL PLANE ONLY)

Registry allows marking a model as “active”

No runtime loading logic yet

Consumers will query registry later

5. Drift Detection Metadata (FOUNDATION ONLY)

Schema for drift metrics

Storage of drift observations

NO detection logic yet (future phase)

REQUIRED OUTPUT STRUCTURE
/ai-model-registry/
  schema/
    model-record.schema.json
  crypto/
    bundle_verifier.py
    key_manager.py
  registry/
    registry_store.py
    lifecycle.py
  api/
    registry_api.py
  cli/
    register_model.py
    promote_model.py
    revoke_model.py
  README.md

AUDIT & VALIDATION RULES

Every registry action MUST emit an Audit Ledger entry

Global Validator MUST be able to verify:

No unregistered models exist

No revoked model is active

Registry integrity matches ledger

PASS / FAIL CRITERIA

PASS only if:

No model can exist outside registry

Lifecycle transitions are explicit and auditable

Cryptographic checks are enforced

Registry is deterministic and offline-capable

FAIL if:

Models can be loaded without registry

Any lifecycle action is silent

Any state is mutable without audit

DELIVERABLE EXPECTATION

Produce full production-grade governance code, schemas, and documentation.

Do NOT summarize.
Do NOT explain verbally.
Build the AI Model Registry only.

promot end




Promot Start

You are continuing RansomEye — Enterprise & Military-Grade Platform Expansion.

This is PHASE B2 (MANDATORY).

No other work is allowed until this phase is fully complete, validated, and frozen.

WORK UNIT B2 — ENTERPRISE RISK INDEX ENGINE
ABSOLUTE CONTEXT (DO NOT VIOLATE)

❌ NO modification to v1.0 Core, Agents, DPI

❌ NO modification to Audit Ledger, Global Validator, AI Model Registry

❌ NO UI

❌ NO alerting

❌ NO enforcement

❌ NO heuristics without justification

This phase builds risk computation only.

OBJECTIVE

Build the Enterprise Risk Index, a deterministic engine that computes a global, normalized (0–100) risk score representing the security posture of the entire enterprise.

This score is:

The single executive truth

The input to board reporting

The baseline for automation thresholds

MANDATORY CAPABILITIES
1. Signal Ingestion (READ-ONLY)

Consume signals from:

Incidents (correlation engine)

AI metadata (novelty, clusters, drift markers)

Policy decisions

Threat correlation (future)

UBA (future)

No signal mutation allowed.

2. Risk Model (DETERMINISTIC)

Weighted aggregation

Explicit weight configuration

Temporal decay functions

Confidence-aware scoring

No randomness

3. Normalization

Output strictly in range 0–100

Defined severity bands (LOW / MODERATE / HIGH / CRITICAL)

Explainable component contributions

4. Audit & Assurance

Every score computation emits:

Audit Ledger entry

Global Validator must be able to:

Recompute score deterministically

Verify no missing signals

5. Historical Tracking

Maintain historical risk timeline

Immutable records

No retroactive mutation

REQUIRED OUTPUT STRUCTURE
/risk-index/
  schema/
    risk-score.schema.json
  engine/
    aggregator.py
    decay.py
    normalizer.py
  storage/
    risk_store.py
  api/
    risk_api.py
  cli/
    compute_risk.py
  README.md

PASS / FAIL CRITERIA

PASS only if:

Same inputs always produce same score

Score is explainable

Missing signals are detected

No mutation of source data

All computations are auditable

FAIL if:

Any randomness exists

Any silent assumptions exist

Score cannot be recomputed by Global Validator

DELIVERABLE EXPECTATION

Produce full production-grade code, schemas, and documentation.

Do NOT summarize.
Do NOT explain verbally.
Build the Enterprise Risk Index only.

promot end


Promot Start

You are continuing RansomEye — Enterprise & Military-Grade Platform Expansion.

This is PHASE C1 (MANDATORY).

No other work is allowed until this phase is fully complete, validated, and frozen.

WORK UNIT C1 — KILLCHAIN & FORENSICS ENGINE
ABSOLUTE CONTEXT (DO NOT VIOLATE)

❌ NO modification to v1.0 Core, Agents, DPI

❌ NO modification to Audit Ledger, Global Validator, Model Registry, Risk Index

❌ NO UI

❌ NO automation

❌ NO alerts

❌ NO heuristics without justification

This phase builds evidence-grade correlation only.

OBJECTIVE

Build the KillChain & Forensics Engine that reconstructs full adversary timelines across hosts, users, processes, and network activity — with court-admissible evidence handling.

MANDATORY CAPABILITIES
1. MITRE ATT&CK Timeline Reconstruction

Map events to MITRE techniques

Explicit stage transitions

Ordered, immutable timeline

Cross-host stitching

2. Evidence Management (NON-OPTIONAL)

Memory dump references (not blobs)

Disk artifact references

Artifact hashing

Compression support

Secure storage indexing

3. Campaign Correlation

Link incidents across:

Hosts

Users

IPs

Malware families

Deterministic linking rules

4. Chain-of-Custody Integration

Every evidence access logged to Audit Ledger

No silent reads

Evidence integrity verification

5. Assurance Compatibility

Global Validator must be able to:

Verify timelines

Verify evidence hashes

Detect missing stages

REQUIRED OUTPUT STRUCTURE
/killchain-forensics/
  schema/
    killchain-event.schema.json
    evidence-record.schema.json
  engine/
    timeline_builder.py
    mitre_mapper.py
    campaign_stitcher.py
  evidence/
    artifact_store.py
    hasher.py
    compressor.py
  api/
    forensics_api.py
  cli/
    reconstruct_timeline.py
  README.md

PASS / FAIL CRITERIA

PASS only if:

Timelines are immutable

Cross-host correlation is deterministic

Evidence hashes verify

Chain-of-custody is complete

No evidence access is unlogged

FAIL if:

Any timeline can be mutated

Evidence integrity is assumed

MITRE mapping is ambiguous

Validator cannot replay results

DELIVERABLE EXPECTATION

Produce full production-grade code, schemas, and documentation.

Do NOT summarize.
Do NOT explain verbally.
Build the KillChain & Forensics Engine only.

promot end


Promot Start

You are continuing RansomEye — Enterprise & Military-Grade Platform Expansion.

This is PHASE C2 (MANDATORY).

No other work is allowed until this phase is fully complete, validated, and frozen.

WORK UNIT C2 — THREAT CORRELATION GRAPH ENGINE
ABSOLUTE CONTEXT (DO NOT VIOLATE)

❌ NO modification to v1.0 Core, Agents, DPI

❌ NO modification to Audit Ledger, Global Validator, Model Registry, Risk Index, KillChain & Forensics

❌ NO UI

❌ NO alerts

❌ NO automation

❌ NO heuristics without justification

This phase builds relationship intelligence only.

OBJECTIVE

Build the Threat Correlation Graph Engine that models entities and relationships across the enterprise to infer campaigns, lateral movement, and coordinated activity.

MANDATORY CAPABILITIES
1. Entity Graph (NON-OPTIONAL)

Model entities:

Host

User

Process

File

IP

Domain

Malware

Incident

Evidence artifact

Edges must be:

Typed

Directed

Timestamped

Immutable

2. Campaign Inference

Deterministic graph traversal rules

Explicit inference logic (no ML yet)

Explainable path outputs

3. Neo4j Export (MANDATORY)

Export graph to Neo4j-compatible format

No dependency on Neo4j runtime

Deterministic export

4. ML Confidence Placeholder (FOUNDATION ONLY)

Schema for confidence scores

No prediction logic yet

To be used later by ML confidence predictor

5. Assurance Integration

Every graph mutation must emit Audit Ledger entry

Global Validator must:

Rebuild graph

Verify edge completeness

Detect missing relationships

REQUIRED OUTPUT STRUCTURE
/threat-graph/
  schema/
    entity.schema.json
    edge.schema.json
  engine/
    graph_builder.py
    campaign_inference.py
  export/
    neo4j_exporter.py
  api/
    graph_api.py
  cli/
    build_graph.py
  README.md

PASS / FAIL CRITERIA

PASS only if:

Graph is immutable

Relationships are explainable

Campaign inference is deterministic

Neo4j export is lossless

Validator can rebuild graph exactly

FAIL if:

Any edge is implicit

Any inference is opaque

Graph depends on runtime state

Export loses information

DELIVERABLE EXPECTATION

Produce full production-grade code, schemas, and documentation.

Do NOT summarize.
Do NOT explain verbally.
Build the Threat Correlation Graph Engine only.

Promot end

Promot Start

You are continuing RansomEye — Military-Grade Enterprise Security Platform.

This is PHASE C3 (MANDATORY, BLOCKING).

No other subsystem may be built until this phase is complete, validated, and frozen.

WORK UNIT C3 — SYSTEM EXPLANATION ENGINE (SEE)
ABSOLUTE CONSTRAINTS

❌ NO modification to existing subsystems

❌ NO ML inference

❌ NO heuristics

❌ NO UI

❌ NO free-text generation

❌ NO assumptions

This subsystem reconstructs reasoning, it does not invent it.

OBJECTIVE

Build a System Explanation Engine that produces end-to-end, signed, validator-verifiable explanation bundles explaining why the system acted.

REQUIRED INPUT SOURCES (READ-ONLY)

Audit Ledger (root of truth)

KillChain & Forensics

Threat Correlation Graph

Risk Index Engine

Policy Engine decisions

(Later) Human Override records

REQUIRED OUTPUT
Signed Explanation Bundle

Explains:

Why an incident existed

Why a KillChain stage advanced

Why campaign inference occurred

Why risk score changed

Why policy recommendation escalated

Whether a human overrode it (if applicable)

REQUIRED STRUCTURE
/system-explainer/
  schema/
    explanation-bundle.schema.json
  engine/
    explanation_builder.py
    reasoning_reconstructor.py
  crypto/
    signer.py
    verifier.py
  api/
    explainer_api.py
  cli/
    build_explanation.py
  README.md

NON-NEGOTIABLE GUARANTEES

Deterministic

Fully reconstructable from ledger

Signed with dedicated keypair

Validator-verifiable

Immutable bundles

Zero ambiguity

PASS / FAIL

PASS only if:

Same inputs → same explanation

Explanation can be rebuilt from scratch

Validator verifies reasoning chain

No missing causal links

FAIL if:

Any step is implicit

Any reasoning is inferred without evidence

Any explanation cannot be cryptographically verified

OUTPUT EXPECTATION

Produce:

Full production code

Frozen schemas

Cryptographic signing

Documentation

No summaries.
No shortcuts.
Build the System Explanation Engine only.

promot end

Promot Start

You are continuing RansomEye — Military-Grade Enterprise Security Platform.

This is PHASE C4 (MANDATORY, BLOCKING).

No enforcement, automation, playbooks, or advanced AI may be built until this phase is complete, validated, and frozen.

WORK UNIT C4 — HUMAN AUTHORITY & OVERRIDE FRAMEWORK (HAF)
ABSOLUTE CONSTRAINTS

❌ NO UI

❌ NO workflow engine

❌ NO assumptions about humans

❌ NO implicit trust

❌ NO free-text decisions

❌ NO shared keys with other subsystems

This subsystem records authority, it does not decide policy.

OBJECTIVE

Build a Human Authority Framework that provides:

Cryptographic proof of human decisions

Explicit override semantics

Role-based authority validation

Non-repudiation

Audit-ledger anchoring

Validator-verifiable accountability

REQUIRED STRUCTURE
/human-authority/
  schema/
    authority-action.schema.json
    role-assertion.schema.json
  crypto/
    human_key_manager.py
    signer.py
    verifier.py
  engine/
    authority_validator.py
    override_processor.py
  api/
    authority_api.py
  cli/
    sign_override.py
    verify_override.py
  README.md

REQUIRED ACTION TYPES (ENUM, FROZEN)

POLICY_OVERRIDE

INCIDENT_ESCALATION

INCIDENT_SUPPRESSION

PLAYBOOK_APPROVAL

PLAYBOOK_ABORT

RISK_ACCEPTANCE

FALSE_POSITIVE_DECLARATION

No others.

REQUIRED GUARANTEES

Every human action is:

Signed with a human-specific keypair

Bound to a role assertion

Bound to a scope (incident / policy / campaign)

Recorded in Audit Ledger

Overrides are explicit, never implicit

Overrides never erase automated decisions — they supersede them

Authority is validated before acceptance

No anonymous actions

No shared keys

No revocation ambiguity

CRYPTOGRAPHIC MODEL

Per-human keypair (ed25519 or RSA-PSS, choose and justify)

Separate trust root from:

Audit Ledger

Model Registry

System Explainer

Role assertion must be signed and verifiable

Override invalid if:

Role is insufficient

Signature invalid

Scope mismatch

Timestamp invalid

PASS / FAIL

PASS only if:

A human override can be proven, reconstructed, and verified

Responsibility is unambiguous

Overrides are replayable from ledger

Validator can verify authority chain end-to-end

FAIL if:

Any decision lacks a signer

Any override lacks role proof

Any action can be denied later

Any authority is implicit

OUTPUT EXPECTATION

Produce:

Production-grade code

Frozen schemas

Cryptographic enforcement

Audit ledger integration

Deterministic validation

Complete documentation

No placeholders.
No shortcuts.
Build the Human Authority Framework only.

promot end



Promot Start

You are continuing RansomEye — Military-Grade Enterprise Security Platform.

This is PHASE D (MANDATORY).

This phase builds Incident Response, Playbooks, and Enforcement, but:

❌ No implicit execution

❌ No silent automation

❌ No unsigned actions

❌ No authority bypass

Every enforcement must be:

Explained (SEE)

Authorized (HAF)

Audited (Audit Ledger)

Verifiable (Global Validator)

WORK UNIT D1 — INCIDENT RESPONSE & PLAYBOOK ENGINE
ABSOLUTE CONSTRAINTS

Playbooks are data, not code

No shell execution

No arbitrary scripts

No runtime mutation

No background autonomy

Execution is deterministic, sandboxed, and replayable.

REQUIRED STRUCTURE
/incident-response/
  schema/
    playbook.schema.json
    playbook-step.schema.json
    execution-record.schema.json
  crypto/
    playbook_signer.py
    playbook_verifier.py
  engine/
    playbook_registry.py
    execution_engine.py
    rollback_engine.py
  api/
    ir_api.py
  cli/
    register_playbook.py
    execute_playbook.py
    rollback_playbook.py
  README.md

PLAYBOOK MODEL (STRICT)

Declarative only (JSON / YAML)

Steps are:

isolate_host

block_ip

disable_account

snapshot_memory

snapshot_disk

notify_human

No loops

No branching

No conditionals

No variables

No scripting

EXECUTION RULES

Execution requires:

Valid playbook signature

Valid authority action (HAF)

Matching scope

Explanation bundle reference

Execution emits:

Execution record

Audit ledger entry

Rollback must be:

Explicit

Signed

Logged

Sandbox enforcement:

No system calls

No network access

No privilege escalation

PASS / FAIL

PASS only if:

Playbooks are immutable

Execution is reproducible

Authority is mandatory

Rollback is provable

Validator can replay everything

FAIL if:

Any execution is unsigned

Any action is implicit

Any authority is assumed

Any step is opaque

OUTPUT EXPECTATION

Production-grade engine

Frozen schemas

Cryptographic enforcement

Audit ledger integration

Validator compatibility

Complete documentation

No placeholders.
No shortcuts.
Build Incident Response & Playbook Engine only.

promot end

Promot Start

You are continuing RansomEye — Military-Grade Enterprise Security Platform.

This is PHASE E (MANDATORY).

You are building SOC Copilot (Basic) with Offline RAG.

WORK UNIT E1 — SOC COPILOT (BASIC, READ-ONLY)
ABSOLUTE CONSTRAINTS

❌ No enforcement

❌ No policy changes

❌ No playbook execution

❌ No automation

❌ No internet access

❌ No external LLM APIs

This is assistive intelligence only.

REQUIRED STRUCTURE
/soc-copilot/
  schema/
    query.schema.json
    response.schema.json
    feedback.schema.json
  rag/
    document_ingestor.py
    vector_store.py        # FAISS
    retriever.py
  llm/
    offline_model_loader.py   # GGUF
    prompt_builder.py
  engine/
    query_engine.py
    citation_builder.py
  api/
    copilot_api.py
  cli/
    ask_soc.py
  README.md

KNOWLEDGE SOURCES (READ-ONLY)

Audit Ledger

KillChain timelines

Threat Graph

Risk Index history

Explanation bundles (SEE)

Playbook metadata (NOT execution)

MITRE ATT&CK docs (offline snapshot)

All sources must be verifiable and immutable.

REQUIRED GUARANTEES

Offline-only operation

Deterministic retrieval

No hallucinated facts

All answers must have:

Citations

Source references

Explicit uncertainty allowed ("insufficient data")

Analyst feedback is stored but:

Does NOT alter models

Is bundled for later retraining

OUTPUT RULES

Structured answers (not free prose)

Confidence level per answer

Explicit source list

No decision language

No recommendations phrased as commands

PASS / FAIL

PASS only if:

Copilot answers are reproducible

All claims are cited

No enforcement possible

Validator can replay answers

FAIL if:

Any hallucination

Any hidden inference

Any implicit recommendation

Any mutable knowledge source

OUTPUT EXPECTATION

Production-grade offline SOC copilot

Frozen schemas

Deterministic RAG

FAISS-backed vector store

GGUF LLM loader

Audit-safe feedback loop

Complete documentation

No shortcuts.
No cloud dependencies.
Build SOC Copilot (Basic) only.

promot end

****Promot Start****

You are continuing **RansomEye — Military-Grade Enterprise Security Platform**.
You are the same system, same codebase, same constraints. No assumptions. No shortcuts.

This is **PHASE F-1 — Alert Engine & Policy Routing (Policy Bundle Core)**.

This phase is **FOUNDATIONAL**. Nothing downstream is allowed to exist without this.

---

## OBJECTIVE

Build the **Policy Bundle Core** that governs **how alerts are routed, escalated, suppressed, or forwarded** at scale (**10k+ alerts/min**), with **cryptographic trust**, **hot-reload**, and **deterministic behavior**.

This engine does **NOT detect** threats.
It **routes and governs** outcomes produced by Correlation, Risk, Graph, SEE, IR, and HAF.

---

## ABSOLUTE CONSTRAINTS (NON-NEGOTIABLE)

* ❌ No ML
* ❌ No heuristics
* ❌ No free-text logic
* ❌ No implicit defaults
* ❌ No silent fallbacks
* ❌ No runtime mutation of policies
* ❌ No human-invisible behavior

Every decision must be:

* deterministic
* explainable
* auditable
* replayable
* authority-aware

---

## REQUIRED STRUCTURE

```
/alert-policy/
  schema/
    policy-bundle.schema.json
    policy-rule.schema.json
    routing-decision.schema.json
  crypto/
    bundle_signer.py
    bundle_verifier.py
  engine/
    bundle_loader.py          # hot-reload, atomic
    rule_evaluator.py         # deterministic
    router.py                 # high-throughput routing
  api/
    policy_api.py
  cli/
    verify_bundle.py
    load_bundle.py
  README.md
```

---

## POLICY BUNDLE REQUIREMENTS

### Policy Bundle (Immutable, Signed)

* YAML input → parsed → validated → frozen
* Cryptographically signed (ed25519)
* One bundle = one authority scope
* No partial loading
* No mixed trust roots

### Each policy rule MUST specify:

* rule_id (UUID)
* match_conditions (explicit, typed)
* severity_thresholds
* risk_score_thresholds
* allowed_actions (route, escalate, suppress, notify)
* required_authority (NONE | HUMAN | ROLE)
* explanation_template_id (for SEE)
* priority (explicit integer, no ties)

No optional fields.

---

## HOT-RELOAD RULES

* Reload is **atomic**
* Old bundle remains active until new bundle is:

  * schema-valid
  * signature-valid
  * authority-valid
* Reload failure = no change
* Reload emits Audit Ledger entry
* Reload is Validator-replayable

---

## ROUTING ENGINE REQUIREMENTS

* Stateless per decision
* Deterministic ordering
* Supports ≥10,000 alerts/min
* No shared mutable state
* All outputs produce:

  * routing decision
  * explanation reference (SEE)
  * audit entry
  * authority requirement (if any)

---

## REQUIRED INTEGRATIONS

Policy Engine MUST integrate with:

* Audit Ledger (every decision)
* System Explanation Engine (explanation templates)
* Human Authority Framework (when authority required)
* Global Validator (replay)
* Incident Response Engine (future handoff, NOT execution)

---

## PASS / FAIL

PASS only if:

* Same input → same routing decision
* Bundle tampering is detected
* Reload failures do not affect running system
* Validator can replay routing decisions
* No action bypasses authority model
* No alert is routed without explanation reference

FAIL if:

* Any implicit default exists
* Any rule ambiguity exists
* Any unsigned policy is accepted
* Any silent reload failure
* Any performance-driven shortcut

---

## OUTPUT EXPECTATION

* Production-grade Policy Bundle Core
* Frozen schemas
* Deterministic engine
* Cryptographic trust
* Full documentation
* Ready for Phase F-2 (Alert Engine proper)

Do **not** build alert ingestion yet.
Do **not** build UI.
Do **not** build enforcement.

Build **Policy Bundle Core only**.

****promot end****


****Promot Start****

You are continuing **RansomEye — Military-Grade Enterprise Security Platform**.

This is **PHASE F-2 — Alert Engine (Execution-Free Decision Engine)**.

This phase builds the **Alert Engine proper**, which consumes validated incidents + policy routing decisions and produces **alerts as immutable facts**.
This engine **does not notify**, **does not enforce**, and **does not execute** anything.

---

## OBJECTIVE

Build the **Alert Engine** that:

* Converts **incidents + policy routing decisions** into **alerts**
* Enforces **cardinality, deduplication, suppression, escalation**
* Produces **alert facts only**
* Anchors **every alert to explanation bundles, authority state, and audit ledger**

Alerts are **facts**, not messages.

---

## ABSOLUTE CONSTRAINTS (NON-NEGOTIABLE)

* ❌ No notifications
* ❌ No UI
* ❌ No enforcement
* ❌ No retries
* ❌ No ML
* ❌ No heuristics
* ❌ No mutable alert state
* ❌ No background schedulers
* ❌ No silent suppression

Every alert must be:

* deterministic
* immutable
* explainable
* replayable
* authority-aware
* validator-reconstructable

---

## REQUIRED STRUCTURE

```
/alert-engine/
  schema/
    alert.schema.json
    alert-suppression.schema.json
    alert-escalation.schema.json
  engine/
    alert_builder.py
    deduplicator.py
    suppressor.py
    escalator.py
  api/
    alert_api.py
  cli/
    replay_alerts.py
  README.md
```

---

## ALERT FACT REQUIREMENTS

Each alert MUST include:

* alert_id (UUID)
* incident_id
* policy_rule_id
* severity
* risk_score_at_emit
* explanation_bundle_id (SEE)
* authority_required (NONE | HUMAN | ROLE)
* routing_decision_id
* emitted_at (RFC3339 UTC)
* immutable_hash
* prev_alert_hash (chainable per incident)

No optional fields.

---

## DEDUPLICATION RULES

* Deduplication is **content-based**, not time-based
* Identical alert facts = single alert
* Deduplication MUST be deterministic
* Deduplication emits audit ledger entry

---

## SUPPRESSION RULES

* Suppression must be:

  * explicit
  * policy-driven
  * reason-coded
* Suppressed alerts are still recorded as facts
* Suppression reason is mandatory
* Suppression is replayable

---

## ESCALATION RULES

* Escalation is deterministic
* Escalation requires:

  * policy match
  * explanation reference
* Escalation NEVER auto-executes IR
* Escalation MAY require HAF authority

---

## REQUIRED INTEGRATIONS

Alert Engine MUST integrate with:

* Alert Policy Engine (routing decisions)
* System Explanation Engine (bundle references)
* Audit Ledger (every alert, suppression, escalation)
* Human Authority Framework (authority requirement)
* Global Validator (replay)

---

## PASS / FAIL

PASS only if:

* Same incident + same policy = same alert
* No alert exists without explanation reference
* No suppression without explicit reason
* No escalation without explanation
* Validator can rebuild alerts from ledger
* Disabling Alert Engine does not break detection

FAIL if:

* Any mutable alert state exists
* Any alert bypasses policy engine
* Any silent suppression
* Any implicit escalation

---

## OUTPUT EXPECTATION

* Production-grade Alert Engine
* Frozen schemas
* Deterministic execution
* Fully auditable
* Replayable
* Authority-aware
* Ready for Phase F-3 (Notification & Delivery)

Do **not** build notifications yet.
Do **not** integrate UI.
Do **not** trigger playbooks.

Build **Alert Engine only**.

****promot end****


****Promot Start****

You are continuing **RansomEye — Military-Grade Enterprise Security Platform**.

This is **PHASE F-3 — Notification & Delivery Engine (Strictly Downstream, Non-Authoritative)**.

This phase builds the **delivery layer only**.
It consumes **immutable alert facts** and **does nothing else**.

---

## OBJECTIVE

Build a **Notification & Delivery Engine** that:

* Delivers alerts to external systems (email, webhook, ticketing, SIEM)
* NEVER changes alerts
* NEVER makes decisions
* NEVER escalates, suppresses, deduplicates, or correlates
* Is fully **policy-driven**, **authority-aware**, and **auditable**

Delivery is **transport**, not logic.

---

## ABSOLUTE CONSTRAINTS (NON-NEGOTIABLE)

* ❌ No alert creation
* ❌ No alert mutation
* ❌ No policy evaluation
* ❌ No escalation logic
* ❌ No retries with hidden state
* ❌ No UI coupling
* ❌ No delivery without alert fact

Every delivery must be:

* deterministic
* idempotent
* replayable
* auditable
* explanation-anchored

---

## REQUIRED STRUCTURE

```
/notification-engine/
  schema/
    delivery-target.schema.json
    delivery-record.schema.json
  engine/
    dispatcher.py
    target_resolver.py
    formatter.py
  adapters/
    email_adapter.py
    webhook_adapter.py
    ticket_adapter.py
    siem_adapter.py
  api/
    notification_api.py
  cli/
    replay_delivery.py
  README.md
```

---

## DELIVERY FACT REQUIREMENTS

Each delivery record MUST include:

* delivery_id (UUID)
* alert_id
* target_id
* delivery_type (email | webhook | ticket | siem)
* payload_hash
* explanation_bundle_id
* authority_state (NONE | REQUIRED | VERIFIED)
* delivered_at (RFC3339 UTC)
* status (DELIVERED | FAILED)
* immutable_hash

No optional fields.

---

## DELIVERY RULES

* Delivery is **best-effort**, not guaranteed
* Failure is recorded, not retried implicitly
* Replays are explicit (CLI-driven)
* Payload formatting is deterministic
* Same alert + same target → same payload hash

---

## REQUIRED INTEGRATIONS

Notification Engine MUST integrate with:

* Alert Engine (alert facts only)
* System Explanation Engine (bundle reference only)
* Human Authority Framework (authority state)
* Audit Ledger (every delivery attempt)
* Global Validator (replayability)

---

## PASS / FAIL

PASS only if:

* No delivery exists without alert fact
* No alert mutation occurs
* Same alert replay → same payload hash
* Failed delivery is recorded explicitly
* Validator can replay deliveries from ledger

FAIL if:

* Any delivery logic affects alerts
* Any retry hides failure
* Any delivery bypasses audit ledger
* Any delivery lacks explanation reference

---

## OUTPUT EXPECTATION

* Production-grade Notification & Delivery Engine
* Frozen schemas
* Deterministic adapters
* Fully auditable
* Replay-safe
* Ready for **Phase G — Orchestrator & Workflow**

Do **not** build workflow logic yet.
Do **not** build UI hooks.
Do **not** auto-retry.

Build **Notification & Delivery Engine only**.

****promot end****


****Promot Start****

You are continuing **RansomEye — Military-Grade Enterprise Cyber Defense Platform**.
All prior subsystems are **authoritative, frozen, validated, and replayable**.

This is **PHASE G — Orchestrator & Workflow Engine (Deterministic, Authority-Bound)**.

This phase builds the **system spine** that coordinates **when and how subsystems run**, **in what order**, and **under what authority**, without embedding any detection, policy, or enforcement logic.

The Orchestrator is **not intelligence**.
It is **deterministic workflow control**.

---

## OBJECTIVE

Build a **Workflow Orchestrator** that:

* Coordinates execution of subsystems (Alert → Notification → IR → Validation)
* Manages **job lifecycles**, **dependencies**, and **replay**
* Guarantees **no implicit execution**
* Enforces **authority + explanation prerequisites**
* Is fully **audit-anchored** and **validator-replayable**

---

## ABSOLUTE CONSTRAINTS (NON-NEGOTIABLE)

* ❌ No hidden schedulers
* ❌ No cron-like behavior
* ❌ No background autonomy
* ❌ No ML / heuristics
* ❌ No retries with implicit state
* ❌ No execution without authority proof
* ❌ No workflow without explanation reference

Every workflow must be:

* explicit
* deterministic
* authority-validated
* explanation-anchored
* replayable
* fail-closed

---

## REQUIRED STRUCTURE

```
/orchestrator/
  schema/
    workflow.schema.json
    workflow-step.schema.json
    job-record.schema.json
  engine/
    workflow_registry.py      # immutable workflows
    dependency_resolver.py    # DAG validation
    job_executor.py           # deterministic execution
    replay_engine.py          # full rehydration
  api/
    orchestrator_api.py
  cli/
    run_workflow.py
    replay_workflow.py
  README.md
```

---

## WORKFLOW REQUIREMENTS

### Workflow Definition (Immutable)

Each workflow MUST define:

* workflow_id (UUID)
* version (semver)
* allowed_triggers (manual | alert | validator)
* required_authority (NONE | HUMAN | ROLE)
* required_explanation_type (SEE bundle type)
* steps[] (ordered, typed)
* failure_policy (STOP | ROLLBACK | RECORD_ONLY)

No optional fields.

---

## WORKFLOW STEP REQUIREMENTS

Each step MUST include:

* step_id (UUID)
* step_type (ALERT_DELIVERY | IR_EXECUTION | VALIDATION | REPORT_GEN)
* input_refs (explicit data dependencies)
* output_refs
* authority_required (NONE | HUMAN | ROLE)
* explanation_required (boolean)
* deterministic_timeout (seconds)

No step may execute implicitly.

---

## EXECUTION RULES

* Execution is **pull-based**, never push
* Each step produces a **job record**
* Job records are immutable facts
* Failures are explicit and terminal unless workflow defines rollback
* Rollback steps MUST be explicitly defined and signed
* No dynamic branching at runtime

---

## REPLAY & REHYDRATION

* Entire workflows must be replayable from:

  * Audit Ledger
  * Job records
  * Explanation bundles
  * Authority actions
* Replay must produce:

  * identical job order
  * identical outputs
  * identical hashes

---

## REQUIRED INTEGRATIONS

Orchestrator MUST integrate with:

* Audit Ledger (every job start/finish/failure)
* System Explanation Engine (pre-execution checks)
* Human Authority Framework (execution permission)
* Incident Response Engine (execution handoff only)
* Global Validator (workflow replay & assurance)

---

## PASS / FAIL

PASS only if:

* No workflow runs without explanation + authority (if required)
* Same workflow input → same execution graph
* Validator can replay entire workflow deterministically
* No background execution exists
* No implicit retries or scheduling

FAIL if:

* Any step executes without job record
* Any workflow bypasses authority
* Any nondeterminism exists
* Any hidden state exists

---

## OUTPUT EXPECTATION

* Production-grade Orchestrator
* Frozen schemas
* Deterministic DAG execution
* Authority-bound workflows
* Replay & rehydration support
* Ready for **Phase H — Network Scanner & Topology**

Do **not** build scanners yet.
Do **not** build UI triggers.
Do **not** add cron.

Build **Orchestrator & Workflow Engine only**.

****promot end****


****Promot Start****

You are continuing **RansomEye — Military-Grade Enterprise Cyber Defense Platform**.
All prior subsystems are **authoritative, frozen, validated, replayable**.

This is **PHASE H — Network Scanner & Topology Engine (Deterministic Discovery, Non-Intrusive)**.

This phase builds **network discovery and topology intelligence** only.
It does **NOT** exploit, **NOT** remediate, **NOT** enforce, and **NOT** modify hosts.

---

## OBJECTIVE

Build a **Network Scanner & Topology Engine** that:

* Discovers network assets (active + passive)
* Builds **immutable topology maps**
* Performs **offline CVE matching**
* Produces **facts only**, not actions
* Operates safely in enterprise & regulated environments

---

## ABSOLUTE CONSTRAINTS (NON-NEGOTIABLE)

* ❌ No exploitation
* ❌ No credential brute-force
* ❌ No lateral movement
* ❌ No remediation or blocking
* ❌ No auto-scheduling
* ❌ No background scanning
* ❌ No ML inference during scan
* ❌ No network mutation

Scanning is **observation**, not attack.

---

## REQUIRED STRUCTURE

```
/network-scanner/
  schema/
    asset.schema.json
    service.schema.json
    topology-edge.schema.json
    cve-match.schema.json
  engine/
    active_scanner.py        # nmap-based, bounded
    passive_discoverer.py    # DPI / flow-based input
    topology_builder.py      # immutable graph
    cve_matcher.py           # offline CVE correlation
  data/
    cve_db/                  # offline NVD snapshot
  api/
    scanner_api.py
  cli/
    scan_network.py
    build_topology.py
  README.md
```

---

## DISCOVERY REQUIREMENTS

### Active Scanning (Bounded)

* Uses **nmap only**
* Explicit scan scope (CIDR, interface)
* Explicit port list (no full sweep by default)
* Rate-limited
* Produces:

  * assets
  * open services
  * banners
* Scan execution must be **explicitly triggered**

### Passive Discovery

* Consumes:

  * DPI Probe outputs
  * flow metadata
* No packet crafting
* No injection
* Read-only ingestion

---

## TOPOLOGY REQUIREMENTS

* Topology is a **fact graph**
* Nodes:

  * hosts
  * network devices
  * services
* Edges:

  * communicates_with
  * hosts_service
  * routes_through
* All edges are:

  * directed
  * timestamped
  * immutable

---

## CVE MATCHING REQUIREMENTS

* Uses **offline NVD snapshot**
* Banner/service-based matching only
* No exploitability scoring
* Produces:

  * possible_cve_id
  * match_reason
  * confidence (LOW | MEDIUM | HIGH)
* Deterministic matching rules only

---

## REQUIRED INTEGRATIONS

Network Scanner MUST integrate with:

* Audit Ledger (scan start/end, scope, results)
* Threat Graph Engine (entity + edges)
* KillChain & Forensics (evidence references)
* Global Validator (replayability)

---

## PASS / FAIL

PASS only if:

* Scans are explicit and bounded
* Same scan → same results
* No network mutation occurs
* Topology can be rebuilt deterministically
* CVE matching is offline and explainable
* Validator can replay discovery

FAIL if:

* Any implicit scanning exists
* Any exploit-like behavior exists
* Any hidden scope expansion
* Any nondeterminism

---

## OUTPUT EXPECTATION

* Production-grade Network Scanner & Topology Engine
* Frozen schemas
* Deterministic discovery
* Offline CVE matching
* Immutable topology graphs
* Ready for **Phase I — Deception Framework**

Do **not** build deception yet.
Do **not** add remediation.
Do **not** add schedulers.

Build **Network Scanner & Topology Engine only**.

****Promot end****


****Promot Start****

You are continuing **RansomEye — Military-Grade Enterprise Cyber Defense Platform**.
All previous subsystems are **authoritative, frozen, deterministic, validator-verifiable**.

This is **PHASE I — Deception Framework (Active Defense, Non-Destructive)**.

This phase introduces **controlled deception** to **observe attacker behavior**, not to block, exploit, or retaliate.

---

## OBJECTIVE

Build a **Deception Framework** that:

* Deploys **decoy assets** (hosts, services, credentials, files)
* Attracts attacker interaction
* Generates **high-confidence signals**
* Produces **evidence-grade telemetry**
* Never interferes with production assets

Deception is **observation with intent**, not enforcement.

---

## ABSOLUTE CONSTRAINTS (NON-NEGOTIABLE)

* ❌ No counter-attacks
* ❌ No malware execution
* ❌ No real credential exposure
* ❌ No production host modification
* ❌ No automatic blocking
* ❌ No retaliation logic
* ❌ No background autonomy
* ❌ No dynamic learning or ML here

Everything is **explicit, deterministic, reversible**.

---

## REQUIRED STRUCTURE

```
/deception/
  schema/
    decoy.schema.json
    interaction.schema.json
    deployment.schema.json
  engine/
    decoy_registry.py        # Immutable decoy definitions
    deployment_engine.py     # Explicit deployment only
    interaction_collector.py # Interaction capture
    signal_builder.py        # High-confidence signals
  integrations/
    linux_agent_hooks.py
    network_scanner_hooks.py
  api/
    deception_api.py
  cli/
    deploy_decoy.py
    collect_interactions.py
  README.md
```

---

## DECOY TYPES (MANDATORY)

Must support **all** below, each as **data-defined**, not code:

1. **Host Decoys**

   * Fake Linux/Windows hosts
   * Never real production IPs

2. **Service Decoys**

   * Fake SSH / SMB / HTTP banners
   * Banner-only, no real backend

3. **Credential Decoys**

   * Honey credentials
   * Cryptographically tagged
   * Never valid in real systems

4. **File / Artifact Decoys**

   * Fake configs, keys, documents
   * Read-only access

---

## INTERACTION CAPTURE

Every interaction must record:

* Decoy ID
* Interaction type (auth_attempt, scan, access, command)
* Source (IP, host, process)
* Timestamp
* Evidence reference
* Confidence level (HIGH by default)

No interaction is dropped.
No aggregation at capture time.

---

## SIGNAL REQUIREMENTS

Signals produced by deception must be:

* **High confidence by design**
* Deterministic
* Explicitly explainable
* Chain-of-custody protected

Signals flow into:

* KillChain & Forensics
* Threat Graph
* Risk Index
* Alert Engine
* System Explanation Engine (SEE)

---

## REQUIRED INTEGRATIONS

Deception Framework MUST integrate with:

* Audit Ledger (deployment, interaction, teardown)
* Network Scanner (topology-aware placement)
* Linux Agent (host-level decoys)
* Threat Graph (entity + edge creation)
* KillChain & Forensics (evidence)
* Global Validator (replayability)

---

## PASS / FAIL

PASS only if:

* Decoys are isolated from production
* No real credentials are exposed
* Same deployment → same behavior
* Interactions are immutable facts
* Signals are deterministic and explainable
* Validator can replay interactions

FAIL if:

* Any real asset is touched
* Any exploit logic exists
* Any automatic retaliation exists
* Any nondeterminism appears

---

## OUTPUT EXPECTATION

* Production-grade **Deception Framework**
* Frozen schemas
* Explicit deployment
* Evidence-grade interaction capture
* High-confidence signals
* Ready for **Phase J — Threat Intel Feed & IOC Engine**

Do **not** build Threat Intel yet.
Do **not** add blocking or remediation.
Do **not** add ML.

Build **Deception Framework only**.

****Promot end****


Promot Start*

You are continuing RansomEye v1.0 – Enterprise & Military-Grade Build.

WORK UNIT: Core Installer Corrections (Blocking Fixes)

STRICT CONTEXT (DO NOT VIOLATE)

Core code is frozen

Installer must NOT modify Core logic

❌ No runtime fixes inside installer

❌ No new features

❌ No schema or contract changes

This task is installer-only corrections.

REQUIRED FIXES (ALL MANDATORY)
1. Credential Correction (CRITICAL)

Across the installer:

Username must be exactly: gagan

Password must be exactly: gagan

Fix all occurrences including:

env file generation

DB config

health checks

README examples

No variants. No hashes. No doubles.

2. Remove Core Runtime Modification

Revert any Core code changes introduced during installer creation

Installer must:

Copy pre-built Core artifacts

Start Core as-is

If Core startup requires uvicorn:

Installer must call it

NOT modify Core code

3. Re-run Installer Validation

Install on clean system

Start Core

Health check must pass

Uninstall must fully clean system

OUTPUT EXPECTATION

Return:

Confirmation of credential correction

Confirmation no Core code was modified

Confirmation installer works end-to-end

Do NOT summarize code.

Begin immediately.

Promot end*


****Promot Start****

You are continuing **RansomEye — Military-Grade Enterprise Cyber Defense Platform**.
All prior subsystems are **authoritative, frozen, deterministic, validator-verifiable**.

This is **PHASE J — Threat Intelligence Feed & IOC Engine (Deterministic, Offline-First)**.

This phase establishes **trusted external and internal intelligence ingestion** without creating enforcement, bias, or hidden logic.

---

## OBJECTIVE

Build a **Threat Intelligence & IOC Engine** that:

* Ingests **external and internal intelligence feeds**
* Normalizes indicators into **immutable facts**
* Correlates IOCs with **existing evidence**
* Feeds **KillChain, Threat Graph, Risk Index, Alert Engine**
* Remains **offline-capable and deterministic**

Threat intel **informs**, it never decides.

---

## ABSOLUTE CONSTRAINTS (NON-NEGOTIABLE)

* ❌ No automatic blocking
* ❌ No enrichment mutation of incidents
* ❌ No trust escalation
* ❌ No ML or heuristics
* ❌ No live internet dependency at runtime
* ❌ No prioritization logic
* ❌ No scoring here

IOC ingestion ≠ threat judgment.

---

## REQUIRED STRUCTURE

```
/threat-intel/
  schema/
    ioc.schema.json
    intel-source.schema.json
    correlation.schema.json
  engine/
    feed_ingestor.py        # Offline snapshot ingestion
    normalizer.py           # Canonical IOC normalization
    deduplicator.py         # Hash-based IOC deduplication
    correlator.py           # Evidence ↔ IOC correlation
  storage/
    intel_store.py          # Immutable IOC storage
  api/
    intel_api.py
  cli/
    ingest_feed.py
    correlate_iocs.py
  README.md
```

---

## SUPPORTED IOC TYPES (MANDATORY)

Must support **explicit enumeration**:

* IP address
* Domain
* URL
* File hash (MD5, SHA1, SHA256)
* Email address
* Registry key
* Process name
* Mutex
* User agent

No free-form indicators.

---

## INTEL SOURCES

Must support **signed, versioned snapshots**:

* Public feeds (MISP, NVD-derived, CERT, ISAC)
* Internal sources:

  * Deception Framework interactions
  * Incident artifacts
  * Forensics evidence
* Manual analyst-submitted feeds (signed)

Runtime operation must be **offline-only**.

---

## CORRELATION RULES

IOC correlation must be:

* Deterministic
* Evidence-based
* Non-mutating

Correlation outputs are **facts**, not decisions.

Examples:

* IOC hash matches forensic artifact hash
* Domain IOC matches network scanner service
* IP IOC matches alert source

---

## REQUIRED INTEGRATIONS

Threat Intel Engine MUST integrate with:

* Audit Ledger (ingestion, correlation)
* KillChain & Forensics (evidence correlation)
* Threat Graph (entity + edge creation)
* Risk Index (signal input only)
* Alert Engine (context only)
* System Explanation Engine (SEE)
* Global Validator (replayability)

---

## PASS / FAIL

PASS only if:

* IOC storage is immutable
* Feeds are signed and versioned
* Correlation is deterministic
* Runtime has no network access
* Validator can replay correlations
* No decision logic exists

FAIL if:

* Any IOC causes automatic action
* Any enrichment mutates facts
* Any heuristic or ML appears
* Any runtime internet dependency exists

---

## OUTPUT EXPECTATION

* Production-grade **Threat Intelligence & IOC Engine**
* Frozen schemas
* Deterministic ingestion & correlation
* Offline-first operation
* Evidence-anchored intelligence

After completion, system proceeds to
**PHASE K — HNMP Engine (Host / Network / Malware / Process)**.

****Promot end****



****Promot Start****

You are continuing **RansomEye — Military-Grade Enterprise Cyber Defense Platform**.
All completed subsystems are **frozen, authoritative, deterministic, replayable, validator-verifiable**.

This is **PHASE K — HNMP Engine (Host / Network / Malware / Process Intelligence Core)**.

This phase establishes the **lowest-level, evidence-grade behavioral intelligence layer** that all higher reasoning depends on.

---

## OBJECTIVE

Build the **HNMP Engine** that provides **ground-truth behavioral facts** across:

* **Host** (user, privilege, filesystem, memory)
* **Network** (flows, connections, DNS, DPI outputs)
* **Malware** (artifacts, hashes, behaviors)
* **Process** (execution, parent/child, injections)

HNMP produces **facts only**, never conclusions.

---

## ABSOLUTE CONSTRAINTS (NON-NEGOTIABLE)

* ❌ No scoring
* ❌ No ML
* ❌ No heuristics
* ❌ No enforcement
* ❌ No alerting
* ❌ No aggregation logic
* ❌ No implicit inference
* ❌ No mutation of upstream data

HNMP is **observation and normalization only**.

---

## REQUIRED STRUCTURE

```
/hnmp/
  schema/
    host-event.schema.json
    network-event.schema.json
    process-event.schema.json
    malware-event.schema.json
    hnmp-correlation.schema.json
  engine/
    host_normalizer.py
    network_normalizer.py
    process_normalizer.py
    malware_normalizer.py
    correlator.py
  storage/
    hnmp_store.py
  api/
    hnmp_api.py
  cli/
    ingest_hnmp.py
    correlate_hnmp.py
  README.md
```

---

## DATA SOURCES (MANDATORY)

HNMP must ingest **only signed, validated inputs** from:

* Linux Agent (eBPF, procfs, audit)
* Windows Agent (ETW, registry, process telemetry)
* DPI Probe (flows, L7 metadata)
* Forensics Engine (artifacts, memory dumps)
* Deception Framework (interactions)
* Threat Intel Engine (IOC matches)

No raw packet capture storage.

---

## EVENT TYPES (MANDATORY)

### Host Events

* User login/logout
* Privilege escalation
* File creation/modification
* Registry change (Windows)
* Credential access attempt

### Network Events

* Flow start/end
* DNS query/response
* Protocol detection
* TLS metadata (no payload)

### Process Events

* Process start/exit
* Parent/child linkage
* Injection attempt
* Suspicious flags (explicit, no inference)

### Malware Events

* Hash observation
* Execution attempt
* Artifact discovery
* Sandbox verdict reference (no scoring)

---

## CORRELATION RULES

Correlation is **strictly factual**:

* Process ↔ network flow
* Process ↔ file artifact
* File artifact ↔ malware hash
* User ↔ process
* Host ↔ network identity

No campaign inference here
(No timelines, no killchain logic)

---

## REQUIRED INTEGRATIONS

HNMP Engine MUST integrate with:

* Audit Ledger (all ingestion & correlation)
* KillChain & Forensics (input + downstream)
* Threat Graph (entity + edge generation)
* Alert Engine (context input only)
* Risk Index (signal input only)
* System Explanation Engine (fact substrate)
* Global Validator (full replay)

---

## DETERMINISM RULES

* Same inputs → same outputs
* Canonical timestamps
* Explicit field ordering
* No time windows
* No implicit joins
* No default assumptions

---

## PASS / FAIL

PASS only if:

* All schemas have **zero optional fields**
* Storage is immutable
* Correlation produces facts only
* No decision logic exists
* Validator can fully reconstruct HNMP state
* All events are audit-anchored

FAIL if:

* Any scoring exists
* Any ML appears
* Any inference sneaks in
* Any enforcement happens
* Any event mutates upstream data

---

## OUTPUT EXPECTATION

* **HNMP Engine** as the factual backbone of RansomEye
* Immutable behavioral substrate
* Deterministic, replayable intelligence
* Court-defensible evidence layer

After completion, system proceeds to:

**PHASE L — DPI Probe Advanced Engine (10G / eBPF / AF_PACKET Fast-Path)**

****Promot end****



****Promot Start****

You are continuing **RansomEye — Military-Grade Enterprise Cyber Defense Platform**.
All previously completed subsystems are **frozen, authoritative, deterministic, replayable, validator-verifiable**.

This is **PHASE L — DPI Probe Advanced Engine (10G / eBPF / AF_PACKET Fast-Path)**.

This phase upgrades the DPI Probe from a **functional sensor** to a **carrier-grade, high-performance network intelligence engine** capable of sustaining **10G+ traffic** with **provable performance and privacy guarantees**.

---

## OBJECTIVE

Build the **Advanced DPI Probe Engine** that provides:

* Line-rate (10G+) traffic observation
* Flow-level behavioral ML (local, bounded, explainable)
* Asset classification (device / role inference)
* Privacy-preserving redaction modes
* Deterministic chunked upload with cryptographic enforcement
* eBPF / AF_PACKET fast paths
* Full integration with HNMP, Threat Graph, KillChain, Risk Index

---

## ABSOLUTE CONSTRAINTS (NON-NEGOTIABLE)

* ❌ No payload storage
* ❌ No packet replay
* ❌ No MITM
* ❌ No active traffic modification
* ❌ No credential extraction
* ❌ No decryption of encrypted payloads
* ❌ No cloud dependency
* ❌ No kernel patching

This is **observation only**, at scale.

---

## REQUIRED STRUCTURE

```
/dpi-advanced/
  schema/
    flow-record.schema.json
    asset-profile.schema.json
    upload-chunk.schema.json
    privacy-policy.schema.json
  fastpath/
    af_packet_capture.c
    ebpf_flow_tracker.c
  engine/
    flow_assembler.py
    behavior_model.py
    asset_classifier.py
    privacy_redactor.py
    uploader.py
  performance/
    throughput_benchmark.py
    latency_benchmark.py
    cpu_profile.md
  api/
    dpi_api.py
  cli/
    run_probe.py
    benchmark_probe.py
  README.md
```

---

## PERFORMANCE TARGETS (MANDATORY)

You must **prove**, not claim:

* **10 Gbps sustained throughput**
* **<5% CPU per 1 Gbps**
* **Zero packet drops at 64-byte packets (AF_PACKET)**
* **Bounded memory (ring buffers only)**
* **Backpressure under congestion (no OOM)**

Benchmarks must be reproducible.

---

## FAST-PATH IMPLEMENTATION

### AF_PACKET

* PACKET_MMAP (TPACKET_V3)
* RX ring only
* Zero-copy
* CPU affinity pinning

### eBPF

* Flow tuple extraction
* L7 protocol fingerprinting (metadata only)
* Per-flow counters
* No loops
* Verifier-safe

---

## FLOW-LEVEL ML (STRICTLY LOCAL)

Allowed:

* Sequence models on **flow metadata only**
* Packet size, timing, flags, protocol hints

Forbidden:

* Payload inspection
* Cross-host learning
* Cloud inference

Outputs:

* **Behavioral profile IDs**
* Confidence bands
* Feature vectors only (stored in HNMP-compatible form)

---

## ASSET CLASSIFICATION

Infer:

* Device type (server, workstation, IoT, network device)
* Role (DB, DC, proxy, printer)

Based on:

* Port behavior
* Protocol mix
* Flow directionality

Must be:

* Deterministic
* Explainable
* Replayable

---

## PRIVACY MODES (MANDATORY)

Implement **policy-driven redaction**:

* **STRICT**

  * Hash IPs
  * Truncate ports
  * No DNS labels
* **BALANCED**

  * Partial IP retention
  * Domain second-level only
* **FORENSIC**

  * Full metadata (no payload)

Redaction happens **before storage and upload**.

---

## UPLOAD PIPELINE

* Chunked uploads
* Per-chunk SHA256
* Signed chunk manifests
* Backpressure-aware
* Resume-safe
* Offline buffering (bounded)

No silent drops.

---

## REQUIRED INTEGRATIONS

Must integrate with:

* HNMP Engine (flow → network facts)
* Threat Graph (asset & flow edges)
* KillChain & Forensics (evidence references)
* Risk Index (signals only)
* Alert Engine (context only)
* Audit Ledger (all actions)
* Global Validator (full replay)

---

## DETERMINISM RULES

* Same packets → same flows
* Same flows → same features
* Same policies → same redaction
* Same input → same output hashes

No entropy.

---

## PASS / FAIL

PASS only if:

* 10G benchmark is reproducible
* CPU & memory profiles documented
* Privacy redaction provably enforced
* Upload integrity is cryptographically verifiable
* No payload is ever persisted
* Validator can replay outputs

FAIL if:

* Any payload leaks
* Any inference is implicit
* Any performance claim is unproven
* Any privacy mode is bypassable

---

## OUTPUT EXPECTATION

* **Carrier-grade DPI engine**
* Privacy-first by design
* Deterministic, replayable, explainable
* Suitable for regulated and military environments

After completion, system proceeds to:

**PHASE M — Advanced UBA (Insider Threat & Identity-Behavior Fusion)**

****Promot end****

****Promot Start****

### PHASE M1 — Advanced UBA Core (Identity–Behavior Ground Truth Layer)

**Objective (NON-NEGOTIABLE)**
Build the **User Behavior Analytics Core** as a **purely factual, evidence-grade subsystem** that establishes **per-identity behavioral ground truth** without scoring, prediction, ML black boxes, or enforcement.

This phase is the **foundation** for insider threat detection and must be **deterministic, replayable, and regulator-safe**.

---

## HARD CONSTRAINTS (ABSOLUTE)

1. **NO hardcoded IPs, paths, users, domains, or interfaces**

   * All paths, endpoints, and identifiers come from environment variables or manifests.
2. **NO ML models in M1**

   * This phase is **ground truth only**, not inference.
3. **NO scoring, alerts, risk, or conclusions**

   * Facts only.
4. **NO optional fields in schemas**

   * Zero ambiguity.
5. **NO background schedulers**

   * Explicit ingestion only.
6. **Every action must emit an Audit Ledger entry**
7. **Replayable from zero using Global Validator**

---

## SUBSYSTEM NAME (STRICT)

**`uba-core`**
(No “phase”, no numbers in names)

---

## DELIVERABLES TO BUILD

### 1. Schemas (Frozen, Zero Optional Fields)

Create under `/uba-core/schema/`

1. `identity.schema.json`

   * user_id
   * identity_type (human / service / machine)
   * auth_domain
   * creation_timestamp
   * source_system
   * canonical_identity_hash

2. `behavior-event.schema.json`

   * event_id
   * identity_id
   * event_type (login, file_access, process_start, network_access, privilege_use, policy_override)
   * source_component (linux-agent, windows-agent, dpi, hnmp, ir, deception)
   * resource_id
   * action
   * timestamp
   * host_id
   * evidence_ref

3. `identity-baseline.schema.json`

   * identity_id
   * baseline_window_start
   * baseline_window_end
   * observed_event_types
   * observed_hosts
   * observed_time_buckets
   * observed_privileges
   * baseline_hash

---

### 2. Engine Components

Under `/uba-core/engine/`

1. `identity_resolver.py`

   * Deterministically map events → canonical identity
   * No heuristics
   * Explicit precedence rules only

2. `behavior_normalizer.py`

   * Canonicalize timestamps
   * Canonicalize event types
   * Canonicalize identity references

3. `baseline_builder.py`

   * Builds **historical baselines**
   * Window is explicit (env-configured)
   * Output is immutable
   * No scoring, only aggregation

4. `baseline_hasher.py`

   * Deterministic SHA256 hash of baseline content
   * Used for drift comparison later (Phase M2)

---

### 3. Storage (Immutable)

Under `/uba-core/storage/`

* `uba_store.py`

  * Append-only storage
  * No updates
  * No deletes
  * Baselines are versioned by time window

---

### 4. API Layer

Under `/uba-core/api/uba_api.py`

Endpoints (read/write split):

* `ingest_behavior_event()`
* `build_identity_baseline()`
* `get_identity_baseline()`

All API calls:

* Require validated schema input
* Emit audit ledger entries
* Fail-closed

---

### 5. CLI Tools (Deterministic)

Under `/uba-core/cli/`

* `ingest_behavior.py`
* `build_baseline.py`
* `export_baseline.py`

---

### 6. Audit Ledger Integration (MANDATORY)

Every one of the following emits a ledger entry:

* Identity creation
* Behavior event ingestion
* Baseline build
* Baseline export

Ledger action types must be **new and explicit**:

* `UBA_IDENTITY_CREATED`
* `UBA_BEHAVIOR_INGESTED`
* `UBA_BASELINE_BUILT`
* `UBA_BASELINE_EXPORTED`

---

### 7. Global Validator Compatibility

Validator must be able to:

* Rebuild all baselines from raw events
* Verify baseline hashes
* Detect missing or altered events
* Confirm no inference occurred

---

### 8. Documentation

Create `/uba-core/README.md` with:

* Threat model
* What UBA Core **does NOT do**
* Determinism guarantees
* Replay guarantees
* Regulatory posture (SOX, SOC2, ISO, Insider Threat compliance)
* Clear statement: **“UBA Core establishes facts, not intent.”**

---

## EXPLICITLY FORBIDDEN

* ❌ ML
* ❌ Risk scoring
* ❌ Alerts
* ❌ Anomaly labels
* ❌ “Suspicious” flags
* ❌ Implicit inference
* ❌ Background jobs
* ❌ Optional fields
* ❌ Human-readable free text reasoning

---

## SUCCESS CRITERIA (PASS / FAIL)

PASS only if:

* All schemas have **zero optional fields**
* All outputs are replayable
* No inference logic exists
* Baselines rebuild bit-for-bit identical
* Audit Ledger contains full chain
* Validator passes reconstruction

FAIL if:

* Any heuristic exists
* Any scoring exists
* Any path/IP/interface is hardcoded
* Any optional field exists

---

**NEXT PHASE (DO NOT BUILD YET):**
PHASE M2 — Behavioral Drift Detection (Deterministic Delta Layer)

****Promot end****


****Promot Start****

### PHASE M2 — Behavioral Drift Detection Engine (Deterministic Delta Layer)

**Objective (NON-NEGOTIABLE)**
Build the **Behavioral Drift Detection Engine** as a **purely deterministic delta-analysis layer** on top of **UBA Core baselines**.

This phase detects **behavioral change**, **not intent**, **not risk**, **not anomaly labels**.
It answers only one question:

> *“Has observed behavior deviated from its own historical baseline, and how?”*

Nothing more.

---

## HARD CONSTRAINTS (ABSOLUTE)

1. **NO ML, NO statistics, NO probabilistic models**
2. **NO risk scores, NO alerts, NO confidence labels**
3. **NO words like suspicious, malicious, abnormal**
4. **NO optional fields in schemas**
5. **NO background schedulers**
6. **NO hardcoded paths, IPs, users, domains**
7. **Every delta must be reconstructable bit-for-bit**
8. **Every action emits Audit Ledger entries**
9. **UBA Core remains read-only**

---

## SUBSYSTEM NAME (STRICT)

**`uba-drift`**

(No phase numbers in names, no shortcuts)

---

## ROLE IN ARCHITECTURE (IMPORTANT)

* **Consumes**:

  * UBA Core baselines
  * UBA behavior events

* **Produces**:

  * **Behavioral delta facts only**

* **Does NOT**:

  * Decide
  * Judge
  * Alert
  * Score
  * Predict
  * Enforce

This layer exists **solely to quantify change**.

---

## DELIVERABLES TO BUILD

---

## 1. Schemas (Frozen, Zero Optional Fields)

Create under `/uba-drift/schema/`

### 1. `behavior-delta.schema.json`

Fields (ALL REQUIRED):

* delta_id
* identity_id
* baseline_hash
* observation_window_start
* observation_window_end
* delta_type

  * NEW_EVENT_TYPE
  * NEW_HOST
  * NEW_TIME_BUCKET
  * NEW_PRIVILEGE
  * FREQUENCY_SHIFT
* baseline_value
* observed_value
* delta_magnitude
* first_seen_timestamp
* last_seen_timestamp

⚠️ **delta_magnitude is numeric but NOT a score**
It is a **count difference or presence delta**, nothing else.

---

### 2. `delta-summary.schema.json`

Fields (ALL REQUIRED):

* identity_id
* baseline_hash
* observation_window_start
* observation_window_end
* total_deltas
* delta_types_present
* summary_hash

---

## 2. Engine Components

Under `/uba-drift/engine/`

### 1. `delta_comparator.py`

* Compares:

  * Baseline facts vs observation window facts
* Produces:

  * Explicit deltas
* Rules:

  * Explicit comparison logic
  * No heuristics
  * No thresholds unless environment-defined

---

### 2. `window_builder.py`

* Builds explicit observation windows
* Window size comes from env vars
* No implicit rolling windows

---

### 3. `delta_hasher.py`

* Deterministic SHA256 over delta content
* Enables validator replay

---

### 4. `delta_classifier.py`

⚠️ Misleading name clarified:

* **Classifies delta TYPE only**
* NOT severity
* NOT intent
* NOT threat

---

## 3. Storage (Immutable)

Under `/uba-drift/storage/`

### `delta_store.py`

* Append-only
* No updates
* No deletes
* Deltas versioned by window

---

## 4. API Layer

Under `/uba-drift/api/drift_api.py`

Endpoints:

* `compute_behavior_deltas()`
* `get_behavior_deltas(identity_id)`
* `get_delta_summary(identity_id)`

Rules:

* All inputs schema-validated
* All outputs immutable
* All calls ledger-anchored

---

## 5. CLI Tools

Under `/uba-drift/cli/`

* `compute_deltas.py`
* `export_deltas.py`
* `export_delta_summary.py`

---

## 6. Audit Ledger Integration (MANDATORY)

New ledger action types:

* `UBA_DELTA_COMPUTED`
* `UBA_DELTA_EXPORTED`
* `UBA_DELTA_SUMMARY_BUILT`

Every delta computation is **auditable and replayable**.

---

## 7. Global Validator Compatibility

Validator MUST be able to:

* Recompute deltas from:

  * Raw behavior events
  * Baselines
* Verify:

  * Delta hashes
  * Summary hashes
* Detect:

  * Missing events
  * Altered baselines
  * Tampering

---

## 8. Documentation

Create `/uba-drift/README.md` with:

* Explicit statement:

  > “Behavioral drift ≠ malicious behavior”
* What this subsystem **does NOT do**
* Determinism guarantees
* How regulators should read delta data
* How later layers MAY consume (Risk, IR, Policy)

---

## EXPLICITLY FORBIDDEN

* ❌ Machine learning
* ❌ Z-scores
* ❌ Percentiles
* ❌ “Anomaly”
* ❌ “Outlier”
* ❌ “Suspicious”
* ❌ Auto-thresholding
* ❌ Background execution
* ❌ Human-readable judgment text

---

## SUCCESS CRITERIA (PASS / FAIL)

### PASS only if:

* Deltas rebuild identically from raw facts
* No inference or scoring exists
* All schemas have zero optional fields
* Baselines remain untouched
* Audit ledger is complete
* Validator passes replay

### FAIL if:

* Any threshold is implicit
* Any scoring is added
* Any heuristic is used
* Any hardcoded value exists

---

## NEXT PHASE (DO NOT BUILD YET)

**PHASE M3 — UBA Signal Interpretation (Risk-Consuming, Not Risk-Producing)**
This is where **other engines** may consume drift — not here.

****Promot end****


****Promot Start****

### PHASE M3 — UBA Signal Interpretation Layer

**(Risk-Consuming, Authority-Bound, Explanation-Anchored)**

---

## OBJECTIVE (ABSOLUTE)

Build **UBA Signal Interpretation** as a **consumer-only layer** that interprets **UBA Drift deltas** in **context**, without producing *new facts*, *new risk*, or *new authority*.

This layer answers **only**:

> “How should downstream systems *understand* behavioral drift when combined with other verified facts?”

It **does not**:

* Generate risk scores
* Create alerts
* Escalate incidents
* Modify baselines
* Infer intent

---

## CORE ARCHITECTURAL POSITION

```
UBA Core (facts)
   ↓
UBA Drift (change deltas)
   ↓
UBA Signal Interpretation  ← YOU ARE HERE
   ↓
Risk Index / Policy / IR / SEE (consumers only)
```

This layer **never becomes a source of truth**.
It is a **lens**, not an authority.

---

## HARD CONSTRAINTS (NON-NEGOTIABLE)

1. **Consumes deltas, never produces facts**
2. **No scoring, no thresholds, no probabilities**
3. **No ML, no statistics**
4. **No autonomous decisions**
5. **No alerts, no enforcement**
6. **No optional schema fields**
7. **Environment-driven only**
8. **Audit-anchored**
9. **Explanation-first (SEE compatible)**
10. **Human authority respected (HAF compatible)**

---

## SUBSYSTEM NAME (STRICT)

**`uba-signal`**

(No phase numbers. No shortcuts.)

---

## DELIVERABLES TO BUILD

---

## 1. Schemas (Frozen, Zero Optional Fields)

Create under `/uba-signal/schema/`

### 1. `interpreted-signal.schema.json`

**ALL FIELDS REQUIRED**

* signal_id
* identity_id
* delta_ids (array)
* interpretation_type

  * CONTEXTUAL_SHIFT
  * ROLE_EXPANSION
  * ACCESS_SURFACE_CHANGE
  * TEMPORAL_BEHAVIOR_CHANGE
* contextual_inputs

  * references only (killchain_id, graph_id, incident_id, etc.)
* explanation_bundle_id
* authority_required (boolean)
* downstream_consumers (array)
* signal_hash
* created_timestamp

⚠️ **interpretation_type is descriptive, not evaluative**

---

### 2. `signal-summary.schema.json`

* identity_id
* observation_window
* signal_count
* interpretation_types_present
* summary_hash

---

## 2. Engine Components

Under `/uba-signal/engine/`

### 1. `signal_interpreter.py`

* Consumes:

  * UBA Drift deltas
  * Context references (read-only)
* Produces:

  * Interpreted signals
* Rules:

  * Explicit mappings only
  * No implicit logic
  * No thresholds unless env-defined

---

### 2. `context_resolver.py`

* Pulls **read-only** context from:

  * KillChain
  * Threat Graph
  * Incident Store
* Never infers
* Never mutates

---

### 3. `signal_hasher.py`

* Deterministic SHA256 over canonical JSON

---

## 3. Storage (Immutable)

Under `/uba-signal/storage/`

### `signal_store.py`

* Append-only
* Versioned by observation window
* No updates, no deletes

---

## 4. API Layer

Under `/uba-signal/api/signal_api.py`

Endpoints:

* `interpret_deltas()`
* `get_signals(identity_id)`
* `get_signal_summary(identity_id)`

All calls:

* Schema-validated
* Ledger-anchored
* Deterministic

---

## 5. CLI Tools

Under `/uba-signal/cli/`

* `interpret_signals.py`
* `export_signals.py`
* `export_signal_summary.py`

---

## 6. Audit Ledger Integration (MANDATORY)

New ledger actions:

* `UBA_SIGNAL_INTERPRETED`
* `UBA_SIGNAL_EXPORTED`
* `UBA_SIGNAL_SUMMARY_BUILT`

No silent interpretations.

---

## 7. SEE & HAF INTEGRATION (MANDATORY)

### SEE (System Explanation Engine)

* Every interpreted signal **must reference** an explanation bundle
* Explanation must trace:

  * Drift → Context → Interpretation

### HAF (Human Authority Framework)

* If `authority_required = true`

  * Downstream execution **MUST require human signature**
  * This layer **does not invoke authority itself**

---

## 8. GLOBAL VALIDATOR REQUIREMENTS

Validator must be able to:

* Rebuild signals from:

  * Drift deltas
  * Context references
* Verify:

  * Signal hashes
  * Explanation references
* Detect:

  * Missing deltas
  * Altered interpretation logic
  * Unauthorized execution attempts

---

## 9. DOCUMENTATION

Create `/uba-signal/README.md` with:

* Clear statement:

  > “Signals describe context, not danger.”
* Explicit separation from:

  * UBA Drift
  * Risk Index
  * Policy Engine
* Regulatory interpretation guidance
* Determinism guarantees

---

## EXPLICITLY FORBIDDEN

* ❌ Risk scoring
* ❌ Severity labels
* ❌ Alert generation
* ❌ Automatic escalation
* ❌ “Suspicious” / “Threatening” language
* ❌ Background execution
* ❌ ML or heuristics
* ❌ Threshold tuning logic

---

## SUCCESS CRITERIA (PASS / FAIL)

### PASS only if:

* Signals rebuild bit-for-bit
* No scoring exists
* All schemas have zero optional fields
* No baseline or drift mutation
* Ledger is complete
* Validator replay passes

### FAIL if:

* Any implicit inference exists
* Any alert logic appears
* Any authority bypass exists
* Any scoring appears

---

## NEXT PHASE (DO NOT BUILD YET)

**PHASE M4 — UBA Risk Consumption (Enterprise Risk Index Integration)**
Risk consumes signals — signals never produce risk.

****Promot end****


****Promot Start****

### PHASE M4 — UBA Risk Consumption

**(Enterprise Risk Index Integration — Signal-Consuming Only)**

---

## OBJECTIVE (ABSOLUTE)

Extend the **Enterprise Risk Index Engine** to **consume UBA Signals** as **contextual modifiers**, **never as risk producers**.

UBA **must never raise risk by itself**.
UBA **only explains why risk *already changed*** when correlated with other verified facts.

This phase answers **only**:

> “How does verified behavioral context *modulate* enterprise risk when other risk-producing systems already fired?”

---

## ARCHITECTURAL POSITION (DO NOT VIOLATE)

```
UBA Core        → facts
UBA Drift       → change
UBA Signal      → context
                     ↓
Enterprise Risk Index (THIS PHASE)
                     ↓
Policy / IR / Exec Reporting
```

UBA **does not generate risk**
UBA **does not trigger alerts**
UBA **does not escalate**

---

## HARD CONSTRAINTS (NON-NEGOTIABLE)

1. **UBA is a modifier, never a source**
2. **Risk Index remains the only risk authority**
3. **No new scores, no weights from UBA**
4. **UBA only adjusts confidence / explainability**
5. **All effects must be explanation-traceable**
6. **Deterministic, replayable**
7. **Environment-driven**
8. **Audit-ledger anchored**
9. **Validator-verifiable**
10. **Human authority preserved**

---

## CHANGES TO IMPLEMENT

### LOCATION

`/risk-index/`

---

## 1. Schema Extension (Frozen)

### Update `risk-score.schema.json`

Add **mandatory** fields:

* uba_signal_ids (array)
* uba_context_applied (boolean)
* risk_explanation_bundle_id
* context_modifiers (array of enums)

  * ROLE_EXPANSION_PRESENT
  * ACCESS_SURFACE_EXPANDED
  * TEMPORAL_SHIFT_PRESENT
  * CONTEXTUAL_SHIFT_PRESENT

⚠️ These are **descriptive**, not numeric.

No optional fields allowed.

---

## 2. Engine Changes

### Update `/engine/aggregator.py`

Add:

#### `apply_uba_context()`

Rules:

* Consumes **UBA Signals**
* Modifies:

  * explanation richness
  * confidence interpretation
* NEVER modifies:

  * base score calculation
  * decay math
  * normalization

If no UBA signals → no change.

---

### Update `/engine/normalizer.py`

* Ensure UBA context **cannot push score outside 0–100**
* Ensure **risk bands remain unchanged**

---

## 3. Explanation Integration (MANDATORY)

Every risk computation **must reference**:

* SEE explanation bundle that chains:

  ```
  Incident → KillChain → Graph → UBA Signal → Risk Index
  ```

No explanation → computation fails.

---

## 4. Audit Ledger Integration

New ledger events:

* `RISK_INDEX_COMPUTED_WITH_UBA_CONTEXT`
* `RISK_CONTEXT_APPLIED`

Ledger must record:

* Which UBA signals were consumed
* Which context modifiers applied
* Explanation bundle reference

---

## 5. API Changes

Update `/api/risk_api.py`

Expose:

* `get_risk_with_context(identity_id)`
* `get_risk_explanation(identity_id)`

Responses must include:

* base risk
* UBA context applied (true/false)
* explanation bundle ID

---

## 6. CLI Updates

Add:

* `compute_risk_with_uba.py`
* `export_risk_with_context.py`

---

## 7. Global Validator Updates

Validator must be able to:

* Recompute risk **with and without** UBA context
* Confirm:

  * Base score unchanged
  * Only context flags differ
* Verify explanation bundle integrity
* Detect unauthorized risk influence

---

## 8. DOCUMENTATION UPDATE

Update `/risk-index/README.md`

Add section:

### “UBA Integration Model”

Include explicit statement:

> “UBA does not increase risk.
> UBA explains *why* existing risk is interpreted the way it is.”

Include regulatory positioning:

* Insider threat ≠ malicious intent
* Behavioral drift ≠ threat
* Risk attribution remains multi-factor

---

## EXPLICITLY FORBIDDEN

* ❌ UBA-driven scoring
* ❌ UBA weight factors
* ❌ UBA-only risk increase
* ❌ Automatic escalation from UBA
* ❌ Behavioral intent inference
* ❌ ML involvement
* ❌ Threshold tuning

---

## PASS / FAIL CRITERIA

### PASS only if:

* Risk score identical with and without UBA
* Only explanation/context differs
* Validator replay succeeds
* No UBA influence without other risk signals
* Ledger is complete

### FAIL if:

* UBA alone changes risk
* Any scoring logic references UBA
* Any implicit severity exists
* Any authority bypass exists

---

## NEXT PHASE (DO NOT BUILD YET)

**PHASE M5 — UBA → Alert Interpretation (Human-Centric Alert Framing)**
UBA influences *how alerts are explained*, never when they are fired.

****Promot End****



****Promot Start*****

You are implementing the next **MANDATORY subsystem** for **RansomEye v1.0**.
You are not allowed to ask questions, simplify scope, or introduce optional behavior.
This is **military-grade, regulator-grade software**.
Follow architecture strictly. No shortcuts.

---

# PHASE M5 — UBA Alert Context Engine (Human-Centric, Non-Triggering)

## AUTHORITATIVE INTENT

This subsystem **does NOT create alerts**.
This subsystem **does NOT suppress alerts**.
This subsystem **does NOT escalate alerts**.
This subsystem **does NOT route alerts**.
This subsystem **does NOT score risk**.

**It ONLY explains alerts to humans using UBA context.**

UBA **frames understanding**, never authority.

---

## CORE PRINCIPLE (NON-NEGOTIABLE)

> **UBA may change how an alert is explained — never whether it exists.**

---

## REQUIRED SUBSYSTEM NAME

**`/uba-alert-context/`**

Do **NOT** name it:

* analyzer
* scorer
* evaluator
* enhancer
* intelligence
* inference

Correct name: **UBA Alert Context Engine**

---

## REQUIRED DELIVERABLES

### 1. Schema (Frozen, Zero Optional Fields)

Create schemas under:

```
/uba-alert-context/schema/
```

#### 1.1 `alert-context.schema.json`

**Purpose:** Human-facing contextual explanation attached to an alert

Required fields (ALL mandatory):

1. `alert_id` (UUID)
2. `context_block_id` (UUID)
3. `uba_signal_ids` (array of UUIDs)
4. `context_types` (array of enums)

   * CONTEXTUAL_SHIFT
   * ROLE_EXPANSION
   * ACCESS_SURFACE_CHANGE
   * TEMPORAL_BEHAVIOR_CHANGE
5. `human_readable_summary` (string, controlled vocabulary only)
6. `what_changed` (array of strings, factual)
7. `what_did_not_change` (array of strings, factual)
8. `interpretation_guidance` (enum)

   * INFORMATIONAL
   * CONTEXT_ONLY
   * REVIEW_RECOMMENDED
9. `explanation_bundle_id` (UUID, SEE mandatory)
10. `generated_at` (RFC3339 UTC)

**STRICT RULES**

* No judgment words (no suspicious, malicious, risky)
* No severity labels
* No probabilities
* No free prose outside controlled strings

---

### 2. Engine Implementation

Path:

```
/uba-alert-context/engine/
```

#### 2.1 `context_builder.py`

* Input:

  * Alert (read-only)
  * UBA Signals (read-only)
  * Explanation Bundle (SEE)
* Output:

  * Alert Context Block (immutable)

Rules:

* Deterministic
* Same inputs → same output
* Order-preserving
* No branching logic
* No ML
* No heuristics

#### 2.2 `context_hasher.py`

* Deterministic SHA256 hash of the context block
* Used for validator replay

---

### 3. Storage (Immutable)

Path:

```
/uba-alert-context/storage/
```

#### 3.1 `context_store.py`

* Append-only
* No updates
* No deletes
* Alert context blocks are immutable facts

---

### 4. API

Path:

```
/uba-alert-context/api/
```

#### 4.1 `alert_context_api.py`

Required endpoints (read/write strictly controlled):

* `build_context(alert_id)`
* `get_alert_context(alert_id)`
* `list_alert_contexts(incident_id)`

Rules:

* Read-only access to Alert Engine
* Read-only access to UBA Signal Store
* Write ONLY to context_store
* Emit audit ledger events:

  * `UBA_ALERT_CONTEXT_BUILT`
  * `UBA_ALERT_CONTEXT_RETRIEVED`

---

### 5. CLI Tools

Path:

```
/uba-alert-context/cli/
```

Required tools:

1. `build_alert_context.py`
2. `export_alert_context.py`

Both must be:

* Deterministic
* Offline
* Validator-replayable

---

### 6. Audit Ledger Integration (MANDATORY)

Every operation must emit ledger entries:

* Alert context build
* Alert context export
* Alert context retrieval

Ledger must include:

* alert_id
* context_block_id
* uba_signal_ids
* explanation_bundle_id

---

### 7. Explicit NON-FEATURES (FORBIDDEN)

You MUST NOT:

* Change alert severity
* Suppress alerts
* Escalate alerts
* Trigger notifications
* Modify routing
* Modify alert content
* Introduce ML
* Introduce risk math
* Introduce policy logic
* Introduce human authority
* Introduce automation

---

### 8. Integration Guarantees

* **Alert Engine remains authoritative**
* **UBA remains non-authoritative**
* **SEE remains explanation root**
* **HAF remains authority root**
* **Risk Index remains risk root**

This engine is **purely explanatory**.

---

### 9. Documentation (MANDATORY)

Create:

```
/uba-alert-context/README.md
```

Must include:

* Purpose statement
* Non-authority declaration
* Regulatory positioning
* Analyst guidance examples
* Failure semantics
* Validator replay guarantees

Include explicit statement:

> “Alert Context does not modify alerts. It explains alerts to humans using behavioral context.”

---

### 10. Validation Requirements

Must be verifiable that:

* Alerts exist without context
* Context can be removed without affecting alerts
* Validator can rebuild context from:

  * Audit Ledger
  * UBA Signals
  * Explanation Bundles
* Removing UBA does NOT break alert pipeline

---

## FINAL STATEMENT (MUST BE TRUE)

> UBA Alert Context changes **understanding**, never **outcomes**.

---

### DELIVERABLE EXPECTATION

When complete, you will report:

* File structure
* Schema field counts
* Explicit guarantees
* Verification results

No placeholders.
No TODOs.
No partial work.

****promot end*****


****Promot Start*****

You are implementing the **NEXT MANDATORY SUBSYSTEM** for **RansomEye v1.0**.
This is **not optional**, **not experimental**, and **not a UX feature**.
You are operating under **military-grade, regulator-grade constraints**.

You must **reason from architecture**, not just extend features.

---

# PHASE M6 — Human-Facing Explanation Assembly (Alert → Incident → Executive)

## AUTHORITATIVE INTENT

We now have **many correct explanation fragments**, but they are **scattered**:

* Alert explanation (Alert Engine)
* UBA Alert Context (M5)
* System Explanation Engine (SEE)
* Risk Index explanations
* KillChain timelines
* Threat Graph reasoning
* Human overrides (HAF)

This phase **does NOT create new explanations**.

This phase **assembles** them into **audience-specific explanation views**.

---

## CORE PRINCIPLE (NON-NEGOTIABLE)

> **One truth, many views. Never many truths.**

This engine **reorders, filters, and presents explanations**
without **changing meaning, authority, or causality**.

---

## REQUIRED SUBSYSTEM NAME

**`/explanation-assembly/`**

Do **NOT** name it:

* summarizer
* reporter
* narrator
* generator
* formatter (alone)

Correct name: **Explanation Assembly Engine**

---

## REQUIRED OUTPUT TYPES (STRICT)

This engine produces **views**, not facts.

### Supported views (EXACTLY these 4):

1. **SOC Analyst View**
2. **Incident Commander View**
3. **Executive / Board View**
4. **Regulator / Auditor View**

No others.
No free customization.
No dynamic templates.

---

## REQUIRED DELIVERABLES

### 1. Schema (Frozen, Zero Optional Fields)

Path:

```
/explanation-assembly/schema/
```

#### 1.1 `assembled-explanation.schema.json`

Required fields (ALL mandatory):

1. `assembled_explanation_id` (UUID)
2. `incident_id` (UUID)
3. `view_type` (enum)

   * SOC_ANALYST
   * INCIDENT_COMMANDER
   * EXECUTIVE
   * REGULATOR
4. `source_explanation_bundle_ids` (array of UUIDs)
5. `source_alert_ids` (array of UUIDs)
6. `source_context_block_ids` (array of UUIDs)
7. `source_risk_ids` (array of UUIDs)
8. `ordering_rules_applied` (array of enums)
9. `content_blocks` (array of structured objects)
10. `integrity_hash` (SHA256)
11. `generated_at` (RFC3339 UTC)

**STRICT RULES**

* No prose generation
* No paraphrasing
* No new facts
* No inference
* No compression logic
* No summarization logic

---

### 2. Engine Implementation

Path:

```
/explanation-assembly/engine/
```

#### 2.1 `assembly_engine.py`

Responsibilities:

* Read-only access to:

  * SEE bundles
  * Alert Context blocks
  * Risk explanations
  * KillChain timelines
  * Threat Graph paths
* Deterministically assemble explanations by **view_type**
* Apply **explicit ordering rules only**

Examples:

* SOC view → technical → chronological
* Executive view → risk → impact → accountability
* Regulator view → ledger → chain-of-custody → determinism

No heuristics.
No AI.
No summarization.

#### 2.2 `assembly_hasher.py`

* Deterministic SHA256 over canonical JSON
* Used by Global Validator

---

### 3. Storage (Immutable)

Path:

```
/explanation-assembly/storage/
```

#### 3.1 `assembly_store.py`

* Append-only
* Immutable records
* No updates
* No deletes

---

### 4. API

Path:

```
/explanation-assembly/api/
```

#### 4.1 `assembly_api.py`

Required endpoints:

* `assemble_incident_explanation(incident_id, view_type)`
* `get_assembled_explanation(assembled_explanation_id)`
* `list_assembled_explanations(incident_id)`

Rules:

* Read-only access to all upstream systems
* Write ONLY to assembly_store
* Emit audit ledger events:

  * `EXPLANATION_ASSEMBLED`
  * `EXPLANATION_RETRIEVED`

---

### 5. CLI Tools

Path:

```
/explanation-assembly/cli/
```

Required:

1. `assemble_explanation.py`
2. `export_explanation.py`

Must be:

* Deterministic
* Offline
* Validator-replayable

---

### 6. Explicit NON-FEATURES (FORBIDDEN)

You MUST NOT:

* Generate text
* Rewrite explanations
* Collapse explanations
* Hide causality
* Create “TL;DR”
* Score explanations
* Decide importance
* Introduce LLMs
* Modify existing explanation content

---

### 7. Audit Ledger Integration (MANDATORY)

Each assembly must emit:

* incident_id
* view_type
* all source IDs used
* integrity_hash

Ledger events:

* `EXPLANATION_ASSEMBLED`
* `EXPLANATION_EXPORTED`

---

### 8. Documentation

Create:

```
/explanation-assembly/README.md
```

Must include:

* Difference between explanation and assembly
* Why no summarization exists here
* Regulatory positioning
* Analyst vs Executive vs Regulator differences
* Failure semantics
* Validator guarantees

Include this **exact sentence**:

> “Explanation Assembly changes presentation, never meaning.”

---

### 9. Validation Requirements

Validator must be able to:

* Rebuild assembled explanations from:

  * Audit Ledger
  * SEE
  * UBA Alert Context
  * Risk Index
  * KillChain
* Verify integrity hash
* Confirm no missing or reordered facts

---

## FINAL STATEMENT (MUST HOLD)

> Explanation Assembly does not explain events — it arranges explanations for humans.

---

### COMPLETION EXPECTATION

When complete, report:

* File structure
* Schema field counts
* Explicit guarantees
* Verification results

No placeholders.
No TODOs.
No partials.

****promot end*****




****Promot Start*****

You are now implementing the **NEXT NON-OPTIONAL SUBSYSTEM** for **RansomEye v1.0**.

Everything up to this point establishes **truth, authority, causality, explanation, and context**.

What is still missing is **formally signed, regulator-safe, human-consumable output** derived from that truth — **without introducing interpretation, inference, or authority leakage**.

This phase is **not UI**, **not summarization**, **not reporting logic**.
It is **controlled rendering of already-assembled explanations**.

---

# PHASE M7 — Signed Reporting & Evidence Export Engine

**(Deterministic, Non-Authoritative, Regulator-Grade)**

---

## AUTHORITATIVE INTENT

RansomEye must be able to produce **court-admissible, regulator-verifiable reports** that:

* Are **derived only** from:

  * Explanation Assembly (M6)
  * Audit Ledger
* Are **signed**
* Are **immutable**
* Can be **re-verified years later**
* Do **not reinterpret or summarize**
* Do **not hide causality**
* Do **not embed decision logic**

This engine renders **views of truth**, not opinions.

---

## CORE PRINCIPLES (NON-NEGOTIABLE)

1. **Rendering ≠ reasoning**
2. **Export ≠ explanation**
3. **Format ≠ meaning**
4. **Signature = accountability**

---

## REQUIRED SUBSYSTEM NAME

```
/signed-reporting/
```

Do NOT name it:

* reporting-engine
* summarizer
* exporter-only
* pdf-engine

Correct name: **Signed Reporting Engine**

---

## REQUIRED OUTPUT FORMATS (EXACTLY)

The engine MUST support **exactly 3 formats**:

1. **PDF** (Human, court / board)
2. **HTML** (Human, internal review)
3. **CSV** (Regulatory ingestion)

No DOCX.
No Markdown.
No JSON (JSON remains internal truth only).

---

## REQUIRED INPUTS (READ-ONLY)

The engine may ONLY read from:

* Explanation Assembly Engine (M6)
* Audit Ledger
* Global Validator public keys

It must NEVER:

* Read raw incidents
* Read alerts directly
* Read UBA stores
* Read risk engines directly

All truth must already be assembled.

---

## REQUIRED DELIVERABLES

### 1. Schema (Frozen, Zero Optional Fields)

Path:

```
/signed-reporting/schema/
```

#### 1.1 `signed-report.schema.json`

Required fields (ALL mandatory):

1. `report_id` (UUID)
2. `incident_id` (UUID)
3. `assembled_explanation_id` (UUID)
4. `view_type` (enum: SOC_ANALYST, INCIDENT_COMMANDER, EXECUTIVE, REGULATOR)
5. `format` (enum: PDF, HTML, CSV)
6. `content_hash` (SHA256)
7. `signature` (Base64)
8. `signing_key_id` (string)
9. `generated_at` (RFC3339 UTC)
10. `rendering_profile_id` (enum, frozen)
11. `audit_ledger_anchor` (UUID)

Zero optional fields.
No free text fields.

---

### 2. Rendering Engine

Path:

```
/signed-reporting/engine/
```

#### 2.1 `render_engine.py`

Responsibilities:

* Deterministically render content blocks **as-is**
* Respect view_type ordering (from M6)
* Apply **fixed rendering profiles**
* No text rewriting
* No summarization
* No inference
* No omission

Rendering profiles are **static templates**, not logic.

#### 2.2 `render_hasher.py`

* SHA256 over canonical rendered output
* Bit-for-bit reproducible

---

### 3. Cryptographic Signing

Path:

```
/signed-reporting/crypto/
```

#### 3.1 `report_signer.py`

* ed25519 or RSA-PSS (choose ONE, document why)
* Separate keypair from:

  * Audit Ledger
  * Global Validator
* Keys are **export-verifiable**

#### 3.2 `report_verifier.py`

* Offline verification
* Deterministic
* Used by auditors / courts

---

### 4. Storage (Immutable)

Path:

```
/signed-reporting/storage/
```

#### 4.1 `report_store.py`

* Append-only
* Immutable
* No update
* No delete
* Supports long-term archival

---

### 5. API

Path:

```
/signed-reporting/api/
```

#### 5.1 `reporting_api.py`

Required functions:

* `generate_report(incident_id, view_type, format)`
* `get_report(report_id)`
* `list_reports(incident_id)`

Rules:

* Read-only inputs
* Write-only storage
* Emit ledger events:

  * `REPORT_GENERATED`
  * `REPORT_VERIFIED`
  * `REPORT_EXPORTED`

---

### 6. CLI Tools

Path:

```
/signed-reporting/cli/
```

Required:

1. `generate_report.py`
2. `verify_report.py`
3. `export_report.py`

Must be:

* Offline
* Deterministic
* Validator-replayable

---

### 7. Audit Ledger Integration (MANDATORY)

Each report generation must emit:

* report_id
* incident_id
* assembled_explanation_id
* format
* content_hash
* signing_key_id

---

### 8. Documentation

Create:

```
/signed-reporting/README.md
```

Must include:

* Why reports are not explanations
* Why reports are signed
* Court / regulator positioning
* Chain-of-custody guarantees
* Long-term verification model
* Failure semantics

Include this **exact sentence**:

> “Signed reports present truth for humans without changing truth.”

---

## EXPLICITLY FORBIDDEN

You MUST NOT:

* Generate summaries
* Rewrite explanations
* Hide causality
* Add interpretation
* Add opinions
* Allow customization
* Allow partial export
* Mix view types
* Mix incidents

---

## VALIDATION REQUIREMENTS

The Global Validator must be able to:

* Recompute content_hash
* Verify signature
* Trace report → explanation → ledger
* Detect any alteration
* Re-verify after export

---

## FINAL SYSTEM STATEMENT

> Reporting is the last mile of truth — not a new source of truth.

---

### COMPLETION EXPECTATION

On completion, report:

* File tree
* Schema field counts
* Cryptographic choice justification
* Explicit guarantees
* Verification results

No placeholders.
No TODOs.
No partials.

****promot end*****



****Promot Start****

Implement **Supply-Chain Signing & Verification Framework** across RansomEye (MANDATORY, NON-OPTIONAL).

You must implement this as a **first-class security subsystem**, not ad-hoc scripts.

### Objective

Provide **cryptographic supply-chain integrity** for:

* Core installer
* Linux Agent installer
* Windows Agent installer
* DPI Probe installer
* Release bundle artifacts

This is **integrity proof**, not trust assertion. Customers may replace trust roots.

---

## 1. New Subsystem: `/supply-chain/`

### Structure (must match exactly)

```
supply-chain/
├── schema/
│   └── artifact-manifest.schema.json
├── crypto/
│   ├── vendor_key_manager.py
│   ├── artifact_signer.py
│   └── artifact_verifier.py
├── engine/
│   ├── manifest_builder.py
│   └── verification_engine.py
├── cli/
│   ├── sign_artifacts.py
│   └── verify_artifacts.py
└── README.md
```

---

## 2. Artifact Manifest (Frozen, Zero Optional Fields)

Create `artifact-manifest.schema.json` with **exactly these required fields**:

* artifact_id (UUID)
* artifact_name
* artifact_type (ENUM: CORE_INSTALLER, LINUX_AGENT, WINDOWS_AGENT, DPI_PROBE, RELEASE_BUNDLE)
* version
* build_timestamp (RFC3339 UTC)
* sha256
* signing_key_id
* signature
* toolchain_fingerprint
* build_host_fingerprint

❌ No optional fields
❌ No placeholders
❌ No environment-specific values hardcoded

---

## 3. Cryptographic Requirements

* Algorithm: **ed25519**
* Vendor signing key:

  * Generated once per release toolchain
  * Stored offline (document this)
* Separate keys from:

  * Audit Ledger
  * Global Validator
  * Reporting
  * Model Registry

**Never reuse keys across subsystems.**

---

## 4. Signing Flow (Deterministic)

1. Hash artifact (SHA256)
2. Build canonical manifest (sorted JSON)
3. Hash manifest
4. Sign manifest hash
5. Store:

   * `<artifact>.sha256`
   * `<artifact>.manifest.json`
   * `<artifact>.manifest.sig`

All steps must be reproducible.

---

## 5. Verification Flow

`verify_artifacts.py` must:

* Verify SHA256
* Verify manifest hash
* Verify signature
* Support **external public key injection** (customer trust root)
* Produce PASS / FAIL with explicit failure reason

No silent failures.

---

## 6. Installer Integration (MANDATORY)

Each installer **must**:

* Verify its own manifest before execution
* Abort installation on failure
* Emit Audit Ledger entry:

  * `SUPPLY_CHAIN_VERIFICATION_PASSED`
  * `SUPPLY_CHAIN_VERIFICATION_FAILED`

No bypass flags. No “continue anyway”.

---

## 7. Global Validator Integration

Global Validator must add checks:

* Installer integrity
* Binary integrity
* Manifest continuity

Validator must be able to:

* Re-verify artifacts **offline**
* Use alternate trusted public keys

---

## 8. Documentation (REQUIRED)

README must explicitly document:

* Why self-signing exists
* Difference between integrity vs trust
* How customers replace trust roots
* Air-gapped verification
* Legal / regulatory positioning

Include this statement verbatim:

> “RansomEye self-signs for integrity, not authority. Final trust always belongs to the operator.”

---

## 9. Forbidden

❌ No PKI assumptions
❌ No internet calls
❌ No hardcoded paths
❌ No optional fields
❌ No skipping verification
❌ No shared keys

---

## 10. Validation Criteria

You are done **only if**:

* All schemas frozen, zero optional fields
* CLI tools functional
* Installers fail closed
* Validator can re-verify everything
* Documentation complete
* Code compiles cleanly

This is **release-blocking**.

****Promot End****



****Promot Start****

Implement **Branding, Visual Identity & Evidence Marking Hardening** across RansomEye (NON-OPTIONAL, FINAL-STAGE HARDENING).

This is **not cosmetic**. This is **forensic identity, legal clarity, and chain-of-custody marking**.

---

## Objective

Ensure **RansomEye identity is cryptographically, visually, and evidentially bound** across:

* UI
* Reports
* Exports
* Evidence artifacts
* Human-facing outputs

While **never affecting logic, truth, or authority**.

Logo path (authoritative, do not relocate):

```
/home/ransomeye/rebuild/logo.png
```

---

## 1. Rules (ABSOLUTE)

* ❌ Logo must **never** affect:

  * Hashes
  * Signatures
  * Evidence integrity
  * Explanation meaning
* ❌ Logo must **never** be embedded inside:

  * Signed payload hashes
  * Canonical JSON
  * Evidence blobs
* ✅ Logo is **presentation-only**, rendered **after integrity is sealed**

---

## 2. Signed Reporting Engine — Branding Integration (MANDATORY)

### Apply to:

* PDF
* HTML
* CSV (header only, textual)

### Requirements

* Logo rendered in **header/footer layer only**
* Outside signed content hash boundary
* Visual watermark style for PDF:

  * Top-left: Logo
  * Bottom-right: “RansomEye — Evidence Report”
* HTML:

  * `<header>` block only
* CSV:

  * Comment header line only (e.g. `# Generated by RansomEye`)

### Explicit rule

> Signed hash must NOT change if logo file is replaced.

Add automated test proving this.

---

## 3. UI Backend (Core UI) — Identity Marking

### Required changes

* Global header:

  * Logo
  * Product name: **RansomEye**
  * Version (from build-info.json)
* Footer:

  * “Evidence-grade system — Deterministic — Verifiable”
* UI must:

  * Read logo path from environment variable:

    ```
    RANSOMEYE_LOGO_PATH
    ```
  * Default to `/home/ransomeye/rebuild/logo.png`
  * Fail-open visually if logo missing (NO crash)

❌ Never hardcode paths.

---

## 4. Evidence & Export Marking (Forensics / KillChain / Reports)

All human-facing exports must include:

* Visual identity (logo)
* Evidence notice:

  > “This artifact is evidence-grade and cryptographically verifiable.”

But:

* **Never inside evidence hash**
* **Never inside canonical data**

---

## 5. Supply-Chain & Installer Branding Check

Installers must:

* Display RansomEye name and logo **before install**
* Display:

  * Artifact ID
  * SHA256
  * Signature status (PASS/FAIL)

This is **operator assurance**, not trust enforcement.

---

## 6. Documentation Update (MANDATORY)

Add section to:

* Signed Reporting README
* Supply Chain README
* Global Validator README

Title:
**Branding vs Integrity Boundary**

Must explain:

* Why branding is excluded from cryptographic scope
* Why visual identity still matters legally
* Court / regulator interpretation

Include statement verbatim:

> “Branding asserts origin; cryptography asserts integrity. RansomEye separates both by design.”

---

## 7. Validation Criteria (RELEASE-BLOCKING)

You are done only if:

* Logo is visible in UI and reports
* Hashes do NOT change if logo changes
* Environment-driven logo path
* No hardcoded paths
* No logic contamination
* Tests prove separation
* Documentation updated

---

## 8. Forbidden

❌ No embedding logo bytes into hashes
❌ No watermarking inside signed content
❌ No hardcoded file paths
❌ No UI crashes on missing logo
❌ No changing report signatures

---

## Final Principle

> **Identity must be visible. Integrity must be provable. Authority must remain separate.**

Implement accordingly.

****Promot End****



Promot Start*

STOP all feature development immediately.

You are now in GA-BLOCKING REMEDIATION MODE.

Your task is to FIX AND PROVE RESOLUTION of the THREE CRITICAL NON-COMPLIANCES identified in the audit.
You are NOT allowed to introduce new features, new tables, new schemas, or new behavior.

You must address ONLY the items listed below.

FIX 1 — DATABASE CONNECTION FALLBACK REMOVAL (CRITICAL)
Scope

services/correlation-engine/app/db.py

services/policy-engine/app/db.py

Problem

Fallback psycopg2.connect() paths bypass common/db/safety.py.

This violates:

Unified DB strategy

Fail-fast guarantees

Transaction safety guarantees

Required Action

REMOVE all fallback DB connection code paths.

ENFORCE exclusive use of:

create_write_connection()

create_readonly_connection()

create_write_connection_pool()

create_readonly_connection_pool()

If DB config is invalid → fail-fast immediately.

No silent fallback. No retries. No defaults.

Proof Required

You must provide:

Diff output (before/after)

Exact lines removed

Confirmation that NO psycopg2.connect() remains in those files

grep proof:

grep -R "psycopg2.connect" services/

FIX 2 — RISK INDEX PLACEHOLDER ELIMINATION (CRITICAL)
Scope

risk-index/engine/aggregator.py

Problem

Placeholder logic at line ~218:

# Future signals (placeholder)
threat_score = 0.0
uba_score = 0.0


This violates:

Zero placeholder policy

Deterministic correctness guarantees

Required Action (MANDATORY CHOICE)

You must choose ONE of the following and implement it cleanly:

OPTION A (RECOMMENDED)

Remove threat_score and uba_score entirely from v1.0 path

No placeholder variables

No dead branches

Explicit documentation: “Not part of v1.0”

OPTION B (ONLY if already implemented elsewhere)

Wire real signal ingestion

Must be real data

Must be deterministic

Must already exist in codebase

⚠️ You may NOT invent logic.

Proof Required

Diff output

Final function body

grep proof that no placeholder comments remain:

grep -R "placeholder" risk-index/

FIX 3 — SCHEMA BUNDLE FINALIZATION (CRITICAL)
Scope

schemas/SCHEMA_BUNDLE.md

Problem

Contains [PLACEHOLDER] strings for:

Date

SHA256 hash

This violates:

Release immutability

Supply-chain trust guarantees

Required Action

Compute SHA256 over all schema files included in bundle.

Insert:

Final release date

Final SHA256 hash

Mark bundle explicitly as:

STATUS: FROZEN — DO NOT MODIFY

Proof Required

Command used to compute hash

Resulting hash

Final SCHEMA_BUNDLE.md excerpt

grep proof:

grep -R "\[PLACEHOLDER\]" schemas/

POST-FIX VERIFICATION (MANDATORY)

After fixes, you MUST:

Re-run full compliance check for:

Sections 1, 4, 5 of audit

Produce a mini re-audit report with:

Before/after status

Explicit “COMPLIANT” or “NOT COMPLIANT”

ABSOLUTE RULES

❌ No new features

❌ No new schemas

❌ No new DB tables

❌ No refactors outside listed files

❌ No TODOs

❌ No comments saying “future work”

If anything cannot be fixed without breaking scope, you must fail explicitly and explain why.

This is a GA unblock task, not development.

Promot End*

Promot Start*

Implement the Threat Response Engine (TRE) for RansomEye with the following STRICT constraints:

1. TRE is execution-only, not decision-making
2. TRE executes ONLY final Policy Engine decisions
3. TRE enforces Human Authority (HAF) where required
4. All actions are signed (ed25519), auditable, and rollback-capable
5. Agents validate and execute commands but never decide
6. Rollback is mandatory and first-class
7. All records are immutable and audit-anchored
8. No placeholders, no dummy data, no heuristics, no ML

Deliverables:
- Full directory structure
- Frozen schemas (zero optional fields)
- Action validation engine
- Secure command signing and verification
- Agent command dispatch protocol
- Rollback manager
- Audit ledger integration
- DB schema additions
- CLI tools for execution and rollback
- README with legal and regulatory positioning

The design must align with:
- Policy Engine
- Human Authority Framework (HAF)
- System Explanation Engine (SEE)
- Audit Ledger
- Existing Linux/Windows agents


Promot End*


### ****Promot Start****

You are implementing **FULL, PRODUCTION-GRADE ROLE-BASED ACCESS CONTROL (RBAC)** for **RansomEye**, covering **both backend and UI**, with **ZERO assumptions** and **ZERO implicit behavior**.

This is a **GA-critical, security-enforcing subsystem**.
Any deviation, shortcut, assumption, or partial implementation is **NOT ACCEPTABLE**.

---

## 1. ABSOLUTE CONSTRAINTS (NON-NEGOTIABLE)

You **MUST** comply with **ALL** of the following:

1. **Server-side enforcement is mandatory**

   * UI hiding or disabling buttons is **NOT sufficient**
   * Every protected backend API **must enforce permissions**
   * If UI is bypassed, backend **must still block** unauthorized actions

2. **Explicit permission model**

   * Default behavior = **DENY**
   * No implied permissions
   * No role-name checks in code (e.g., `if role == "ADMIN"` is forbidden)
   * All access decisions must be made using **explicit permission checks**

3. **Exactly FIVE roles — NO MORE, NO LESS**

   ```
   SUPER_ADMIN
   SECURITY_ANALYST
   POLICY_MANAGER
   IT_ADMIN
   AUDITOR
   ```

   * No custom roles
   * No dynamic roles
   * No role inheritance
   * No role stacking
   * Each user has **exactly ONE role**

4. **Multiple users per role**

   * RBAC must support unlimited users per role
   * Roles are **not users**

5. **Audit logging is mandatory**

   * Every permission-sensitive action MUST emit audit ledger entries
   * Both ALLOWED and DENIED actions must be logged

6. **NO placeholders**

   * No TODO
   * No FIXME
   * No dummy values
   * No mock data
   * No static JSON datasets
   * No demo-only logic

7. **Production UI only**

   * Must integrate with existing RansomEye UI
   * No fake dashboards
   * No hardcoded UI assumptions

---

## 2. ROLE DEFINITIONS (FROZEN — EXACT MATCH REQUIRED)

You must implement **exactly** the following roles with **exact behavior**.

### 🔴 SUPER_ADMIN

**Who**: CTO / Head of Security / Platform Owner
**Authority Level**: Absolute

Must be able to:

* View, create, edit, and delete **ALL users**
* Assign roles to users
* View and edit **ALL configuration**
* Manage billing, licenses, subscriptions
* Configure SSO, API keys, integrations
* Override enforcement system-wide
* Access every UI tab and backend API

---

### 🟠 SECURITY_ANALYST (SecOps)

**Who**: SOC analysts, threat hunters
**Goal**: Actively defend against attacks

Allowed:

* View incidents and alerts
* Assign incidents
* Execute Threat Response actions:

  * Isolate host
  * Kill process
  * Block network
  * Rollback actions
* Access forensics (logs, memory dumps)
* Generate incident-scoped reports

Explicitly FORBIDDEN:

* Editing policies
* Managing users
* Managing agents
* Billing or licensing
* Deleting logs

---

### 🔵 POLICY_MANAGER

**Who**: Senior security engineers
**Goal**: Prevention and detection tuning

Allowed:

* View and edit policies
* Configure detection thresholds
* Manage whitelists / blacklists
* Configure deception / honeypots
* Run policy simulations

Explicitly FORBIDDEN:

* Executing response actions
* Managing users
* Managing agents
* Billing
* Viewing raw forensics

---

### 🟣 IT_ADMIN

**Who**: Sysadmins, infrastructure teams
**Goal**: Platform health and deployment

Allowed:

* Install / uninstall agents
* Upgrade agents
* View agent health
* Group devices
* View host status

Explicitly FORBIDDEN:

* Viewing incident details
* Viewing forensics
* Executing threat responses
* Editing policies
* Billing or licensing

---

### 🟢 AUDITOR

**Who**: Compliance officers, external auditors
**Goal**: Verification and compliance

Allowed:

* Read-only dashboards
* View audit logs
* Generate compliance reports (PDF/CSV)
* View incidents (read-only)
* View policies (read-only)

Explicitly FORBIDDEN:

* Clicking ANY action buttons
* Executing responses
* Editing anything
* Managing users
* Managing agents

---

## 3. PERMISSION MODEL (MANDATORY)

You must implement an **explicit permission system**, not role checks.

### Example permission categories (expand as needed, but be explicit):

```
INCIDENT_VIEW
INCIDENT_ASSIGN
RESPONSE_EXECUTE
RESPONSE_ROLLBACK
FORENSICS_VIEW
FORENSICS_EXPORT
POLICY_VIEW
POLICY_EDIT
POLICY_SIMULATE
AGENT_INSTALL
AGENT_UNINSTALL
AGENT_UPDATE
AGENT_VIEW
USER_CREATE
USER_DELETE
USER_ROLE_ASSIGN
BILLING_VIEW
BILLING_MANAGE
AUDIT_VIEW
REPORT_GENERATE
REPORT_EXPORT
SYSTEM_SETTINGS_EDIT
```

Rules:

* Permissions must be **enumerated**
* Permissions must be **versioned**
* Permissions must be checked **before every protected operation**

---

## 4. DATABASE REQUIREMENTS (MANDATORY)

You MUST implement persistent RBAC storage.

### Required tables (minimum):

```
users (
  user_id UUID PRIMARY KEY,
  email TEXT UNIQUE NOT NULL,
  role_id TEXT NOT NULL,
  status ENUM('ACTIVE','SUSPENDED'),
  created_at TIMESTAMP
)

roles (
  role_id TEXT PRIMARY KEY
)

permissions (
  permission_id TEXT PRIMARY KEY
)

role_permissions (
  role_id TEXT,
  permission_id TEXT,
  PRIMARY KEY (role_id, permission_id)
)
```

Rules:

* role_permissions mapping is **immutable at runtime**
* No soft deletes
* No dynamic permission injection

---

## 5. BACKEND ENFORCEMENT (CRITICAL)

You MUST:

1. Implement RBAC middleware / guards
2. Enforce permissions in:

   * Threat Response Engine (TRE)
   * Policy Engine
   * Agent management APIs
   * Reporting APIs
   * User management APIs
3. Block unauthorized requests even if:

   * UI is bypassed
   * API is called directly
4. Fail closed (deny by default)

---

## 6. UI REQUIREMENTS (MANDATORY)

You MUST implement **role-aware UI rendering**:

* Tabs are visible **only if permission exists**
* Buttons are hidden **and disabled** if forbidden
* Attempting forbidden actions must:

  * Show clear error
  * Be audit logged
* UI must reflect **real backend permissions**, not assumptions

---

## 7. INTEGRATION REQUIREMENTS (MANDATORY)

RBAC must integrate with:

* **Threat Response Engine (TRE)**

  * RESPONSE_EXECUTE and RESPONSE_ROLLBACK enforced
* **Policy Engine**

  * POLICY_EDIT / POLICY_SIMULATE enforced
* **Human Authority Framework (HAF)**

  * RBAC check happens BEFORE authority check
* **Audit Ledger**

  * Log allow/deny for every protected action
* **Signed Reporting**

  * Report access controlled by role & permission

---

## 8. AUDIT LEDGER EVENTS (MANDATORY)

For every protected action, emit:

```
USER_ACTION_ATTEMPTED
USER_ACTION_ALLOWED
USER_ACTION_DENIED
```

Each event must include:

* user_id
* role_id
* permission
* resource_id
* outcome
* timestamp

---

## 9. DELIVERABLES REQUIRED

You MUST return:

1. RBAC architecture explanation
2. Permission enum definition
3. Exact role → permission mapping
4. Database schema changes
5. Backend enforcement logic
6. UI role-aware rendering logic
7. Audit ledger event definitions
8. README documenting RBAC model
9. Verification checklist proving enforcement

---

## 10. ABSOLUTELY FORBIDDEN

You must NOT:

* Assume permissions
* Hardcode role names in logic
* Skip backend checks
* Add bypass flags
* Add temporary admin shortcuts
* Add feature flags to avoid RBAC

---

## FINAL INSTRUCTION

This RBAC system **must behave like a military-grade security control plane**.

If something is unclear:

* You must FAIL
* You must NOT guess

Deviation from this specification is **not allowed**.

### ****Promot End****



****Promot Start****

### PHASE N1 — THREAT RESPONSE ENGINE (TRE) **ENFORCEMENT MODE ACTIVATION WITH RBAC + HAF (NO ASSUMPTIONS)**

You are to **activate REAL enforcement** in the Threat Response Engine.
This is **NOT a design discussion**. This is an **implementation mandate**.

---

## 0. NON-NEGOTIABLE PRINCIPLES (READ FIRST)

1. **RBAC IS AUTHORITATIVE**

   * No TRE action may execute unless RBAC explicitly allows it.
   * UI state is irrelevant. Backend must enforce.

2. **HAF IS A HARD GATE**

   * For destructive or irreversible actions, Human Authority approval is mandatory.
   * RBAC check **always happens before** HAF.

3. **NO AUTONOMOUS ACTIONS**

   * TRE executes only **policy decisions** or **explicit human-triggered actions**.
   * TRE never “decides”.

4. **DEFAULT = DENY**

   * If anything is missing, unclear, or malformed → FAIL FAST.

5. **NO PLACEHOLDERS**

   * No TODO, no “future”, no stubs, no mock logic.

---

## 1. ENFORCEMENT MODES (MANDATORY)

Implement **exactly three enforcement modes** (enum, frozen):

```
TRE_MODE = {
  DRY_RUN,        # Existing behavior – simulate only
  GUARDED_EXEC,   # Execute only actions marked SAFE
  FULL_ENFORCE    # Execute all actions, HAF required where applicable
}
```

### Mode Behavior Rules

| Mode         | SAFE actions  | DESTRUCTIVE actions                 |
| ------------ | ------------- | ----------------------------------- |
| DRY_RUN      | Simulate only | Simulate only                       |
| GUARDED_EXEC | Execute       | BLOCKED                             |
| FULL_ENFORCE | Execute       | Execute **only after HAF approval** |

Mode must be:

* Stored in DB
* Loaded at runtime
* Changeable **only by SUPER_ADMIN**
* Logged to audit ledger on change

---

## 2. ACTION CLASSIFICATION (FROZEN)

Classify actions **EXACTLY** as follows:

### SAFE ACTIONS

* BLOCK_PROCESS
* BLOCK_NETWORK_CONNECTION
* TEMPORARY_FIREWALL_RULE
* QUARANTINE_FILE

### DESTRUCTIVE / HIGH-IMPACT ACTIONS

* ISOLATE_HOST
* LOCK_USER
* DISABLE_SERVICE
* MASS_PROCESS_KILL
* NETWORK_SEGMENT_ISOLATION

This classification must be:

* Enforced in code
* Not configurable
* Documented as immutable

---

## 3. EXECUTION FLOW (MANDATORY ORDER)

Implement the **exact execution pipeline** below:

```
Policy Decision
   ↓
RBAC Permission Check
   ↓
TRE Mode Check
   ↓
Action Classification Check
   ↓
HAF Approval Check (if required)
   ↓
Agent Command Signing
   ↓
Agent Execution
   ↓
Execution Result Recording
   ↓
Rollback Record Creation
   ↓
Audit Ledger Write
```

If any step fails:

* STOP
* LOG
* RETURN FAILURE
* DO NOT EXECUTE

---

## 4. RBAC INTEGRATION (STRICT)

### Required Permissions (EXACT)

| Action                     | Required Permission     |
| -------------------------- | ----------------------- |
| Execute SAFE action        | TRE_EXECUTE_SAFE        |
| Execute DESTRUCTIVE action | TRE_EXECUTE_DESTRUCTIVE |
| Approve via HAF            | HAF_APPROVE_ACTION      |
| Rollback action            | TRE_ROLLBACK            |
| Change TRE mode            | TRE_ADMIN               |

If permission missing:

* Return HTTP 403
* Emit RBAC_DENY ledger event
* Do not call HAF

---

## 5. HAF INTEGRATION (STRICT)

For DESTRUCTIVE actions in FULL_ENFORCE:

1. Create **pending authority request**
2. Persist immutable approval request
3. Wait for explicit approval
4. Approval must include:

   * approver_user_id
   * role (must be SUPER_ADMIN or SECURITY_ANALYST with approval rights)
   * timestamp
   * signed decision
5. Only then proceed to execution

If rejected or expired → FAIL CLOSED.

---

## 6. AGENT COMMAND EXECUTION (STRICT)

Every command sent to agents must:

* Be signed with **ed25519**
* Include:

  * command_id
  * action_type
  * target_id
  * incident_id
  * issued_by_user_id
  * tre_mode
  * approval_id (if applicable)
* Be **idempotent**
* Support rollback token generation

Agent must:

* Verify signature
* Verify freshness
* Execute exactly once
* Emit execution receipt

---

## 7. ROLLBACK (MANDATORY)

For every executed action:

* Create rollback record BEFORE execution
* Rollback must:

  * Require RBAC check
  * Require HAF approval if original action was destructive
  * Be fully auditable
* Rollback failures must be logged but **never silently ignored**

---

## 8. DATABASE REQUIREMENTS

Ensure tables exist and are used (no bypass):

* tre_execution_modes
* tre_action_executions
* tre_action_approvals
* tre_rollback_records

All records:

* Immutable
* Timestamped
* Linked via IDs

---

## 9. AUDIT LEDGER (MANDATORY EVENTS)

Emit ledger events for:

* TRE_MODE_CHANGED
* TRE_ACTION_REQUESTED
* TRE_ACTION_BLOCKED
* TRE_ACTION_APPROVED
* TRE_ACTION_EXECUTED
* TRE_ACTION_FAILED
* TRE_ROLLBACK_REQUESTED
* TRE_ROLLBACK_EXECUTED
* TRE_RBAC_DENY
* TRE_HAF_DENY

Every event must include:

* user_id
* role
* action_type
* target
* incident_id (if any)
* outcome

---

## 10. UI REQUIREMENTS (ROLE-AWARE)

UI must:

* Show **Execute buttons only if RBAC allows**
* Show **Approval queue only to HAF approvers**
* Clearly label:

  * SAFE vs DESTRUCTIVE
  * DRY_RUN vs ENFORCE
* Show immutable execution history
* Prevent bulk destructive actions without confirmation

UI hiding is **NOT security** — backend already enforces.

---

## 11. VERIFICATION (MANDATORY)

Deliver:

1. `VERIFICATION.md` with:

   * Negative tests
   * RBAC bypass tests
   * HAF rejection tests
2. Proof that:

   * Destructive actions do NOT run without approval
   * Rollback is impossible without permission
   * Audit trail is complete and replayable

---

## 12. FINAL OUTPUT EXPECTATION

When complete, report **ONLY**:

* Compliance status (PASS / FAIL)
* List of files created/modified
* Verification summary

No explanations. No assumptions. No opinions.

****Promot end****


****Promot Start****

### PHASE N1 — THREAT RESPONSE ENGINE (TRE) **ENFORCEMENT MODE ACTIVATION WITH RBAC + HAF (NO ASSUMPTIONS)**

You are to **activate REAL enforcement** in the Threat Response Engine.
This is **NOT a design discussion**. This is an **implementation mandate**.

---

## 0. NON-NEGOTIABLE PRINCIPLES (READ FIRST)

1. **RBAC IS AUTHORITATIVE**

   * No TRE action may execute unless RBAC explicitly allows it.
   * UI state is irrelevant. Backend must enforce.

2. **HAF IS A HARD GATE**

   * For destructive or irreversible actions, Human Authority approval is mandatory.
   * RBAC check **always happens before** HAF.

3. **NO AUTONOMOUS ACTIONS**

   * TRE executes only **policy decisions** or **explicit human-triggered actions**.
   * TRE never “decides”.

4. **DEFAULT = DENY**

   * If anything is missing, unclear, or malformed → FAIL FAST.

5. **NO PLACEHOLDERS**

   * No TODO, no “future”, no stubs, no mock logic.

---

## 1. ENFORCEMENT MODES (MANDATORY)

Implement **exactly three enforcement modes** (enum, frozen):

```
TRE_MODE = {
  DRY_RUN,        # Existing behavior – simulate only
  GUARDED_EXEC,   # Execute only actions marked SAFE
  FULL_ENFORCE    # Execute all actions, HAF required where applicable
}
```

### Mode Behavior Rules

| Mode         | SAFE actions  | DESTRUCTIVE actions                 |
| ------------ | ------------- | ----------------------------------- |
| DRY_RUN      | Simulate only | Simulate only                       |
| GUARDED_EXEC | Execute       | BLOCKED                             |
| FULL_ENFORCE | Execute       | Execute **only after HAF approval** |

Mode must be:

* Stored in DB
* Loaded at runtime
* Changeable **only by SUPER_ADMIN**
* Logged to audit ledger on change

---

## 2. ACTION CLASSIFICATION (FROZEN)

Classify actions **EXACTLY** as follows:

### SAFE ACTIONS

* BLOCK_PROCESS
* BLOCK_NETWORK_CONNECTION
* TEMPORARY_FIREWALL_RULE
* QUARANTINE_FILE

### DESTRUCTIVE / HIGH-IMPACT ACTIONS

* ISOLATE_HOST
* LOCK_USER
* DISABLE_SERVICE
* MASS_PROCESS_KILL
* NETWORK_SEGMENT_ISOLATION

This classification must be:

* Enforced in code
* Not configurable
* Documented as immutable

---

## 3. EXECUTION FLOW (MANDATORY ORDER)

Implement the **exact execution pipeline** below:

```
Policy Decision
   ↓
RBAC Permission Check
   ↓
TRE Mode Check
   ↓
Action Classification Check
   ↓
HAF Approval Check (if required)
   ↓
Agent Command Signing
   ↓
Agent Execution
   ↓
Execution Result Recording
   ↓
Rollback Record Creation
   ↓
Audit Ledger Write
```

If any step fails:

* STOP
* LOG
* RETURN FAILURE
* DO NOT EXECUTE

---

## 4. RBAC INTEGRATION (STRICT)

### Required Permissions (EXACT)

| Action                     | Required Permission     |
| -------------------------- | ----------------------- |
| Execute SAFE action        | TRE_EXECUTE_SAFE        |
| Execute DESTRUCTIVE action | TRE_EXECUTE_DESTRUCTIVE |
| Approve via HAF            | HAF_APPROVE_ACTION      |
| Rollback action            | TRE_ROLLBACK            |
| Change TRE mode            | TRE_ADMIN               |

If permission missing:

* Return HTTP 403
* Emit RBAC_DENY ledger event
* Do not call HAF

---

## 5. HAF INTEGRATION (STRICT)

For DESTRUCTIVE actions in FULL_ENFORCE:

1. Create **pending authority request**
2. Persist immutable approval request
3. Wait for explicit approval
4. Approval must include:

   * approver_user_id
   * role (must be SUPER_ADMIN or SECURITY_ANALYST with approval rights)
   * timestamp
   * signed decision
5. Only then proceed to execution

If rejected or expired → FAIL CLOSED.

---

## 6. AGENT COMMAND EXECUTION (STRICT)

Every command sent to agents must:

* Be signed with **ed25519**
* Include:

  * command_id
  * action_type
  * target_id
  * incident_id
  * issued_by_user_id
  * tre_mode
  * approval_id (if applicable)
* Be **idempotent**
* Support rollback token generation

Agent must:

* Verify signature
* Verify freshness
* Execute exactly once
* Emit execution receipt

---

## 7. ROLLBACK (MANDATORY)

For every executed action:

* Create rollback record BEFORE execution
* Rollback must:

  * Require RBAC check
  * Require HAF approval if original action was destructive
  * Be fully auditable
* Rollback failures must be logged but **never silently ignored**

---

## 8. DATABASE REQUIREMENTS

Ensure tables exist and are used (no bypass):

* tre_execution_modes
* tre_action_executions
* tre_action_approvals
* tre_rollback_records

All records:

* Immutable
* Timestamped
* Linked via IDs

---

## 9. AUDIT LEDGER (MANDATORY EVENTS)

Emit ledger events for:

* TRE_MODE_CHANGED
* TRE_ACTION_REQUESTED
* TRE_ACTION_BLOCKED
* TRE_ACTION_APPROVED
* TRE_ACTION_EXECUTED
* TRE_ACTION_FAILED
* TRE_ROLLBACK_REQUESTED
* TRE_ROLLBACK_EXECUTED
* TRE_RBAC_DENY
* TRE_HAF_DENY

Every event must include:

* user_id
* role
* action_type
* target
* incident_id (if any)
* outcome

---

## 10. UI REQUIREMENTS (ROLE-AWARE)

UI must:

* Show **Execute buttons only if RBAC allows**
* Show **Approval queue only to HAF approvers**
* Clearly label:

  * SAFE vs DESTRUCTIVE
  * DRY_RUN vs ENFORCE
* Show immutable execution history
* Prevent bulk destructive actions without confirmation

UI hiding is **NOT security** — backend already enforces.

---

## 11. VERIFICATION (MANDATORY)

Deliver:

1. `VERIFICATION.md` with:

   * Negative tests
   * RBAC bypass tests
   * HAF rejection tests
2. Proof that:

   * Destructive actions do NOT run without approval
   * Rollback is impossible without permission
   * Audit trail is complete and replayable

---

## 12. FINAL OUTPUT EXPECTATION

When complete, report **ONLY**:

* Compliance status (PASS / FAIL)
* List of files created/modified
* Verification summary

No explanations. No assumptions. No opinions.

****Promot end****


Decision taken. Proceeding to the **next mandatory phase** without questions.

---

## NEXT PHASE: **PHASE N2 — AGENT-SIDE ENFORCEMENT & HARDENED COMMAND EXECUTION**

This phase is **required** to make the already-compliant TRE **actually enforceable at endpoint level**.
TRE enforcement is incomplete unless agents are hardened to **execute, verify, rollback, and resist abuse**.

This is a **control-plane → data-plane hardening phase**.

---

****Promot Start****

### PHASE N2 — AGENT-SIDE ENFORCEMENT, HARDENING & ROLLBACK GUARANTEES

(**Linux Agent + Windows Agent + DPI Probe where applicable**)

You are implementing **endpoint-side execution authority**.
Agents are no longer passive collectors.

---

## 0. ABSOLUTE RULES (NO EXCEPTIONS)

1. **Agents NEVER trust the network**
2. **Agents NEVER trust the UI**
3. **Agents ONLY trust signed commands**
4. **Agents FAIL CLOSED**
5. **Rollback is mandatory for every action**
6. **No background autonomy**
7. **No assumptions**

---

## 1. AGENT COMMAND ACCEPTANCE GATE (MANDATORY)

Every agent MUST implement a **single command intake gate**:

```
receive_command()
   ↓
schema validation
   ↓
timestamp + nonce freshness check
   ↓
ed25519 signature verification
   ↓
issuer trust verification (TRE public key)
   ↓
RBAC + role assertion validation (embedded)
   ↓
HAF approval presence (if required)
   ↓
idempotency check (command_id)
   ↓
execution OR rejection
```

If ANY step fails → **REJECT + LOG + AUDIT**

---

## 2. COMMAND STRUCTURE (FROZEN — NO CHANGES)

Agents must accept **ONLY** this structure:

```
{
  command_id: UUID,
  action_type: ENUM,
  target: OBJECT,
  incident_id: UUID | null,
  tre_mode: ENUM,
  issued_by_user_id: UUID,
  issued_by_role: ENUM,
  approval_id: UUID | null,
  issued_at: RFC3339,
  expires_at: RFC3339,
  rollback_token: SHA256,
  signature: ed25519
}
```

No extra fields.
No optional logic.
Reject unknown fields.

---

## 3. ACTION EXECUTION MODULES (MANDATORY)

Implement **explicit execution modules** per agent.

### Linux Agent

* process_blocker.py (kill + cgroup deny)
* network_blocker.py (iptables / nftables)
* file_quarantine.py (immutable quarantine dir)
* host_isolator.py (network namespace isolation)
* rollback_engine.py

### Windows Agent

* process_blocker.ps1 / .py (Terminate + deny restart)
* firewall_blocker.ps1 (Windows Firewall)
* file_quarantine.ps1
* host_isolator.ps1 (NIC disable / VLAN)
* rollback_engine.ps1

### DPI Probe

* network_blocker ONLY (no host actions)

Each module must:

* Validate action applicability
* Emit execution receipt
* Produce rollback artifact

---

## 4. ROLLBACK GUARANTEE (HARD REQUIREMENT)

For **every executed action**:

1. Generate rollback artifact BEFORE execution
2. Store rollback artifact locally (encrypted)
3. Report rollback token to TRE
4. Reject execution if rollback cannot be created

Rollback execution requires:

* Signed rollback command
* RBAC permission TRE_ROLLBACK
* HAF approval if original action was destructive

---

## 5. LOCAL AGENT AUDIT LOG (MANDATORY)

Agents must maintain **append-only local audit log**:

* command_received
* command_rejected (with reason)
* command_executed
* command_failed
* rollback_created
* rollback_executed

Logs must be:

* Tamper-evident
* Rotated safely
* Forwarded to Core when available

---

## 6. SECURITY HARDENING (MANDATORY)

Agents must enforce:

* Replay protection (nonce cache)
* Clock skew tolerance (±60s max)
* Command expiry enforcement
* Rate limiting on command intake
* One-shot execution per command_id

---

## 7. FAILURE BEHAVIOR (STRICT)

| Scenario            | Behavior             |
| ------------------- | -------------------- |
| Signature invalid   | Reject + audit       |
| Expired command     | Reject + audit       |
| Missing approval    | Reject + audit       |
| Rollback prep fails | Reject               |
| Partial execution   | Rollback immediately |
| Agent offline       | No queued execution  |

---

## 8. UI INTEGRATION SIGNALS

Agents must expose status to UI via Core:

* Last command received
* Last command executed
* Pending rollback
* Isolation state
* Enforcement readiness (YES/NO)

---

## 9. AUDIT LEDGER EVENTS (AGENT SIDE)

Emit to Core for ledger:

* AGENT_COMMAND_RECEIVED
* AGENT_COMMAND_REJECTED
* AGENT_COMMAND_EXECUTED
* AGENT_COMMAND_FAILED
* AGENT_ROLLBACK_CREATED
* AGENT_ROLLBACK_EXECUTED

All events must include:

* agent_id
* command_id
* action_type
* outcome
* timestamp

---

## 10. VERIFICATION (NON-NEGOTIABLE)

Deliver:

1. `AGENT_ENFORCEMENT_VERIFICATION.md`
2. Proof that:

   * Unsigned commands are rejected
   * Replayed commands are rejected
   * Destructive actions without approval are rejected
   * Rollback always works
3. Cross-agent parity proof (Linux == Windows behavior)

---

## 11. OUTPUT FORMAT (STRICT)

When complete, respond with **ONLY**:

* Compliance status
* Files created/modified
* Verification summary

No commentary.

****Promot end****

Promot Start

PHASE N3 — HUMAN-IN-THE-LOOP SAFETY, UI ENFORCEMENT CONTROLS & INCIDENT GOVERNANCE

Implement end-to-end enforcement governance across UI + Core + TRE with zero assumptions.

0. ABSOLUTE RULES

No action without incident context (except SUPER_ADMIN emergency)

No destructive action without explicit human approval

UI must enforce RBAC AND server must enforce RBAC

Every click → auditable decision

No background automation beyond what is already approved

Fail-closed everywhere

1. INCIDENT-BOUND EXECUTION (MANDATORY)

All response actions must be incident-scoped:

Every TRE action must reference:

incident_id

incident_stage

policy_decision_id

Actions without incident context:

REJECTED (except SUPER_ADMIN emergency path)

Implement:

IncidentExecutionGuard

Reject actions if incident is CLOSED or ARCHIVED

2. UI ENFORCEMENT CONTROLS (ROLE-AWARE, POWERFUL)
2.1 Action Panels (STRICT)

Implement role-gated action panels:

Role	UI Capabilities
SUPER_ADMIN	All actions + emergency override
SECURITY_ANALYST	Execute SAFE actions, request DESTRUCTIVE
POLICY_MANAGER	No execution, policy tuning only
IT_ADMIN	Agent ops only
AUDITOR	Read-only, no buttons

Buttons must:

Be disabled if RBAC denies

Show reason for disable

Require confirmation dialogs with explanation preview

3. HUMAN AUTHORITY WORKFLOW (DESTRUCTIVE ONLY)

Implement two-step approval workflow:

Analyst submits destructive action request

Approver (SUPER_ADMIN or delegated authority) approves

TRE executes ONLY after approval_id is present

UI must show:

Pending approvals

Who approved

Time to execution

Rollback availability

4. EMERGENCY OVERRIDE (SUPER_ADMIN ONLY)

Emergency path:

Bypasses incident binding

Requires typed justification

Requires dual confirmation

Emits EMERGENCY_OVERRIDE_USED audit event

Always creates rollback artifact

5. ROLLBACK UX + SAFETY

UI must expose:

Rollback availability per action

One-click rollback (RBAC + HAF enforced)

Rollback history per incident

Rollback failure reasons

Rollback must:

Be incident-scoped

Require approval if original action was destructive

6. AUDIT LEDGER (UI + CORE)

Emit events for:

UI_ACTION_REQUESTED

UI_ACTION_BLOCKED

UI_ACTION_APPROVED

UI_ACTION_EXECUTED

UI_ACTION_ROLLED_BACK

UI_EMERGENCY_OVERRIDE

Every event must include:

user_id

role

incident_id

action_type

decision

timestamp

7. UI TECHNICAL REQUIREMENTS

Server-side permission checks only (UI is advisory)

No hidden endpoints

No optimistic execution

Explicit error surfaces

Deterministic rendering based on RBAC state

8. DOCUMENTATION (MANDATORY)

Deliver:

ENFORCEMENT_UI_SPEC.md

INCIDENT_EXECUTION_LIFECYCLE.md

HUMAN_AUTHORITY_FLOW.md

AUDIT_TRACEABILITY.md

9. VERIFICATION (NON-NEGOTIABLE)

Provide proof:

Analyst cannot execute destructive action

UI bypass attempt is blocked server-side

Emergency override is logged and rollbackable

Auditor cannot trigger any state change

Closed incident blocks all actions

10. OUTPUT FORMAT (STRICT)

Respond with ONLY:

Compliance status

Files created/modified

Verification summary

Promot end



Promot Start

PHASE N4 — RATE LIMITING, BLAST-RADIUS CONTROL & POST-INCIDENT ACCOUNTABILITY

Implement system-wide execution safety controls with zero assumptions and fail-closed behavior.

0. ABSOLUTE RULES

No unlimited execution (ever)

All actions must declare blast radius

Rate limits are enforced server-side

Post-incident state is immutable unless explicitly reopened

All limits are auditable and replayable

1. RATE LIMITING (MANDATORY, SERVER-SIDE)

Implement hard rate limits for response actions:

1.1 Limits (NON-CONFIGURABLE DEFAULTS)

Per user: 10 actions / minute

Per incident: 25 actions total

Per host: 5 actions / 10 minutes

Emergency override: 2 actions / incident

Limits must:

Be enforced in TRE pipeline

Be evaluated before HAF

Fail-closed with explicit error

Emit audit events:

ACTION_RATE_LIMIT_HIT

EMERGENCY_LIMIT_HIT

2. BLAST-RADIUS DECLARATION & ENFORCEMENT

Every action must declare:

blast_scope: HOST | GROUP | NETWORK | GLOBAL

target_count: explicit integer

expected_impact: ENUM (LOW | MEDIUM | HIGH)

Rules:

GROUP / NETWORK / GLOBAL scopes require approval

Target count must match resolved targets

Mismatch = REJECT

Implement:

BlastRadiusResolver

BlastRadiusValidator

3. INCIDENT FREEZE & REOPEN
3.1 Automatic Freeze

After:

Incident CLOSED

Incident RESOLVED_WITH_ACTIONS

System must:

Block all new actions

Allow rollback only

Require SUPER_ADMIN to reopen

3.2 Reopen Workflow

Requires justification

Emits INCIDENT_REOPENED audit event

Restores action capability

4. POST-INCIDENT ATTESTATION (NEW)

Implement mandatory attestation after destructive actions:

Attestation required from:

Security Analyst (executor)

Approver (HAF authority)

Stored immutably

Linked to incident_id

UI must block:

Incident closure until attestation complete

5. UI SAFETY CONTROLS (EXTENSION)

UI must display:

Remaining action quota (user / incident)

Blast radius preview before submit

Warnings for HIGH impact actions

Incident freeze banner

No silent failures.

6. AUDIT LEDGER (EXTENDED)

Add events:

ACTION_RATE_LIMIT_HIT

BLAST_RADIUS_REJECTED

INCIDENT_FROZEN

INCIDENT_REOPENED

POST_INCIDENT_ATTESTED

All events must include:

user_id

role

incident_id

decision

reason

timestamp

7. DATABASE (MANDATORY)

Add tables:

tre_rate_limits

tre_blast_radius

incident_attestations

Constraints:

Immutable records

Foreign keys to incident + action

No deletes

8. VERIFICATION (NON-NEGOTIABLE)

Prove:

User cannot exceed action limits

Blast radius mismatch blocks execution

Emergency override is capped

Closed incident blocks execution

Incident cannot close without attestation

All failures are logged

9. OUTPUT FORMAT (STRICT)

Respond with ONLY:

Compliance status

Files created/modified

Verification summary

Promot end



Start Promot*

You are Cursor, acting as the implementation engineer for Phase 5.1 — LLM Generative Summarizer.

AUTHORITATIVE CONTEXT

explanation-assembly/ is NOT a summarizer.

You must build a new subsystem, not extend explanation-assembly.

LLM is NON-DECISIONAL, NON-ENFORCING, TEXT-ONLY.

This module is offline-first, deterministic, signed, and auditable.

OBJECTIVE

Design and implement an Offline LLM Summarizer that generates human-readable incident narratives from structured facts.

HARD CONSTRAINTS (NON-NEGOTIABLE)

NO enforcement

NO decisions

NO raw packets

NO secrets

Deterministic prompts

Prompt hash must be logged

Output hash must be logged

PII redaction at generation time

Air-gapped capable

PDF / HTML / CSV output

REQUIRED INPUTS

Incident timeline (from correlation engine)

KillChain stages

SHAP explanations (numeric only)

Forensic artifacts metadata (NOT raw dumps)

Policy decisions (facts only)

REQUIRED OUTPUTS

SOC narrative

Executive summary

Legal / Regulator narrative
(All generated separately, not post-processed)

REQUIRED DELIVERABLES (IN THIS ORDER)

Architecture write-up

New repo/module name

Clear separation from explanation-assembly

Prompt versioning & hashing model

PII redaction strategy

LLM execution sandbox

Output signing & audit logging

Failure modes (fail-closed)

EXPLICITLY FORBIDDEN

Online APIs

Self-modifying prompts

Auto-retraining

Free-text analyst input

“Helpful” hallucinations

OUTPUT FORMAT

Respond with:

Architecture diagram (textual)

Module structure

Prompt lifecycle flow

Open risks / assumptions (if any)

Do NOT write code yet.

End your response with:

“I am ready for implementation once architecture is approved.”

Promot End*


🔴 PROMPT 3 — LLM SUMMARIZER IMPLEMENTATION (FOUNDATION)

Start Promot*

You are Cursor, acting as the implementation engineer for Phase 5.1 — LLM Generative Summarizer (Foundation Build).

ARCHITECTURE STATUS

Architecture is APPROVED AND FROZEN

You must implement exactly what was approved

No scope expansion

No simplification

YOUR OBJECTIVE

Implement the foundational codebase for llm-summarizer/ such that:

All invariants are enforced

All failure modes are fail-closed

No LLM text generation quality tuning yet

Focus is correctness, safety, determinism

IMPLEMENT IN THIS EXACT ORDER
STEP 1 — SCHEMAS (MANDATORY FIRST)

Create frozen JSON schemas:

summary-request.schema.json

summary-output.schema.json

prompt-template.schema.json

redaction-log.schema.json

Rules:

Strict typing

No optional ambiguity

Reject unknown fields

Versioned schemas only

STEP 2 — PROMPT TEMPLATE REGISTRY

Implement:

Immutable prompt template registration

Template hash calculation (SHA256)

Version enforcement

Fail-closed on hash mismatch

Files:

prompts/template_registry.py

prompts/prompt_hasher.py

STEP 3 — PII REDACTION ENGINE

Implement deterministic redaction:

STRICT / BALANCED / FORENSIC modes

Regex-based pattern detection

Ordered, repeatable execution

Redaction log generation (immutable)

Files:

redaction/redaction_engine.py

redaction/pattern_detector.py

redaction/redaction_policy.py

STEP 4 — LLM EXECUTION SANDBOX (NO MODEL YET)

Implement sandbox WITHOUT calling the model yet:

Token counting

Memory limits

Timeout enforcement

Determinism checks

Fail-closed guards

Files:

llm/sandbox.py

llm/token_manager.py

STEP 5 — OUTPUT VALIDATION & SIGNING

Implement:

Output schema validation

Output hashing

ed25519 signing

Signature verification helper

Files:

output/validator.py

output/signer.py

STEP 6 — AUDIT LEDGER INTEGRATION

Emit ledger entries for:

Redaction completed

Prompt assembled

Sandbox executed (even without model)

Output signed

Do not skip audit on failures.

HARD RULES

No online access

No subprocess execution

No inference yet

No UI

No shortcuts

No TODOs

No “mock” logic

DELIVERABLE

Respond with:

Directory tree

Key class/function signatures

Example schema snippets

Explicit list of what is NOT implemented yet

End with:

“Phase 5.1 foundation implemented. Ready for inference layer.”

Promot End*


🔴 PROMPT 4 — LLM INFERENCE ENGINE (OFFLINE, DETERMINISTIC)

Start Promot*

You are Cursor, acting as the implementation engineer for
Phase 5.2 — LLM Inference Engine (Offline, Deterministic).

CONTEXT (FROZEN)

Phase 5.1 foundation is COMPLETE and FROZEN.

You must integrate inference without changing:

schemas

redaction

prompt assembly

audit semantics

OBJECTIVE

Implement actual LLM inference for llm-summarizer/ using offline GGUF models, with strict determinism and safety.

HARD CONSTRAINTS (NON-NEGOTIABLE)

Offline only (no network)

GGUF format only

Deterministic inference:

temperature = 0.0

fixed seed

Fail-closed on:

model hash mismatch

non-PROMOTED model

token overflow

timeout

memory breach

No prompt mutation

No post-generation editing

Same prompt + same model → same output (bit-for-bit)

IMPLEMENT IN THIS ORDER
STEP 1 — MODEL LOADER

Create:

llm/model_loader.py

Responsibilities:

Load GGUF model from filesystem

Model path from ENV only

Calculate model SHA256

Verify:

model exists

hash matches ai-model-registry

model state == PROMOTED

Fail-closed on any mismatch

STEP 2 — TOKENIZATION (REAL)

Upgrade:

llm/token_manager.py

Requirements:

Use the actual tokenizer for the chosen model

Accurate input + output token counting

Reject on overflow before inference

STEP 3 — INFERENCE ENGINE

Create:

llm/inference_engine.py

Responsibilities:

Accept final prompt string

Run deterministic inference

Enforce:

token limits

execution timeout

Return:

generated_text

token counts

inference time (ms)

STEP 4 — SANDBOX INTEGRATION

Wire inference into:

llm/sandbox.py

Requirements:

Memory limit enforcement

Timeout enforcement

No subprocess escape

Explicit failure exceptions

STEP 5 — AUDIT INTEGRATION

Emit ledger events:

llm_model_loaded

llm_inference_started

llm_inference_completed

llm_inference_failed (if applicable)

Include:

model_id

model_version

model_hash

input_tokens

output_tokens

inference_time_ms

EXPLICITLY FORBIDDEN

Online APIs

Auto-retries

Sampling

Temperature tuning

Streaming output

Partial results

DELIVERABLE

Respond with:

Updated directory tree

Key class/function signatures

How determinism is guaranteed

What is still NOT implemented after this phase

End with:

“Phase 5.2 inference layer implemented. Ready for rendering layer.”

Promot End*


🔴 PROMPT 5 — OUTPUT RENDERING (PDF / HTML / CSV)

Start Promot*

You are Cursor, acting as the implementation engineer for
Phase 5.3 — Output Rendering Layer (PDF / HTML / CSV).

CONTEXT (FROZEN)

Phase 5.1 and 5.2 are COMPLETE and FROZEN.

LLM inference already produces:

deterministic generated_text

output_hash

ed25519 signature

Rendering must consume validated, signed output, not raw prompts.

OBJECTIVE

Implement a deterministic, auditable rendering layer that converts generated summaries into:

PDF (compliance / regulator)

HTML (UI consumption)

CSV (regulatory ingestion)

HARD CONSTRAINTS (NON-NEGOTIABLE)

Rendering MUST NOT modify generated text

Rendering MUST NOT reflow meaning

Rendering MUST preserve exact text content

Rendering MUST log output_format + output_hash

Rendering MUST be deterministic

Rendering MUST fail-closed on any error

No network access

No dynamic templates from users

IMPLEMENT IN THIS ORDER
STEP 1 — RENDERER MODULE

Create:

output/renderer.py

Implement:

render_pdf(text: str, metadata: dict) -> bytes

render_html(text: str, metadata: dict) -> str

render_csv(text: str, metadata: dict) -> str

Rules:

PDF: fixed layout, monospaced or neutral font, no JS

HTML: static, no scripts, no external assets

CSV: one row per logical section, no free-form splitting

STEP 2 — METADATA BINDING

Each rendered output MUST embed:

summary_id

narrative_type

prompt_hash

model_id

model_version

output_hash

signed_at (RFC3339)

Metadata must be:

embedded in PDF footer or metadata

embedded in HTML <meta> tags

embedded as header rows in CSV

STEP 3 — SIGNED OUTPUT HANDLING

Rules:

Rendering occurs after output signing

Signature applies to original text

Renderer must:

include signature reference

NOT re-sign rendered artifacts

STEP 4 — AUDIT INTEGRATION

Emit ledger events:

summary_render_started

summary_render_completed

summary_render_failed

Include:

summary_id

output_format

output_hash

EXPLICITLY FORBIDDEN

Markdown rendering engines

Rich text editors

Dynamic HTML

External fonts or assets

Re-wrapping or paraphrasing text

DELIVERABLE

Respond with:

Updated directory tree

Renderer function signatures

Determinism guarantees per format

What is still NOT implemented after this phase

End with:

“Phase 5.3 rendering layer implemented. Ready for templates and CLI.”

Promot End*


🔴 PROMPT 6 — JINJA2 PROMPT TEMPLATES (AUTHORITATIVE CONTENT)

Start Promot*

You are Cursor, acting as the implementation engineer for
Phase 5.4 — Authoritative Prompt Templates (Jinja2).

CONTEXT (FROZEN)

Prompt registry, assembler, hashing, and inference are COMPLETE.

This phase is content definition, not logic.

Templates are security-critical artifacts.

OBJECTIVE

Create the initial frozen prompt templates that control exactly what the LLM may say.

TEMPLATES TO CREATE (MANDATORY)

Create directory:

prompts/templates/


Create exactly these files:

soc_narrative_v1.0.0.jinja2

executive_summary_v1.0.0.jinja2

legal_narrative_v1.0.0.jinja2

No others.

HARD CONSTRAINTS (NON-NEGOTIABLE)

Templates MUST:

Use only structured inputs

Never speculate

Never introduce new facts

No adjectives implying certainty unless supported by evidence

Explicitly distinguish:

Observed facts

Correlated inferences

Policy decisions

No mitigation advice

No blame language

No probabilistic wording unless numeric confidence exists

Deterministic ordering of sections

REQUIRED STRUCTURE (ALL TEMPLATES)

Each template MUST include sections in this exact order:

Header

Scope & Source of Information

Incident Timeline (facts only)

Observed Behaviors

Correlated Findings

Policy & Response Actions (facts only)

Evidence References

Limitations & Assumptions

Closing Statement

AUDIENCE-SPECIFIC RULES
SOC Narrative

Technical

Precise

No simplification

No business language

Executive Summary

Non-technical

No timestamps unless necessary

Focus on impact and containment

Max 1 page equivalent

Legal / Regulator Narrative

Formal tone

No abbreviations

Explicit disclaimers

Chain-of-custody emphasis

Jurisdiction-neutral language

VERSIONING RULES

Version = v1.0.0

Templates are immutable

Any change requires new version

Do NOT register templates yet

DELIVERABLE

Respond with:

Full contents of all three template files

Explanation of how each section avoids hallucination

Explicit statement of what the templates will never say

End with:

“Phase 5.4 prompt templates defined. Ready for CLI tools.”

Promot End*


🔴 PROMPT 7 — CLI TOOLS (ADMIN & VALIDATION ONLY)

Start Promot*

You are Cursor, acting as the implementation engineer for
Phase 5.5 — CLI Tools for LLM Summarizer (Admin & Validation Only).

CONTEXT (FROZEN)

Summarizer is UI-driven for users.

CLI is NOT a user interface.

CLI is for:

Admin operations

Air-gapped environments

CI / Global Validator

Template lifecycle control

OBJECTIVE

Implement safe, deterministic CLI tools for the LLM summarizer subsystem.

CLIs TO IMPLEMENT (MANDATORY)

Create directory:

cli/


Implement exactly these tools:

register_template.py

list_templates.py

generate_summary.py

render_summary.py

verify_model.py

No others.

TOOL BEHAVIOR (STRICT)
register_template.py

Input: template file path

Validate Jinja2 syntax

Calculate template hash

Register immutable template

Emit audit ledger entry

Fail if template already exists (same hash)

list_templates.py

Read-only

Show:

template_id

version

narrative_type

hash

registered_at

generate_summary.py

Input: summary-request JSON file

Call SummarizerAPI.generate_summary

Print:

summary_id

output_hash

signature

render_summary.py

Input: summary_id + format (PDF/HTML/CSV)

Write output to file

No regeneration

verify_model.py

Verify:

model exists

hash matches registry

state == PROMOTED

No inference

HARD CONSTRAINTS

No interactive prompts

No editing of templates

No bypass of registry

No silent failures

All failures logged

ENV-only configuration

DELIVERABLE

Respond with:

CLI directory tree

argparse command specs for each tool

Safety guarantees per tool

What remains after CLI completion

End with:

“Phase 5.5 CLI tools implemented. LLM subsystem complete.”

Promot End*

🔴 PROMPT 8 — WINDOWS AGENT ETW DEEP TELEMETRY

Start Promot*

You are Cursor, acting as the implementation engineer for
Phase 6 — Windows Agent Deep ETW Telemetry.

AUTHORITATIVE CONTEXT

Linux Agent already provides deep telemetry via eBPF.

Windows Agent currently implements command gate + enforcement, but lacks deep ETW-based visibility.

This phase is DETECTION ONLY.

No enforcement logic may be added or changed.

OBJECTIVE

Implement deep, deterministic ETW telemetry ingestion in the Windows Agent to reach parity with Linux Agent observability.

TELEMETRY TO IMPLEMENT (MANDATORY)

You MUST implement ETW collection for all of the following categories:

1. PROCESS & THREAD ACTIVITY

Process creation / termination

Parent–child lineage

Command line

Image path & hash

Thread start / injection indicators

ETW Providers:

Microsoft-Windows-Kernel-Process

Microsoft-Windows-Kernel-Thread

2. FILESYSTEM ACTIVITY

File create / write / rename / delete

File entropy change indicator (pre/post write size heuristic)

Executable write detection

ETW Providers:

Microsoft-Windows-Kernel-File

3. REGISTRY ACTIVITY

Key creation / modification / deletion

Autorun & persistence locations

Service & driver registration

ETW Providers:

Microsoft-Windows-Kernel-Registry

4. NETWORK INTENT (HOST-SIDE)

Socket creation

Bind / connect intent (not DPI)

Process ↔ socket correlation

ETW Providers:

Microsoft-Windows-Kernel-Network

Microsoft-Windows-TCPIP

5. MEMORY & INJECTION SIGNALS (BEST-EFFORT)

Remote thread creation

Process hollowing indicators

RWX memory allocation flags (where available)

ETW Providers:

Microsoft-Windows-Kernel-Memory

Microsoft-Windows-Threat-Intelligence (if accessible)

HARD CONSTRAINTS (NON-NEGOTIABLE)

ETW READ-ONLY — no blocking, no hooking

NO kernel drivers (user-mode ETW only)

NO performance degradation >5% CPU

Fail-open telemetry (agent must not crash)

NO DB access

ENV-only configuration

Signed telemetry only

Deterministic schemas

Offline capable

No ML inference on endpoint

ARCHITECTURE REQUIREMENTS
Module Placement
ransomeye-agent-windows/
└── agent/
    ├── etw/
    │   ├── providers.py
    │   ├── session_manager.py
    │   ├── event_parser.py
    │   ├── schema_mapper.py
    │   └── health_monitor.py

Output

Emit normalized protobuf events

Same schema family as Linux Agent where possible

Include:

host_id

process_id

event_type

timestamp (ETW native)

raw_provider_id (for traceability)

VALIDATION REQUIREMENTS

You MUST provide:

Event volume benchmarks (idle vs active)

CPU / memory impact measurements

Provider failure handling

Session restart resilience

Telemetry loss detection

EXPLICITLY FORBIDDEN

User-mode API hooking

DLL injection

Inline patching

WMI polling loops

Signature-based detection

Any enforcement or blocking logic

DELIVERABLE

Respond with:

ETW architecture design

Provider list with rationale

Normalized event schema examples

Performance mitigation strategy

Explicit list of what is NOT implemented

End with:

“Phase 6 Windows ETW telemetry designed. Ready for implementation approval.”

Promot End*


🔴 PROMPT 9 — WINDOWS ETW TELEMETRY IMPLEMENTATION

Start Promot*

You are Cursor, acting as the implementation engineer for
Phase 6 — Windows Agent ETW Telemetry (Implementation).

CONTEXT (FROZEN)

Phase 6 ETW design is APPROVED AND FROZEN

This is DETECTION ONLY

Do NOT modify:

command gate

enforcement logic

signing logic semantics

You are implementing exactly the approved design

OBJECTIVE

Implement user-mode ETW telemetry collection in the Windows Agent with:

Stable session management

Deterministic event normalization

Cryptographic signing

Offline buffering

Health monitoring

IMPLEMENT IN THIS EXACT ORDER
STEP 1 — PROVIDER DEFINITIONS

File:

agent/etw/providers.py


Implement:

Provider GUID registry

Enabled event IDs per provider

Keyword / level filters

Provider metadata (name, purpose)

Fail-closed on invalid provider config.

STEP 2 — SESSION MANAGER

File:

agent/etw/session_manager.py


Implement:

ETW session lifecycle (start/stop/restart)

Provider attachment

Failure recovery with backoff

Graceful shutdown handling

Must:

Never crash agent

Emit health events on restart/failure

STEP 3 — EVENT PARSER

File:

agent/etw/event_parser.py


Implement:

Binary ETW parsing (no XML)

Minimal field extraction

Lazy parsing

Provider-specific parsers

Reject malformed events safely.

STEP 4 — SCHEMA MAPPER

File:

agent/etw/schema_mapper.py


Implement:

Deterministic mapping to normalized schemas

Field canonicalization

ETW provider + event ID preservation

Timestamp normalization

Schemas must align with Linux Agent where possible.

STEP 5 — BUFFER MANAGER

File:

agent/etw/buffer_manager.py


Implement:

In-memory ring buffer

Disk-backed overflow buffer

Backpressure handling

Loss detection counters

Offline first. No drops without audit.

STEP 6 — HEALTH MONITOR

File:

agent/etw/health_monitor.py


Implement:

Provider liveness checks

Event rate monitoring

Session restart detection

Telemetry loss detection

Emit signed health telemetry.

STEP 7 — TELEMETRY INTEGRATION

Wire ETW output into:

agent/telemetry/event_envelope.py
agent/telemetry/signer.py
agent/telemetry/sender.py


Requirements:

Every event signed

Envelope includes:

host_id

event_type

timestamp

provider_id

Offline buffering respected

VALIDATION REQUIREMENTS

You MUST include:

Event volume measurements (idle / active)

CPU & memory benchmarks

Provider failure simulation

Session restart simulation

Offline buffer replay validation

HARD RULES

No kernel drivers

No hooks

No WMI

No ML

No enforcement

ENV-only config

No TODOs

No placeholders

DELIVERABLE

Respond with:

Updated directory tree

Key class/function signatures

Example normalized events

Performance benchmark summary

Explicit list of remaining gaps (if any)

End with:

“Phase 6 Windows ETW telemetry implemented. Ready for Phase B.”

Promot End*


Promot Start

You are Cursor, acting as the Database & Data-Plane Hardening Engineer for RansomEye.

AUTHORITATIVE CONTEXT

Windows ETW telemetry implementation exists.

Core Engine, DPI Probe, and Linux Agent may run on the same host (POC/demo).

PostgreSQL is mandatory.

Event volume can exceed 1,000,000 writes/reads concurrently.

Zero data corruption is acceptable.

Wrong table / column access is unacceptable.

This prompt is about architecture correctness, DB safety, and scale — not features.

OBJECTIVE

Design and enforce a bulletproof data-plane architecture such that:

Every module:

Writes ONLY to its designated tables

Reads ONLY via approved views

Database:

Handles massive concurrent writes safely

Avoids lock contention

Avoids table bloat

Avoids index storms

Co-located deployment:

Core + DPI + Linux Agent on same machine

No port conflicts

No resource starvation

Predictable performance isolation

MANDATORY DELIVERABLES (NO SKIP)
STEP 1 — WRITE/READ OWNERSHIP MATRIX (CRITICAL)

Produce a strict matrix:

Module	WRITE Tables	READ Tables	READ Method

Rules:

Agents never read DB

DPI never reads agent tables

Core reads via views only

No direct cross-module table reads

This matrix is binding.

STEP 2 — SCHEMA HARDENING STRATEGY

Define:

Event ingestion tables (append-only)

Partitioning strategy (time + source)

Indexing strategy (minimal, write-optimized)

HOT update avoidance

WAL tuning assumptions

Explicitly state:

Which tables are UNLOGGED vs LOGGED

Which use BRIN vs BTREE

Which are partitioned

STEP 3 — HIGH-CONCURRENCY INGEST DESIGN

Explain how DB handles:

1M+ inserts

Burst traffic

Backpressure from Core

Queue-based ingest

Retry semantics

Must include:

COPY vs INSERT decision

Batch sizes

Failure handling

No duplicate ingestion

STEP 4 — CO-LOCATED POC SAFETY

Explain:

Port separation

CPU pinning strategy

Memory limits per service

IO scheduling considerations

Network namespace / socket separation (if any)

No conflicts allowed.

STEP 5 — GUARANTEES & FAILURE MODES

Explicitly list:

What failures are tolerated

What failures are fatal

How corruption is prevented

How partial writes are handled

How replay works

HARD RULES

No assumptions

No “should be fine”

No vague language

No skipping DB internals

No changing earlier architectural decisions

OUTPUT FORMAT

Respond with:

Data-plane architecture explanation

Ownership matrix table

Partition/index strategy

Co-located deployment safety model

Explicit list of remaining risks (if any)

End your response with:

“Data-plane hardened. Ready to proceed to Phase B.”

*****Promt End *****



Promot Start

You are Cursor, acting as the Forensic Intelligence Engineer for
Phase B — Advanced Forensic & Behavior Summarization.

AUTHORITATIVE CONTEXT

Data plane is hardened and frozen.

Raw, normalized, and correlated events exist.

This phase is POST-INCIDENT ONLY.

This phase is NOT LLM-based.

Output must be deterministic and replayable.

OBJECTIVE

Build a deterministic forensic summarization engine that:

Reconstructs attacker behavior step-by-step

Explains what happened, how it unfolded, what evidence exists

Produces machine-verifiable summaries

Does NOT speculate

Does NOT recommend actions

Does NOT infer intent beyond evidence

REQUIRED CAPABILITIES (MANDATORY)
1. BEHAVIORAL CHAIN RECONSTRUCTION

Process lineage reconstruction

File modification chains

Persistence establishment chains

Network intent progression

Lateral preparation indicators

2. TEMPORAL GRAPH SUMMARIZATION

Collapse large event sets into phases

Identify:

Initial execution

Expansion

Persistence

Exfiltration prep (if any)

Deterministic phase boundaries

3. EVIDENCE LINKING

Every claim links to:

event_id

table

timestamp

No statement without evidence references

4. OUTPUT FORMATS

JSON (machine)

Text (human, non-LLM)

Graph metadata (nodes + edges)

HARD RULES

No ML

No LLM

No probabilities

No adjectives

No external intel

No policy logic

No enforcement

DELIVERABLE

Respond with:

Forensic summarization architecture

Data sources used (tables/views)

Deterministic summarization algorithm

Example forensic summary output

Explicit list of limitations

End with:

“Phase B forensic summarization designed. Ready for implementation.”

*****Promt End *****



Promot Start

You are Cursor, acting as the Implementation Engineer for
Phase B — Advanced Forensic & Behavior Summarization.

AUTHORITATIVE CONTEXT

Data plane is hardened and frozen.

Phase B design is APPROVED AND FROZEN.

This is POST-INCIDENT ONLY.

This is NOT ML / NOT LLM.

Output must be deterministic, replayable, evidence-linked.

Summaries are accessed via Core UI, not CLI in production.

OBJECTIVE

Implement the forensic summarization engine exactly as designed.

IMPLEMENT IN THIS ORDER (MANDATORY)
STEP 1 — BEHAVIORAL CHAIN BUILDER

File:

engine/behavioral_chain_builder.py


Implement:

Process lineage reconstruction using (pid, start_time)

File modification chains

Persistence establishment chains

Network intent progression

Lateral preparation indicators (rule-based thresholds)

Fail if evidence missing → explicitly mark gaps.

STEP 2 — TEMPORAL PHASE DETECTOR

File:

engine/temporal_phase_detector.py


Implement:

Deterministic phase detection:

INITIAL_EXECUTION

EXPANSION

PERSISTENCE

EXFILTRATION_PREP

Explicit boundary rules

Null-safe handling for missing phases

No overlap between phases

STEP 3 — EVIDENCE LINKER

File:

engine/evidence_linker.py


Implement:

Claim-to-evidence binding

Reject claims without evidence

Evidence reference format:

event_id

table

observed_at

No exceptions.

STEP 4 — SUMMARY GENERATOR (NON-LLM)

File:

engine/summary_generator.py


Implement:

Template-based text generation

Fixed section ordering

No adjectives

No inference language

No mitigation advice

Deterministic formatting

STEP 5 — API INTEGRATION

File:

api/summarization_api.py


Implement:

Summary generation endpoint

JSON output

Text output

Graph metadata output

Read-only DB access via views only

STEP 6 — CLI (TEST / AUDIT ONLY)

File:

cli/generate_summary.py


Purpose:

Dev/test/audit use only

Not user-facing in production

HARD RULES

No ML

No LLM

No probabilities

No heuristics beyond defined rules

No policy logic

No enforcement

No DB writes except summary tables

DELIVERABLE

Respond with:

Updated directory tree

Key function signatures

Example summary outputs (JSON + text)

Explicit list of remaining limitations (if any)

End with:

“Phase B forensic summarization implemented. Ready for Phase C.”

Promt End



Promot Start

You are Cursor, acting as the Validation & Assurance Engineer for
Phase C — Global GA Validation & Determinism Proof.

AUTHORITATIVE CONTEXT

Core Engine, DPI Probe, Linux Agent, Windows Agent are implemented.

Phase B forensic summarization is implemented and corrected.

Data plane is hardened and frozen.

This phase determines GA eligibility.

OBJECTIVE

Prove that RansomEye is GA-ready by validating:

Determinism

Replayability

Data integrity

Safety under load

No hidden failure paths

MANDATORY VALIDATION TRACKS (ALL REQUIRED)
TRACK 1 — DETERMINISM PROOF

Same inputs → same outputs across:

Detection

Correlation

Forensics

Summarization

Hash comparison required

Multiple runs required

TRACK 2 — REPLAY & REHYDRATION

Rebuild:

Incidents

Killchains

Forensic summaries

From raw_events only

No divergence allowed

TRACK 3 — FAILURE INJECTION

Inject:

DB connection loss

Agent disconnect

Queue overflow

Duplicate events

Partial writes

Verify:

No corruption

No silent loss

Correct degradation

TRACK 4 — SCALE & STRESS

≥1,000,000 event ingestion burst

Mixed ETW + DPI + Agent traffic

Co-located deployment

Verify:

No deadlocks

No unbounded latency

No data loss

TRACK 5 — SECURITY & SAFETY

Verify:

No enforcement without authority

No unsigned execution

No cross-module DB access

No direct table reads

RBAC enforcement

DELIVERABLE

Respond with:

Validation plan

Test scenarios

Metrics collected

Pass / Fail criteria

Explicit GA verdict

End with:

“Phase C validation complete. GA decision ready.”

*****Promt End *****



Promot Start

You are Cursor, acting as the Validation & Assurance Engineer for
Phase C — Global GA Validation & Determinism Proof (Corrected).

AUTHORITATIVE CONTEXT

Core Engine, DPI Probe, Linux Agent, Windows Agent are implemented.

Phase B forensic summarization is implemented and corrected.

Data plane is hardened and frozen.

LLM output is governed by semantic determinism, not byte equality.

This phase determines GA eligibility.

OBJECTIVE

Prove that RansomEye is GA-ready through correct, realistic, and technically valid validation.

MANDATORY VALIDATION TRACKS (ALL REQUIRED)
TRACK 1 — DETERMINISM (CORRECTED)

DET-001: Detection determinism (Agent → raw_events)
DET-002: Normalization determinism (raw_events → normalized)
DET-003: Correlation determinism (normalized → incidents)
DET-004: Forensic summarization determinism (incidents → summaries)
DET-005: LLM semantic determinism

Rules:

Non-LLM paths → hash equality required

LLM paths → schema + semantic equivalence only

Forbidden language checks mandatory

Structure, ordering, and exclusions must match

TRACK 2 — REPLAY & REHYDRATION (SPLIT MODES)

REP-A — Identity Replay

Same code

Same schemas

Bit-exact hashes required

REP-B — Evolution Replay

New code version

Same inputs

Semantic equivalence required

Hash equality NOT required

Both modes must pass.

TRACK 3 — FAILURE INJECTION

FAIL-001: DB connection loss
FAIL-002: Agent disconnect
FAIL-003: Queue overflow
FAIL-004: Duplicate events
FAIL-005: Partial writes
FAIL-006: DB restart mid-processing

Pass criteria:

No corruption

No silent loss

Explicit degradation only

TRACK 4 — SCALE & STRESS (REALISTIC)

SCALE-001: Burst ingestion
SCALE-002: Sustained load (1M+ events)
SCALE-003: Mixed traffic (ETW + DPI + Agent)
SCALE-004: Co-located deployment
SCALE-005: Backpressure recovery

Latency targets (LOCKED):

p50 < 1s

p95 < 3s

p99 < 5s

TRACK 5 — SECURITY & SAFETY

SEC-001: Enforcement authority verification
SEC-002: Signed execution verification
SEC-003: No direct table access
SEC-004: RBAC enforcement
SEC-005: Data-plane ownership enforcement
SEC-006: Audit ledger integrity

TRACK 6 — AGENT REALITY CHECK (NEW)

AGENT-001: Linux real agent vs simulator
AGENT-002: Windows real agent vs simulator

Requirement:

Structural and semantic equivalence

No simulator-only assumptions allowed

DELIVERABLE

Respond with:

Corrected validation plan

Test execution results

Metrics collected

Pass / Fail per track

Explicit GA verdict

End with:

“Phase C validation complete. GA decision ready.”

Promt End




Promot Start

You are Cursor, acting as the Execution Engineer for
Phase C — Global GA Validation (Final Execution).

AUTHORITATIVE CONTEXT

Phase C validation plan is APPROVED AND FROZEN

All required fixes have been incorporated:

DET-006 (PID reuse / identity disambiguation)

Functional Parity (action-based agent testing)

Identity Replay vs Evolution Replay

Backwards Compatibility (superset validation)

Realistic latency targets

Disk I/O metrics included

This phase determines the final GA decision

OBJECTIVE

Execute the approved Phase C validation plan and produce verifiable evidence artifacts.

EXECUTION REQUIREMENTS (MANDATORY)
1. RUN ALL TRACKS

Execute all 34 tests across 6 tracks exactly as defined:

Determinism (DET-001 → DET-006)

Replay (REP-A + REP-B)

Failure Injection

Scale & Stress (with I/O metrics)

Security & Safety

Agent Reality Check (Functional Parity)

2. COLLECT EVIDENCE ARTIFACTS

For each track, produce:

JSON logs (machine-readable)

Markdown reports (human-readable)

Hash/signature verification where applicable

Artifacts must be immutable once generated.

3. APPLY CORRECT PASS/FAIL LOGIC

Non-LLM paths → bit-exact hashes

LLM paths → schema + backwards-compatible superset validation

Replay:

REP-A → bit-exact

REP-B → backwards compatibility

Scale:

p50 < 1s

p95 < 3s

p99 < 5s

Any critical failure → GA blocked

DELIVERABLE

Respond with:

Test execution summary

Pass/Fail status per track

Collected metrics (including Disk I/O wait & queue depth)

Evidence artifact list

Final GA verdict

End with one of the following (no ambiguity):

“Phase C validation PASSED. RansomEye is GA-READY.”

OR

“Phase C validation FAILED. GA is BLOCKED.”

*****Promt End *****


Promot Start

You are Cursor, acting as the Validation Engineer for
Phase C — Determinism Track Correction.

AUTHORITATIVE CONTEXT

Phase C execution framework is implemented.

One critical coverage gap remains.

GA execution is blocked until this is fixed.

OBJECTIVE

Add DET-006: Identity Disambiguation Determinism to Track 1 — Determinism and wire it fully into the execution framework.

REQUIRED IMPLEMENTATION (MANDATORY)
STEP 1 — ADD TEST CASE

Add a new determinism test:

DET-006: Identity Disambiguation Determinism


Test scenario:

Same PID reused

Different process start times (or process GUID)

Appears across:

raw_events

normalized events

correlation

forensic summarization

STEP 2 — ASSERTIONS

DET-006 must assert:

Distinct process identities created

No lineage merge

Deterministic behavior across runs

Replay-safe (Identity Replay compatible)

Non-LLM path → bit-exact hash match

STEP 3 — FRAMEWORK INTEGRATION

Update Track 1 count to 6 tests

Update reports and evidence artifacts

Update final GA checklist to include DET-006

DELIVERABLE

Respond with:

Updated Track 1 definition (DET-001 → DET-006)

DET-006 test logic

Updated execution summary

Confirmation that Phase C execution is unblocked

End with:

“DET-006 implemented. Phase C execution unblocked.”

Promt End



Promot Start

You are Cursor, acting as the Validation Execution Architect for
Phase C — Global GA Validation (Multi-Host, Corrected Model).

AUTHORITATIVE CONTEXT

RansomEye is a multi-OS system.

Linux and Windows agents cannot be validated on the same host.

ETW is Windows-only and cannot run on Linux.

GA certification must be technically defensible.

This prompt replaces all previous Phase C execution assumptions.

OBJECTIVE

Implement Phase C execution as a two-run, multi-host validation process with a single authoritative GA verdict.

EXECUTION MODEL (LOCKED)
PHASE C-L — LINUX EXECUTION

Runs on: Linux
Mandatory Tracks:

Track 1: Determinism (DET-001 → DET-006)

Track 2: Replay (REP-A Identity, REP-B Evolution)

Track 3: Failure Injection (FAIL-001 → FAIL-006)

Track 4: Scale & Stress (with Disk I/O wait, Queue depth)

Track 5: Security & Safety

Track 6-A: Agent Reality Check — Linux Agent only

Output Artifact (MANDATORY):

phase_c_linux_results.json

PHASE C-W — WINDOWS EXECUTION

Runs on: Native Windows host
Mandatory Tracks:

Track 6-B: Agent Reality Check — Windows Agent (ETW)

What must be validated:

ETW event capture

Normalization correctness

PID reuse disambiguation

Functional parity with simulator

Deterministic schema output

Output Artifact (MANDATORY):

phase_c_windows_results.json

GA VERDICT LOGIC (NON-NEGOTIABLE)

GA verdict must be computed as:

GA_READY =
  phase_c_linux_results.PASS == true
  AND
  phase_c_windows_results.PASS == true


Rules:

Any skipped mandatory test = FAIL

FAIL-006 cannot be skipped

AGENT-002 cannot be skipped

No partial or provisional GA allowed

HARNESS REQUIREMENTS
Linux Harness Must:

Refuse to run AGENT-002

Explicitly state:

“Windows Agent validation must be run on Windows host”

Windows Harness Must:

Run only Track 6-B

Validate ETW via real agent execution

Produce standalone results file

DELIVERABLE

Respond with:

Updated Phase C execution architecture

Linux harness behavior changes

Windows harness behavior changes

GA verdict aggregation logic

Explicit confirmation:

“Phase C execution model corrected. GA validation is now OS-correct and audit-safe.”

Promt End



Promot Start

You are Cursor, acting as the Build-Integrity and Validation Architect for RansomEye.

NON-NEGOTIABLE SYSTEM CONTRACT

Global credentials for POC + GA are fixed:

Database User: gagan
Database Password: gagan


These are default build credentials and must be embedded.
Environment variables may override but absence must never break execution.

Database connectivity is a HARD GATE.

If DB connection fails → immediate fatal exit

No tracks execute

No partial verdict

Clear error message required

Phase C is multi-host:

Linux executes Phase C-L only

Windows executes Phase C-W only

Aggregation happens only after both complete

Windows ETW tests must NEVER run on Linux

Skipped mandatory tests = FAIL

FAIL-006 cannot be skipped for GA

AGENT-002 cannot be skipped for GA

Execution must be module-safe:

All tools run via python3 -m

Direct script execution must not break imports

REQUIRED CHANGES

Implement the following:

A. Fix DB Connection Defaults

Default user/password must be gagan / gagan

Add startup DB connectivity assertion

Fail fast if DB unreachable

B. Harden Phase C Executor

Abort immediately on DB failure

Never compute verdict if tracks didn’t execute

Always initialize verdict structure safely

C. Enforce OS Execution Boundaries

Linux refuses --mode windows

Windows refuses Linux tracks

Clear fatal errors when violated

D. Fix GA Aggregation

Aggregator reads result JSONs only

No imports from executor

GA_READY only if Phase C-L PASS AND Phase C-W PASS

DELIVERABLE

Respond with:

Confirmation that DB credentials are now embedded (gagan/gagan)

Code changes summary

Updated execution commands (Linux, Windows, Aggregation)

Explicit statement:

“Phase C execution is now credential-safe, OS-correct, fail-fast, and GA-reliable.”

Promt End


Promot Start

You are now acting as Database & Validation Bootstrap Engineer for RansomEye.

Your task is to correct the Phase C database assumptions and make database authentication explicit, verifiable, and non-ambiguous.

This is NOT an application logic change — this is infrastructure correctness enforcement.

🚨 CRITICAL REALITY TO ACKNOWLEDGE (DO NOT ARGUE)

Embedding credentials in Python code does NOT:

Create PostgreSQL users

Set passwords

Grant privileges

Fix pg_hba.conf

Create databases

Phase C is failing correctly because PostgreSQL is not bootstrapped correctly.

REQUIRED CHANGES (DO ALL)
1. Add Explicit DB Credential Verification (Preflight)

In preflight_check():

Detect authentication failure vs connection failure

If authentication fails:

Print EXACT actionable error

Abort Phase C immediately

Example (exact wording required):

❌ FATAL: PostgreSQL authentication failed.

Required POC credentials:
  user: gagan
  password: gagan
  database: ransomeye

This is NOT a code issue.
PostgreSQL is not bootstrapped correctly.

Fix by running (once, as postgres superuser):

  CREATE ROLE gagan LOGIN PASSWORD 'gagan';
  CREATE DATABASE ransomeye OWNER gagan;
  GRANT ALL PRIVILEGES ON DATABASE ransomeye TO gagan;

Phase C cannot continue.


⚠️ Do NOT attempt auto-creation from Python.
That would violate security boundaries.

2. Add DB Bootstrap Validator (Hard Gate)

Create a new helper:

validation/harness/db_bootstrap_validator.py

Responsibilities:

Verify role exists

Verify database exists

Verify ownership

Verify login works using psycopg2

Verify basic SELECT 1

Return a structured failure reason, not just True/False.

3. Update Phase C Documentation (MANDATORY)

In PHASE_C_EXECUTION_SUMMARY.md add a bold section:

DATABASE BOOTSTRAP REQUIREMENT (MANDATORY)

Phase C assumes PostgreSQL is pre-provisioned with:

  User: gagan
  Password: gagan
  Database: ransomeye
  Owner: gagan

Phase C WILL FAIL if this is not true.
This is intentional and correct.

4. DO NOT CHANGE THESE THINGS

❌ Do NOT:

Remove gagan/gagan defaults

Add fallback passwords

Silence auth failures

Auto-create DB users

Downgrade failure to warning

Failing here is security-correct behavior.

ACCEPTANCE CRITERIA

After your changes:

Phase C failure message must clearly say:

DB is misconfigured

This is not a code bug

No stack traces

No confusion

No retries

No silent fallback

This must be obvious to any auditor, SOC engineer, or SRE.

FINAL NOTE (IMPORTANT)

If Phase C passes without DB bootstrap verification,
RansomEye is NOT GA-grade.

Fix this once, permanently.

*****Promt End *****



Promot Start

You are now acting as PostgreSQL Environment Diagnostics Engineer.

Your task is to make the database bootstrap validator fully self-explanatory on Linux systems, without weakening security or auto-fixing anything.

This is the final diagnostic enhancement.

REQUIRED CHANGE (ONLY THIS)
Enhance PEER / pg_hba Failure Messaging

When verify_db_bootstrap() detects:

CASE 2 (peer authentication)

CASE 6 (pg_hba blocks password auth)

Do the following:

1. Detect pg_hba.conf Location (Read-Only)

Attempt (in order):

Run:

SHOW hba_file;


If unavailable, fall back to known defaults:

/etc/postgresql/*/main/pg_hba.conf

/var/lib/pgsql/data/pg_hba.conf

Do NOT read or modify the file.
Path detection only.

2. Emit OS-Aware Diagnostic Message

For PEER auth, error output must include:

❌ FATAL: PostgreSQL is using PEER authentication.

Password-based login for role 'gagan' is ignored.

Detected authentication method: peer
Detected pg_hba.conf location:
  /etc/postgresql/XX/main/pg_hba.conf

On Ubuntu/Debian, PostgreSQL defaults to PEER auth for local sockets.

To allow password authentication, update pg_hba.conf and change:

  local   all   gagan   peer

to:

  local   all   gagan   md5

Then restart PostgreSQL.

Phase C cannot continue.

3. Do NOT Change Anything Else

❌ No auto-edit
❌ No restart
❌ No privilege escalation
❌ No fallback auth

Diagnostics only.

ACCEPTANCE CRITERIA

After this change:

An operator can fix PostgreSQL without asking you

Zero ambiguity remains

Phase C remains fail-fast and security-correct

This is the final Phase C infrastructure fix

Implement now.

Promt End



PROMPT START

You are working on RansomEye v1.0 GA – Audit Remediation Phase.
This is NOT v2, NOT new feature development, and NOT architectural expansion.

🔒 GLOBAL CONSTRAINTS (MANDATORY)

This is v1.0 GA hardening only

No new features

No redesigns beyond fixing validation failures

No credential changes — keep gagan / gagan as-is

Fail-closed behavior must be preserved

Diagnostics only, never auto-fix

Treat this as code-freeze remediation

TASK 1 — IMPLEMENT PRE-FLIGHT DATABASE DIAGNOSTIC (MANDATORY GA GATE)
Objective

Prevent opaque startup crashes caused by PostgreSQL authentication misconfiguration (PEER vs MD5), while preserving security boundaries.

Current Failure

When PostgreSQL uses PEER authentication (default on Debian/Ubuntu), RansomEye crashes with a generic DB connection error, even if credentials are correct.

This violates:

Enterprise usability

Audit readiness

Operator trust

REQUIRED IMPLEMENTATION

Create a diagnostic-only module:

core/diagnostics/db_bootstrap_validator.py

Behavior (STRICT)

Attempt DB connection using existing credentials (gagan / gagan)

If authentication fails:

Inspect PostgreSQL error code / message

Detect PEER authentication mismatch

If PEER auth is detected:

DO NOT MODIFY ANY FILE

DO NOT FALL BACK

DO NOT CONTINUE STARTUP

Emit a clear, actionable error:

Example (wording can vary, clarity must not):

FATAL: PostgreSQL is rejecting password authentication.
Detected PEER authentication in pg_hba.conf.
Please change the authentication method from peer to md5 for user gagan.

Exit fail-closed

HARD RULES

❌ No auto-editing pg_hba.conf

❌ No weakening authentication

❌ No retries with alternate modes

❌ No credential rotation

✅ Diagnostics only

✅ Deterministic output

✅ Enterprise-grade messaging

INTEGRATION REQUIREMENT

This validator must run before any schema validation or service startup

If it fails → system must terminate cleanly with the diagnostic message

DELIVERABLES

db_bootstrap_validator.py

Integration point showing where Core calls it

Example failure output (as comment or test)

Confirmation that no security boundary was weakened

ACCEPTANCE CRITERIA (GA BLOCKING)

PEER auth → guided failure

MD5 auth → normal startup

No silent crashes

No auto-fix behavior

Respond only with:

Implementation approach

File paths

Key code excerpts

Confirmation of rule compliance

PROMPT END





PROMPT 2 — OS-Aware Validation Executor (GA Gate)

PROMPT START

You are working on RansomEye v1.0 GA – Audit Remediation Phase.
This is NOT v2, NOT new feature development, and NOT architectural expansion.

🔒 GLOBAL CONSTRAINTS (MANDATORY)

v1.0 GA hardening only

No new features

No redesigns beyond fixing validation failures

No credential changes (gagan / gagan remains)

Fail-closed behavior is mandatory

Diagnostics and validation only

Scope creep is forbidden

TASK 2 — OS-AWARE VALIDATION EXECUTOR (MANDATORY GA GATE)
Objective

Prevent invalid or misleading validation failures caused by running platform-specific validation tracks on the wrong operating system.

This is required for:

Audit correctness

Reproducibility

Legal defensibility of validation results

Current Failure

The validation harness allows:

Windows-specific tracks (e.g., ETW-based) to run on Linux

Linux-specific tracks (e.g., eBPF-based) to run on Windows

This causes:

Confusing failures

False negatives

Invalid audit evidence

REQUIRED IMPLEMENTATION

Modify the validation executor:

validation/executor.py

Behavior (STRICT)

At executor startup:

Detect host OS using platform.system()

Enforce hard OS gating:

If OS == Linux:

Block all Windows-only tracks (e.g., ETW)

If OS == Windows:

Block all Linux-only tracks (e.g., eBPF)

If a blocked track is requested:

Emit a clear, final error

Explain why the track is invalid on this OS

Exit fail-closed

Do not attempt partial execution

Do not silently skip tracks

HARD RULES

❌ No auto-selection of alternate tracks

❌ No warnings-only behavior

❌ No “best effort” execution

✅ Explicit refusal

✅ Deterministic messaging

✅ Audit-safe failure

DELIVERABLES

Updated executor.py

OS detection logic

Explicit track-to-OS mapping

Example failure output (comment or test)

Confirmation of fail-closed behavior

ACCEPTANCE CRITERIA (GA BLOCKING)

Linux host + Windows track → hard failure

Windows host + Linux track → hard failure

Correct OS + correct track → normal execution

No false audit results possible

Respond only with:

Implementation approach

File paths

Key code excerpts

Confirmation of rule compliance

PROMPT END




PROMPT 3 — OPERATIONAL TELEMETRY (“GLASS COCKPIT”)

PROMPT START

You are working on RansomEye v1.0 GA – Audit Remediation Phase.
This is Phase D: Observability Without Compromise.

🔒 GLOBAL CONSTRAINTS (MANDATORY)

v1.0 GA hardening only

Internal-only visibility (SRE / Admin use)

NO PII

NO payload data

NO incident or threat details

Lightweight metrics only (must not slow ingest)

Fail-safe behavior required

TASK 3 — IMPLEMENT /health/metrics ENDPOINT (MANDATORY GA GATE)
Objective

Provide clear operational visibility into RansomEye’s own health so operators can detect failure before security guarantees are compromised.

This endpoint monitors the system, not threats.

Current Gap

RansomEye processes telemetry but exposes no self-health indicators:

Ingest backpressure is invisible

DB latency is unknown

Agent connectivity loss is silent

This violates enterprise SRE expectations.

REQUIRED IMPLEMENTATION
1. Endpoint

Method: GET

Path: /health/metrics

Format: JSON

Non-blocking (must never hang)

2. Location

Create or extend a diagnostics router, e.g.:

services/ingest/app/routes/diagnostics.py


and register it in the Ingest FastAPI app.

METRICS TO EXPOSE (STRICT — NO ADDITIONS)
{
  "system_status": "HEALTHY | DEGRADED | CRITICAL",
  "ingest_rate_eps": <float>,
  "db_write_latency_ms": <float>,
  "queue_depth": <int>,
  "agent_heartbeat_lag_sec": <float>
}

Metric Definitions

system_status

HEALTHY: all metrics within expected bounds

DEGRADED: elevated latency / backlog

CRITICAL: DB unreachable or ingest stalled

ingest_rate_eps

1-minute moving average

Must be computed efficiently (counter + time window)

db_write_latency_ms

Average of last ~100 DB writes

No per-query instrumentation overhead

queue_depth

Current size of ingest / processing buffer

agent_heartbeat_lag_sec

Max time since last valid agent heartbeat

Do not expose agent identity

HARD SECURITY & PRIVACY RULES

❌ No hostnames

❌ No IP addresses

❌ No tenant identifiers

❌ No incident metadata

❌ No file paths

❌ No payload samples

This endpoint is operational telemetry only.

FAILURE BEHAVIOR (MANDATORY)

If DB is unreachable:

Return HTTP 200

system_status = "CRITICAL"

Do not throw exceptions

Do not hang

Do not retry indefinitely

DELIVERABLES

Metrics collection approach (lightweight, in-memory)

File paths modified/added

Key code excerpts

Example JSON output

Explicit confirmation that no PII is exposed

ACCEPTANCE CRITERIA (GA BLOCKING)

Endpoint returns 200 OK

JSON schema matches exactly

Metrics update in real time

No ingest slowdown

No privacy leakage

Respond only with:

Implementation approach

File paths

Key code excerpts

Confirmation of privacy & security compliance

PROMPT END



PROMPT 4 — DETERMINISTIC REPORTING & BRANDING SEPARATION

(MANDATORY GA GATE — LEGAL ADMISSIBILITY)

PROMPT START

You are working on RansomEye v1.0 GA – Audit Remediation Phase.
This is Phase F: Forensic & Legal Hardening.

🔒 GLOBAL CONSTRAINTS (MANDATORY)

v1.0 GA hardening only

NO new features

NO schema changes unless strictly required

NO behavioral drift

Evidence integrity > presentation

Fail-closed behavior required

TASK 4 — ABSOLUTE REPORT DETERMINISM (GA BLOCKER)
Objective

Guarantee legal chain-of-custody by ensuring that a report generated for the same incident snapshot is bit-for-bit identical forever, regardless of when or where it is rendered.

Current Failure

PDF reports currently embed generation-time elements (e.g., datetime.now()), which causes:

Different file hashes for the same incident

Broken evidentiary chain

Legal inadmissibility

REQUIRED IMPLEMENTATION (STRICT)
1. Incident-Anchored Timestamps

All timestamps in reports MUST derive from:

Incident Snapshot Time OR

Incident Closure Time

❌ datetime.now() or system time is FORBIDDEN in report rendering

2. Branding Separation (CRITICAL)

Evidence layer (facts, timelines, hashes) defines the report hash

Branding / visuals (logo, CSS, theme) MUST NOT affect the hash

Mandatory Rule

Replacing the logo file MUST NOT change the report SHA256.

3. Deterministic Rendering Rules

Stable field ordering

Stable numeric formatting

Stable timestamp formatting

No random IDs

No environment-dependent metadata

REQUIRED TEST (GA-BLOCKING)

Generate Report A for Incident X

Wait 5 minutes

Generate Report B for Incident X

Assert:

SHA256(Report_A) == SHA256(Report_B)


Swap logo file

Re-render

Assert:

SHA256 unchanged

HARD RULES

❌ No dynamic timestamps

❌ No renderer-side entropy

❌ No branding mixed with evidence hash

✅ Evidence snapshot is the single source of truth

DELIVERABLES

Files modified (renderer / exporter)

Where system time was removed

How incident snapshot time is injected

How branding is excluded from hash domain

Determinism test (code or description)

ACCEPTANCE CRITERIA (LEGAL / GA BLOCKING)

Same incident → same hash forever

Logo swap → hash unchanged

Output is court-defensible

Respond only with:

Implementation approach

File paths

Key code excerpts

Determinism test explanation

PROMPT END


PROMPT 5 — SBOM & ARTIFACT SIGNING (AIR-GAP READY)

(MANDATORY GA GATE — MILITARY / GOV REQUIREMENT)

PROMPT START

You are working on RansomEye v1.0 GA – Audit Remediation Phase.
This is Phase B / F: Supply Chain & Artifact Integrity Hardening.

🔒 GLOBAL CONSTRAINTS (MANDATORY)

v1.0 GA hardening only

NO new features

NO build-system redesign

NO runtime behavior changes

Offline / air-gapped verification must be possible

Fail-closed installation

TASK 5 — SBOM GENERATION & ARTIFACT SIGNING (GA BLOCKER)
Objective

Enable offline, cryptographic verification of everything shipped to a customer.

An air-gapped military or government customer must be able to:

Inspect what is inside the release

Verify nothing was tampered with

Install only if verification succeeds

REQUIRED IMPLEMENTATION (STRICT)
1. Generate SBOM (manifest.json)

At build time, generate a machine-readable SBOM listing every shipped artifact.

Manifest MUST include for each artifact:

Artifact name

Artifact path (relative)

SHA256 hash

Artifact type (core, linux_agent, windows_agent, dpi_probe, etc.)

Example structure (illustrative):

{
  "version": "1.0.0",
  "build_id": "...",
  "artifacts": [
    {
      "name": "ransomeye-core",
      "path": "bin/core",
      "sha256": "...",
      "type": "core"
    }
  ]
}

2. Cryptographic Signing (ed25519)

Generate a manifest.json.sig using ed25519

Signature must cover the entire manifest.json

No placeholder keys

No test keys

Signing key must not be embedded in binaries

3. Installer Enforcement (FAIL-CLOSED)

Installer MUST:

Verify manifest.json.sig

Verify each artifact’s SHA256

Refuse installation if:

Signature invalid

Any artifact hash mismatch

Manifest missing

No warnings. No overrides.

HARD RULES

❌ No unsigned artifacts

❌ No “best effort” install

❌ No network access required for verification

✅ Offline verification only

✅ Deterministic manifest generation

DELIVERABLES

SBOM generation logic (build step or script)

Signing logic (ed25519)

Installer verification logic

File paths modified/added

Example manifest.json (redacted if needed)

ACCEPTANCE CRITERIA (GA BLOCKING)

Air-gapped system can verify artifacts offline

Tampered artifact → install fails

Invalid signature → install fails

Correct bundle → install succeeds

Respond only with:

Implementation approach

File paths

Key code excerpts

Confirmation of offline verification & fail-closed behavior

PROMPT END


PROMPT 6 — AGENT AUTONOMY (HEADLESS / FAIL-CLOSED MODE)

(FINAL GA GATE)

PROMPT START

You are working on RansomEye v1.0 GA – Audit Remediation Phase.
This is Phase F: Survivability & Autonomous Enforcement.

🔒 GLOBAL CONSTRAINTS (MANDATORY)

v1.0 GA hardening only

NO new features

NO new policy logic

NO relaxation of enforcement

Fail-closed is mandatory

Agent must never crash or fail open

TASK 6 — AGENT AUTONOMY WHEN CORE IS OFFLINE (GA BLOCKER)
Objective

Prove that endpoint agents remain secure, deterministic, and enforce policy even if the Core / C2 server is destroyed, unreachable, or under attack.

This is mandatory for:

Military deployments

Cyber-warfare survivability

Zero-trust enforcement

SCENARIO TO SIMULATE (MANDATORY TEST)

Agent starts normally and receives policy from Core

Core becomes unreachable (process killed / network severed)

A prohibited action is attempted on the endpoint

REQUIRED BEHAVIOR (STRICT)
1. Agent MUST NOT fail open

❌ Must NOT allow action because Core is unreachable

❌ Must NOT disable enforcement

❌ Must NOT crash

2. Agent MUST enforce last known good policy

Policy must be cached securely on disk

Cache must be integrity-checked at startup

Enforcement must continue without Core

3. If no policy exists

Agent must default to SAFE / DENY

Explicit log: “No policy available — default deny enforced”

HARD RULES

❌ No “allow all if disconnected”

❌ No silent degradation

❌ No best-effort mode

✅ Explicit autonomous enforcement

✅ Deterministic behavior

REQUIRED IMPLEMENTATION
Agent Side

Secure policy cache (existing mechanism if present)

Startup logic:

If Core reachable → normal operation

If Core unreachable → load cached policy

Integrity check before applying cached policy

Validation Test (GA-Blocking)

Create a severed-link validation scenario:

Start Agent

Kill Core

Attempt mock prohibited action

Assert:

Action is blocked

Agent logs explicit autonomous enforcement

Agent remains running

DELIVERABLES

Agent logic changes (if any)

Policy cache handling explanation

Validation test steps

Example logs (offline enforcement)

ACCEPTANCE CRITERIA (FINAL GA GATE)

Agent enforces policy without Core

No fail-open paths

No crash

Behavior is deterministic and logged

Respond only with:

Implementation approach

File paths

Key code excerpts

Validation test explanation

PROMPT END


PROMPT 7 — CORRELATION STATE MACHINE HARDENING

(CRITICAL LOGIC FIX — ENTERPRISE USABILITY GATE)

PROMPT START

You are working on RansomEye v1.0 GA – Audit Remediation Phase.
This is Phase C: Correlation Logic Hardening.

🔒 GLOBAL CONSTRAINTS (MANDATORY)

v1.0 GA hardening only

NO new detection rules

NO new data sources

NO schema changes unless strictly required

Fix engine logic only

Correlation > Isolation must be enforced

Deterministic behavior required

TASK 7 — CORRELATION STATE MACHINE & CONFIDENCE ACCUMULATION (GA BLOCKER)
Objective

Transform the Correlation Engine from a signal passthrough into a true aggregator that reduces false positives and is usable by enterprise SOC teams.

CURRENT FAILURE (FROM VALIDATION 07)

Single signal → Incident created

No state machine

No confidence accumulation

No deduplication

Violates “Correlation > Isolation”

This causes:

Massive alert fatigue

SOC abandonment

Product unusability in production

REQUIRED IMPLEMENTATION (STRICT)
1. INCIDENT STATE MACHINE

Implement explicit state transitions:

SUSPICIOUS → PROBABLE → CONFIRMED


Rules

Incidents are created only in SUSPICIOUS

Transitions require additional correlated evidence

No direct jump to CONFIRMED from a single signal

2. CONFIDENCE ACCUMULATION

Each correlated signal adds weighted confidence

Confidence must be incremental and bounded

Incident becomes actionable only when:

confidence_score >= CONFIRMATION_THRESHOLD


Threshold must be configurable (constant or env-based).

3. DEDUPLICATION (MANDATORY)

Signals with same logical identity (e.g. machine_id, process_id, time window):

MUST MERGE into a single incident

MUST NOT create duplicates

Incident ID must be stable for the same entity

4. CONTRADICTION HANDLING (LOGIC ONLY)

If contradictory evidence appears:

Confidence must decay

State must not escalate

Do not invent new contradiction rules — only enforce decay logic

HARD RULES

❌ No new detection rules

❌ No AI-driven decisions

❌ No single-signal confirmation

❌ No per-signal incidents

✅ Aggregation only

✅ Deterministic escalation

✅ SOC-usable output

DELIVERABLES

Correlation Engine logic changes

State transition logic

Confidence accumulation formula

Deduplication strategy

Example flow (multiple signals → single incident)

Validation test description

ACCEPTANCE CRITERIA (GA BLOCKING)

Single signal → SUSPICIOUS only

Multiple corroborating signals → PROBABLE / CONFIRMED

Same machine → one incident, not many

Alert volume reduced dramatically

Deterministic behavior

Respond only with:

Implementation approach

File paths

Key code excerpts

Example state transition flow

PROMPT END



PROMPT 8 — FINAL OPERATOR RUNBOOK

(ENTERPRISE / MILITARY HANDOFF — NON-CODE)

PROMPT START

You are working on RansomEye v1.0 GA – Final Enterprise Handoff.

🔒 GLOBAL CONSTRAINTS

NO code changes

NO architecture changes

Documentation only

Audience: Enterprise SOC, SRE, Security Ops, Military Operators

TASK 8 — GENERATE FINAL OPERATOR RUNBOOK
File: OPERATIONS_MANUAL.md
Objective

Produce a clear, authoritative operator manual that explains how to install, verify, operate, and audit RansomEye v1.0 in enterprise and military environments.

This document must assume:

Air-gapped deployments

Zero trust mindset

Auditors reading logs months later

REQUIRED CONTENT (MANDATORY)
1. INSTALLATION & SUPPLY CHAIN VERIFICATION

How to verify manifest.json and manifest.json.sig

How to run verify_sbom.py offline

What a FAILED SBOM verification means

Why installation is fail-closed by design

2. DATABASE BOOTSTRAP TROUBLESHOOTING

Meaning of PEER vs MD5 authentication

How to interpret db_bootstrap_validator errors

Where pg_hba.conf is typically located

What RansomEye will not auto-fix (by design)

3. VALIDATION & PLATFORM AWARENESS

Why Linux and Windows validation tracks are separated

How OS-aware validation prevents audit corruption

Common operator mistakes and how they are blocked

4. OPERATIONAL MONITORING (“GLASS COCKPIT”)

How to use /health/metrics

Meaning of:

HEALTHY

DEGRADED

CRITICAL

What CRITICAL implies operationally

What data is intentionally NOT exposed (privacy guarantees)

5. INCIDENT INTELLIGENCE & CONFIDENCE SCORES

Meaning of:

SUSPICIOUS

PROBABLE

CONFIRMED

How confidence scores accumulate

Why single events never become incidents

How this reduces alert fatigue

6. FORENSICS & LEGAL ADMISSIBILITY

How deterministic reports work

Why report hashes never change

How to prove chain-of-custody

How logo/branding does NOT affect evidence

7. SURVIVABILITY & AGENT AUTONOMY

What happens when Core is offline

Meaning of “GA-BLOCKING” logs

How agents enforce cached policy

Why default-deny is intentional

8. AUDIT & COMPLIANCE NOTES

Why fail-closed behavior exists everywhere

Why there is no “best effort” mode

How RansomEye aligns with military / gov expectations

STYLE REQUIREMENTS

Clear, precise, non-marketing language

No assumptions

No emojis

No buzzwords

Auditor-readable

Operator-usable at 3 AM during an incident

DELIVERABLE

Full OPERATIONS_MANUAL.md content

Structured sections

Ready to ship with the product

PROMPT END


Prompt Start

You are fixing PHASE 0 — INSTALLER & BOOTSTRAP TRUST for RansomEye.

Scope (STRICT)

You may ONLY modify:

Installer scripts

Bootstrap validation logic

Core startup validation

You may NOT:

Add features

Change architecture

Touch runtime logic beyond trust validation

Objective

Ensure it is impossible to install or start RansomEye insecurely.

Mandatory Fixes (ALL REQUIRED)

Remove ALL hardcoded credentials

"gagan" DB password

Test signing keys

Default secrets of any kind

Installer must FAIL-CLOSED

If required env vars are missing → exit non-zero

If weak secrets are detected → exit non-zero

If signing keys are missing → exit non-zero

Runtime trust alignment

Core startup must validate:

DB credentials present

Signing keys present

No test/default secrets

Core must refuse to start if validation fails

systemd alignment

systemd units must NOT start services if validation fails

No silent fallbacks

Files You MUST Inspect & Fix

(quote exact paths and lines)

installer/core/install.sh

installer/linux-agent/install.sh

installer/dpi-probe/install.sh

core/runtime.py (or equivalent startup validator)

Any shared secret utility used by installer/runtime

Evidence Required in Your Response

You MUST provide:

Exact code diffs

Before vs After behavior

Failure paths demonstrated

Why this satisfies Validation Files 01, 02, 13

If ANY hardcoded secret remains → your response is INVALID.

Do NOT proceed beyond Phase 0.

Prompt Ends



Prompt Start

You are fixing PHASE 1 — TRUST FOUNDATION (ZERO TRUST) for RansomEye.

This phase is BLOCKING.
Nothing else may proceed until this phase is fully PASS.

OBJECTIVE

Eliminate implicit trust and establish cryptographically enforced trust boundaries.

After this phase:

No service may talk to another without authentication

Ingest must reject unauthenticated telemetry

Database access must be least-privilege and scoped per service

MANDATORY FIXES (ALL REQUIRED)
1. Service-to-Service Authentication

Implement authenticated service identity for all internal service calls

No anonymous HTTP

No trust based on network location

Identity must be cryptographically verifiable

You must choose one:

mTLS

Signed service JWTs

Justify the choice.

2. Ingest Telemetry Authentication (CRITICAL)

Ingest MUST verify:

Telemetry signature

Component identity binding

Unsigned or spoofed telemetry MUST be rejected

Component field must NOT be trusted unless cryptographically bound

3. Per-Service Database Credentials

Enable schemas/08_db_users_roles.sql

Create separate DB users per service

Enforce least-privilege access

Remove any shared DB credentials

4. Credential Chain Integrity

Ensure:

Services cannot impersonate each other

Revocation is possible (key rotation support)

No credential reuse across trust domains

FILES YOU MUST INSPECT & MODIFY

(quote exact paths and lines)

services/ingest/app/main.py

services/*/app/main.py

schemas/08_db_users_roles.sql

DB connection config for each service

Any shared auth / crypto utilities

FORBIDDEN

No feature additions

No heuristics

No “temporary bypass”

No silent fallback

No TODOs

EVIDENCE REQUIRED IN YOUR RESPONSE

You MUST provide:

Exact code diffs

Authentication flow diagram (textual)

Before vs after trust model

Rejection paths (what fails, how, and why)

Explicit mapping to:

Validation File 03

Validation File 05

Validation File 17

If any service can still communicate unauthenticated → FAIL.

Prompt Ends



Prompt Start

You are fixing PHASE 2 — DETERMINISM RESTORATION for RansomEye.

This phase is BLOCKING.
No downstream work is allowed until this phase is PASS.

OBJECTIVE

Eliminate all non-deterministic behavior from ingest and correlation.

After this phase:

Replay of the same evidence MUST produce identical results

Event ordering MUST NOT depend on wall-clock time

Correlation MUST be replay-stable

MANDATORY FIXES (ALL REQUIRED)
1. Eliminate Non-Deterministic Time

You MUST:

Remove ALL usage of:

datetime.now()

SQL NOW()

No wall-clock mutation allowed

2. Deterministic Event Ordering

You MUST:

Introduce a deterministic sequence identifier for events

Ordering MUST be based on:

sequence number OR

deterministic hash ordering

ingested_at MUST NOT be used for ordering

3. Ingest Timestamp Model

You MUST:

Preserve original event time (event_time)

Use deterministic ingest sequence

Ensure replay produces identical timestamps

4. Correlation Replay Stability

You MUST:

Replace ORDER BY ingested_at

Ensure correlation produces:

identical incident graphs

identical transitions

identical IDs
on replay

FILES YOU MUST INSPECT & MODIFY

(quote exact paths and lines)

services/ingest/app/main.py

schemas/01_raw_events.sql

services/correlation-engine/app/db.py

Any SQL using NOW() or ordering by ingest time

FORBIDDEN

No heuristics

No “best effort” ordering

No randomness

No time-based mutation

No partial fixes

EVIDENCE REQUIRED IN YOUR RESPONSE

You MUST provide:

Exact code diffs

Old vs new ordering logic

Replay proof explanation (why it is identical)

Explicit mapping to:

Validation File 04

Validation File 06

Validation File 07

If any replay can differ → FAIL.

Prompt Ends



Prompt Start

You are fixing PHASE 3 — CORRELATION LOGIC & AI PROVENANCE for RansomEye.

This phase is SEQUENTIAL and depends on Phase 2 being PASS (now satisfied).

OBJECTIVE

Make detection, escalation, and AI outputs provable, replayable, and explainable.

After this phase:

Incidents MUST progress through a formal state machine

Confidence MUST accumulate deterministically

Contradictions MUST be detected and handled

AI outputs MUST be reproducible from stored artifacts

MANDATORY FIXES (ALL REQUIRED)
1. Correlation State Machine

You MUST implement a deterministic state machine:

CLEAN → SUSPICIOUS → PROBABLE → CONFIRMED


Rules:

Transitions MUST be explicit

Guards MUST be deterministic

No time-based escalation

No single-signal CONFIRMED

2. Confidence Accumulation Model

You MUST:

Define signal weights

Accumulate confidence deterministically

Implement saturation & decay rules

Prevent single-signal escalation

3. Contradiction Detection

You MUST detect and act on contradictions:

Host vs Network

Execution vs Timing

Persistence vs Silence

Deception vs Absence

Contradictions MUST:

Block escalation OR

Downgrade confidence deterministically

4. AI Model Provenance

You MUST:

Persist trained models (not retrain silently)

Persist full SHAP explanations (not just hashes)

Store:

model version

training data hash

SHAP artifact hash

Ensure replay produces identical AI output

FILES YOU MUST INSPECT & MODIFY

(quote exact paths and lines)

services/correlation-engine/app/*

services/ai-core/app/*

AI model storage / registry code

SHAP persistence logic

FORBIDDEN

No heuristics

No probabilistic shortcuts

No “best effort” explanations

No runtime retraining without persistence

EVIDENCE REQUIRED IN YOUR RESPONSE

You MUST provide:

State machine definition (textual + code)

Confidence accumulation math

Contradiction handling logic

AI provenance storage proof

Replay proof (why same inputs → same AI output)

Mapping required to:

Validation File 07

Validation File 08

Validation File 16

If any AI output cannot be re-derived → FAIL.

Prompt Ends


Prompt Start

You are fixing PHASE 4 — POLICY AUTHORITY & RESPONSE EXECUTION for RansomEye.

This phase is SEQUENTIAL and depends on Phase 3 being PASS (now satisfied).

OBJECTIVE

Ensure no response action can execute unless:

It is cryptographically signed

The signing authority is valid

The policy explicitly authorizes it

The endpoint can verify it

MANDATORY FIXES (ALL REQUIRED)
1. Single Signing Standard (CRITICAL)

You MUST:

Eliminate all non-ed25519 signing

Policy Engine, Threat Response Engine, and Agents MUST use ed25519 only

No HMAC. No exceptions.

2. Policy Authority Validation

You MUST:

Bind every command to:

policy_id

policy_version

issuing authority

Verify authority before execution

Reject unsigned or unauthorized commands

3. Windows Agent Enforcement

You MUST:

Remove placeholder verification

Implement real ed25519 verification

Reject commands that fail verification

No soft-fail allowed.

4. Replay & Audit Anchoring

You MUST:

Ensure every command execution:

emits audit ledger entry

references explanation bundle

is replay-verifiable

FILES YOU MUST INSPECT & MODIFY

(quote exact paths and lines)

services/policy-engine/app/*

services/threat-response-engine/*

agents/linux/*

agents/windows/*

Command signing & verification utilities

FORBIDDEN

No mixed signing algorithms

No “temporary allow”

No implicit trust

No placeholder logic

No runtime bypass

EVIDENCE REQUIRED IN YOUR RESPONSE

You MUST provide:

Signing flow (policy → TRE → agent)

Exact signing & verification code

Rejection paths

Audit anchoring proof

Mapping required to:

Validation File 09

Validation File 10

If any command can execute without verification → FAIL.

Prompt Ends



